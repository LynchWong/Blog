<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swift on Nobodyknows&#43; 2.5</title>
    <link>http://lynchwong.com/tags/swift/index.xml</link>
    <description>Recent content in Swift on Nobodyknows&#43; 2.5</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://lynchwong.com/tags/swift/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>最近的代码</title>
      <link>http://lynchwong.com/2016/06/%E6%9C%80%E8%BF%91%E7%9A%84%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Thu, 02 Jun 2016 11:35:40 +0000</pubDate>
      
      <guid>http://lynchwong.com/2016/06/%E6%9C%80%E8%BF%91%E7%9A%84%E4%BB%A3%E7%A0%81/</guid>
      <description>&lt;p&gt;这三个小项目其实已经完成蛮久了，差不多一个多月的时间了。有发在Cocoachina的代码里面，我的&lt;a href=&#34;https://github.com/LynchWong&#34;&gt; GitHub &lt;/a&gt;上面也有源码。这里也只是作下记录，不做详细的讲解。
&lt;/p&gt;

&lt;h1 id=&#34;仿-爱范儿-客户端&#34;&gt;仿 爱范儿 客户端&lt;/h1&gt;

&lt;p&gt;仿 爱范儿 客户端，使用UIViewController容器、UIScrollView实现，使用 SnapKit 布局。&lt;/p&gt;

&lt;p&gt;实现左右滚动，顶部标题滚动，缩小视图，下拉刷新(上拉加载未实现)。&lt;/p&gt;

&lt;p&gt;说明：由于水平和思路的差异导致视觉效果上有些差异，除此之外还有些功能未实现(如 更多栏目)，请使用CocoaPods添加依赖库。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/LynchWong/mifanr&#34;&gt; 源码 &lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;圆圈按钮&#34;&gt;圆圈按钮&lt;/h1&gt;

&lt;p&gt;自动布局，随意配制按钮个数和外观。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/LynchWong/CircleMenu&#34;&gt; 源码 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/RecentCoding/demo.gif&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;播放器&#34;&gt;播放器&lt;/h1&gt;

&lt;p&gt;这个播放器是基于VLC的MobileVLCKit开发的，使用Swift。是我自己做的一个App，去年就上架到App Store了，最近空闲就小更新了下。&lt;/p&gt;

&lt;p&gt;MobileVLCKit功能强大，这个App只用到皮毛。实现了一些基本的功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href=&#34;https://github.com/swisspol/GCDWebServer&#34;&gt; GCDWebServer &lt;/a&gt;来进行本地视频上传到播放器。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实现简单的播放、暂停、快进、后退、左侧上下滑动屏幕调节亮度、右侧上下滑动屏幕调节音量、左右扫动进度调节。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;没有支持播放远程视频，不支持外挂字幕，不支持截屏等其他功能。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;后续可能会添加这些功能的支持。&lt;/p&gt;

&lt;p&gt;项目App Store地址：
&lt;a href=&#34;https://itunes.apple.com/us/app/jian-yi-bo-fang-qi-ji-jian/id1059131009?ls=1&amp;amp;mt=8&#34;&gt;简易播放器 - 极简播放器&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/LynchWong/ePlayer&#34;&gt; 源码 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/RecentCoding/intro.gif&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IWILLTools</title>
      <link>http://lynchwong.com/2016/01/iwilltools/</link>
      <pubDate>Sun, 10 Jan 2016 18:45:43 +0000</pubDate>
      
      <guid>http://lynchwong.com/2016/01/iwilltools/</guid>
      <description>&lt;p&gt;上篇博文也说了最近在构建一个自己的代码库，主要就是一些iOS开发中会经常用到的一些代码。使用&lt;strong&gt;Swift&lt;/strong&gt;构建，基于iOS8.0，相信很多代码在iOS7上也是可以正常工作的。这部分代码并不适合当作第三方库添加到项目中，最好作为参考使用，所以我也就没添加&lt;strong&gt;Carthage&lt;/strong&gt;和&lt;strong&gt;CocoaPods&lt;/strong&gt;的支持。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/MyPot/IWILLTools&#34;&gt; IWILLTools &lt;/a&gt;
&lt;/p&gt;

&lt;h1 id=&#34;transitionanimate&#34;&gt;TransitionAnimate&lt;/h1&gt;

&lt;p&gt;Controller间的转场动画，目前添加了Push &amp;amp; Pop以及模态的转场动画。&lt;/p&gt;

&lt;p&gt;主要参考的这篇文章， &lt;a href=&#34;http://www.cocoachina.com/ios/20150719/12600.html&#34;&gt; 关于自定义转场动画，我都告诉你 &lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;第三种&lt;strong&gt;Segue&lt;/strong&gt;的方式这里没做。&lt;/p&gt;

&lt;h1 id=&#34;uicollectionviewlayout&#34;&gt;UICollectionViewLayout&lt;/h1&gt;

&lt;p&gt;实现了圆圈的布局，另外一个还未实现。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/majiakun1/article/details/17204921&#34;&gt; UICollectionViewLayout &lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&#34;cache&#34;&gt;Cache&lt;/h1&gt;

&lt;p&gt;缓存默认存储在&lt;strong&gt;IWCache&lt;/strong&gt;文件夹中。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func cacheExistsWithdestinationPath(url: NSURL) -&amp;gt; (filePath: String, isExists: Bool)&lt;/code&gt;方法会判断URL是否缓存过。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func dataWithURL(url: NSURL, finish: Finish)&lt;/code&gt;方法会缓存这个URL。&lt;/p&gt;

&lt;h1 id=&#34;audioplayer&#34;&gt;AudioPlayer&lt;/h1&gt;

&lt;p&gt;音频播放：支持播放本地音频和网络音频。&lt;/p&gt;

&lt;p&gt;本地音频支持播放完成后的回调。&lt;/p&gt;

&lt;p&gt;远程音频支持播放进度和缓存。&lt;/p&gt;

&lt;h1 id=&#34;videoplayer&#34;&gt;VideoPlayer&lt;/h1&gt;

&lt;p&gt;TODO&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;net&#34;&gt;Net&lt;/h1&gt;

&lt;p&gt;使用&lt;strong&gt;NSURLSession&lt;/strong&gt;完成网络请求、下载和上传。&lt;/p&gt;

&lt;p&gt;实现了网络请求、下载。上传还未测试。&lt;/p&gt;

&lt;h1 id=&#34;type&#34;&gt;Type&lt;/h1&gt;

&lt;p&gt;类型。&lt;/p&gt;

&lt;h1 id=&#34;extension&#34;&gt;Extension&lt;/h1&gt;

&lt;p&gt;拓展。&lt;/p&gt;

&lt;h1 id=&#34;utility&#34;&gt;Utility&lt;/h1&gt;

&lt;p&gt;文件工具类和设备信息工具类。&lt;/p&gt;

&lt;p&gt;之后会不断的进行完善。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>UIButton传递参数</title>
      <link>http://lynchwong.com/2015/08/uibutton%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sun, 09 Aug 2015 16:23:22 +0000</pubDate>
      
      <guid>http://lynchwong.com/2015/08/uibutton%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</guid>
      <description>&lt;p&gt;今天开发自己项目的时候有个需求，需要&lt;strong&gt;UIButton&lt;/strong&gt;的Action传递多个参数。项目里的实际需求是需要传递&lt;strong&gt;NSIndexPath&lt;/strong&gt;，如果只需要section或者row那很好办，设置tag就可以了。但是两个都需要，所以就要传递对象过去了。这里就涉及到了OBJC运行时，使用关联对象就很好办了。
&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/chenglibin1988/article/details/27549925&#34;&gt; 【iOS】UIButton 传递多个参数的方法 &amp;mdash;&amp;ndash;使用关联函数 &lt;/a&gt;
&lt;a href=&#34;http://stackoverflow.com/questions/13397258/how-to-add-a-method-with-multiple-parameters-to-the-selector-of-a-button&#34;&gt;How to add a method with multiple parameters to the selector of a button&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里给出两个连接，讲解的很详细，我就不罗嗦了，代码也很简单。&lt;/p&gt;

&lt;p&gt;最后贴出我自己的部分代码，Swift版的，仅作参考：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var AssociatedKey = &amp;quot;IndexPath&amp;quot;
objc_setAssociatedObject(cell!.checkButton, &amp;amp;AssociatedKey, indexPath, UInt(OBJC_ASSOCIATION_RETAIN_NONATOMIC))

func uncheck(sender: UIButton) {
    var indexPath = objc_getAssociatedObject(sender, &amp;amp;AssociatedKey) as! NSIndexPath
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>SpriteKit：Scenes</title>
      <link>http://lynchwong.com/2015/04/spritekitscenes/</link>
      <pubDate>Thu, 23 Apr 2015 23:20:32 +0000</pubDate>
      
      <guid>http://lynchwong.com/2015/04/spritekitscenes/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;最近这周时间比较忙，空闲的时候看了看苹果官方的编程指南。发现有很多东西都是之前忽略掉的，或者就是根本不知道的。看完之后感觉收获良多，在某些方面有恍然大悟之感。其实刚开始学iOS的时候去看一些官方文档可能并没有多少作用，到了一定程度回头再去看得时候就觉得很清晰、很有逻辑。这些编程指南就像一些经典书籍一样，不同的时间回去看就会有不同的收获，这些书籍能随着时间跟随我们一起成长，我们需要做得就是细细的品，不时的回头看看，思考。看书还是多看经典的好，这也是为什么有的人觉得看了那么多书，却感觉没什么用，就是因为经典看的少。&lt;/p&gt;

&lt;p&gt;装了下逼，心情就更舒畅了。SpriteKit这个系列还有很多内容，估计写起来还要花很多时间。所以后面我会穿插一些其他的内容，比如一些阅读编程指南后的感悟，或者就是翻译下编程指南。网上有很多博主已经翻译了很多编程指南，有些可能版本已经对不上了，内容跟现在的有些差异。我会参考这些翻译的指南，重新整理。&lt;/p&gt;

&lt;p&gt;再多说一点，写SpriteKit这个系列，并没有教大家怎样完整的做一个游戏。主要的还是理论、概念方面的讲解，所以当作资料或者工具来使用比较好。同时还是推荐大家&lt;a href=&#34;http://www.raywenderlich.com/store/ios-games-by-tutorials&#34;&gt;iOS Games by Tutorials Second Edition&lt;/a&gt;这本书，它有5个完整的游戏Demo，对大家的学习更有帮助。这本书跟大家推荐过很多次了，后面不会再提了。&lt;/p&gt;

&lt;p&gt;回到主题，这章就讲讲场景和视差滚动这两个内容。&lt;/p&gt;

&lt;h2 id=&#34;场景&#34;&gt;场景&lt;/h2&gt;

&lt;p&gt;通常继承&lt;code&gt;SKScene&lt;/code&gt;，然后实现&lt;code&gt;init(size:)&lt;/code&gt;, &lt;code&gt;update()&lt;/code&gt;, &lt;code&gt;touchesBegan(withEvent:)&lt;/code&gt;或者其他一些你需要的方法。&lt;/p&gt;

&lt;p&gt;还是打开之前的项目，选择*File\New\File&amp;hellip;*，*iOS\Source\Swift File*，点击*Next*，输入*GameOverScene*点击*Save As*。然后打开*GameOverScene.swift*文件替换成如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import SpriteKit

class GameOverScene: SKScene {

    override func didMoveToView(view: SKView) {
        backgroundColor = SKColor.grayColor()
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里将场景的背景色设置为灰色，所以当切换到这个场景时就是灰色的背景。&lt;/p&gt;

&lt;h2 id=&#34;切换场景&#34;&gt;切换场景&lt;/h2&gt;

&lt;p&gt;首先我们将&lt;code&gt;GameScene.swift&lt;/code&gt;的替换成如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import SpriteKit

class GameScene: SKScene {

    let ship = SKSpriteNode(imageNamed: &amp;quot;Spaceship&amp;quot;)

    override func didMoveToView(view: SKView) {
        ship.position = CGPoint(x: size.width / 2, y: size.height / 2)
        addChild(ship)
    }

    override func touchesBegan(touches: Set&amp;lt;NSObject&amp;gt;, withEvent event: UIEvent) {
        let touch = touches.first as! UITouch
        let location = touch.locationInNode(self)
        if CGRectContainsPoint(ship.frame, location) {
            let scene = GameOverScene(size: CGSize(width: 750.0, height: 1334.0))
            scene.scaleMode = scaleMode
            let transition = SKTransition.flipHorizontalWithDuration(0.5)
            view?.presentScene(scene, transition: transition)
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码很简单，相信大家都能看懂。首先我们设置场景的&lt;code&gt;scaleMode&lt;/code&gt;为同一个模式，确保有相同的行为。多说一句，有四个值可以选，大家可以⌘点击进去看下具体的描述，这里就不一一解释了。当我们点击飞船精灵的内部时，我们就会从当前这个场景过渡到我们新创建的&lt;code&gt;GameOverScene&lt;/code&gt;场景。&lt;/p&gt;

&lt;p&gt;从一个场景过渡到另一个场景只需要三个步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;*创建新场景。*首先，创建新场景的实例。通常我们用默认的初始化方法&lt;code&gt;init(size:)&lt;/code&gt;，我们也可以使用自己定义的初始化方法，同时也可以传递额外的参数。&lt;/li&gt;
&lt;li&gt;*创建过渡对象。*然后，你创建过渡对象来指定用来显示新场景时的动画类型。比如，淡入淡出、翻转等等。&lt;/li&gt;
&lt;li&gt;*调用SKView的 presentScene(transition:) 方法。*在iOS中，&lt;code&gt;SKView&lt;/code&gt;就是&lt;code&gt;UIView&lt;/code&gt;，在屏幕上显示SpriteKit的内容。你可以用场景的属性&lt;code&gt;view&lt;/code&gt;来访问它。然后将第一步和第二部创建的参数传递给这个方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有很多过渡用的动画，大家自行测试。&lt;/p&gt;

&lt;h2 id=&#34;创建自定义的场景构造器&#34;&gt;创建自定义的场景构造器&lt;/h2&gt;

&lt;p&gt;替换``为如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import SpriteKit

class GameOverScene: SKScene {

    override init(size: CGSize) {
        super.init(size: size)
        backgroundColor = SKColor.yellowColor()
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError(&amp;quot;init(coder:) has not been implemented&amp;quot;)
    }

    //    override func didMoveToView(view: SKView) {
    //        backgroundColor = SKColor.grayColor()
    //    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;init(size: CGSize)&lt;/code&gt;这个构造器是从写的父类的，而且这个构造器是指定构造器。如果之前Swift的相关文章看过，这里就涉及到构造器链、以及两段式构造这些概念。指定构造器总是向上代理的，便利构造器总是横向代理的。指定构造器需要在本类所有属性初始化完成后调用父类的指定构造器，避免赋值的属性被父类从新赋值了；便利构造器需要先调用本类的指定构造器然后再对属性赋值，避免赋值的属性被本类的指定构造器从新赋值了，所以要先调用。由于我们没有属性需要初始化，所以直接调用了父类的指定构造器，然后在设置背景颜色为黄色。如果你先设置了背景颜色为黄色，然后再调用父类的指定构造器，编译器就会报错：Use of &amp;lsquo;self&amp;rsquo; in property access &amp;lsquo;backgroundColor&amp;rsquo; before super.init initializes self。这里就是两段式构造的概念了，在Swift里面，我们不需要显示的使用&lt;code&gt;Self&lt;/code&gt;这个关键字。其实这个&lt;code&gt;backgroundColor = SKColor.yellowColor()&lt;/code&gt;就相当于是&lt;code&gt;self.backgroundColor = SKColor.yellowColor()&lt;/code&gt;。编译器这里也解释了，在调用父类的指定构造器之前是不能使用&amp;rsquo;self&amp;rsquo;的。另一方面，指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没有这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。所以在写自定义构造器时，最好先弄明白构造器链、以及两段式构造这些概念。&lt;/p&gt;

&lt;h2 id=&#34;背景层滚动&#34;&gt;背景层滚动&lt;/h2&gt;

&lt;p&gt;大家肯定都见过视差滚动了，很多游戏都用了这个技术。比如大家常玩的一些打飞机类的游戏，就有视差滚动。背景层以一个稳定的速度向着一个方向移动，从上向下或者从左往右，当多个背景层以不同的速度移动的时候就实现了远近的感觉。&lt;/p&gt;

&lt;p&gt;这里我们讲讲怎么简单的实现一个背景层循环滚动，多个背景层滚动就是类似的，不做讲解。其实实现背景层循环滚动有很多种方法，因人而异，但是原理都是差不多的，随便讲解一种。&lt;/p&gt;

&lt;p&gt;还是使用之前的那个项目，最后会上传这个简单的Demo。&lt;/p&gt;

&lt;p&gt;首先我们添加一张背景图片，尺寸就是我们设置的场景的大小。然后替换&lt;code&gt;GameScene.swift&lt;/code&gt;内容为如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import SpriteKit

class GameScene: SKScene {

    let background = SKSpriteNode(imageNamed: &amp;quot;bg&amp;quot;)
    let background1 = SKSpriteNode(imageNamed: &amp;quot;bg&amp;quot;)

    override func didMoveToView(view: SKView) {
        background.anchorPoint = CGPointZero
        addChild(background)

        background1.anchorPoint = CGPointZero
        background1.position = CGPoint(x: 0.0, y: background.size.height)
        addChild(background1)
    }

    override func update(currentTime: NSTimeInterval) {
        if background.position.y &amp;lt;= -background.size.height {
            background.position.y = background.size.height
        }
        if background1.position.y &amp;lt;= -background1.size.height {
            background1.position.y = background1.size.height
        }
        background.position.y -= 1
        background1.position.y -= 1
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;点击运行就能看到效果了，代码很简单。主要原理就是判断背景的y坐标是否超过了那个临界值，然后再设置背景的y坐标，这样就实现了循环滚动。&lt;a href=&#34;https://github.com/LynchWong/Test&#34;&gt;Demo&lt;/a&gt;，示例很简单。很多视差滚动的原理都是类似的，大家可以自行封装下达到重用的目的。&lt;/p&gt;

&lt;p&gt;由于&lt;code&gt;SKNode&lt;/code&gt;本身是不会绘制内容的，所以在SpriteKit里面我们常常使用&lt;code&gt;SKNode&lt;/code&gt;来管理、组织我们场景里面的一些内容，就像cocos2d里面的&lt;code&gt;CCLayer&lt;/code&gt;。比如一个游戏，我们把背景组织放在一层，当作背景层，放在场景的最下面（设置zPositionsh属性）；然后玩家角色和其他的敌人等放在另外一层，放在场景背景层上面；最后我们将一些UI元素，比如按钮、标签等组织在UI层，放在场景的最上面。这些更方便我们来管理场景，同时操作也更方便。但是这些里面有一些地方时需要注意的，就是坐标问题。比如我们玩家角色需要和背景层里面的一些精灵交互，但是现在两个精灵在不同的层里面，那边位置坐标肯定是不一样的，所以我们应该将两个精灵的坐标转换到同一个坐标系统，不管是玩家角色转换到背景层还是背景层的转换到角色层。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;backgroundLayer.convertPoint(CGPoint(x: size.width, y: CGRectGetMaxY(playableRect)), fromNode: self)

//将场景坐标系统中得一个点转换到backgroundLayer的坐标系统。
backgroundLayer.convertPoint( background.position, toNode: self)

//将backgroundLayer的点转换到场景坐标系统。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据需求选择不同的方法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SpriteKit：Actions</title>
      <link>http://lynchwong.com/2015/04/spritekitactions/</link>
      <pubDate>Wed, 15 Apr 2015 10:31:17 +0000</pubDate>
      
      <guid>http://lynchwong.com/2015/04/spritekitactions/</guid>
      <description>&lt;p&gt;上篇介绍了一些SpriteKit的基本概念，也介绍了怎么添加精灵到场景里面。但精灵在场景里都是静态的，我们还没有让它们动起来。所以这篇就讲讲怎么让精灵动起来，让游戏更生动。
&lt;/p&gt;

&lt;p&gt;有两种方法可以让精灵动起来：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;我们可以让精灵运行动作，在SpriteKit里面动作用&lt;code&gt;SKAction&lt;/code&gt;这个类来表示。比如一些简单的动作，移动，缩放，旋转，跟随等。你可以将简单的动作组合起来，成为一个序列；你也可以指定动作执行的次数或者循环执行；你也可以自定义动作等等。&lt;/li&gt;
&lt;li&gt;我们可以根据时间来手动设置精灵的位置。之前有提到过&lt;code&gt;GameScene.swift&lt;/code&gt;里面有个&lt;code&gt;update(currentTime: NSTimeInterval)&lt;/code&gt;方法，SpriteKit每帧都会自动调用这个方法。所以，在这个方法里根据时间设置精灵的位置是个不错的选择。但是这个方法的效果有时候不会很理想，特别是当帧率不稳定的时候，我们后边再讲。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以接下来我们就具体的看看这两种方法，我们先用第二种方法。&lt;/p&gt;

&lt;h2 id=&#34;使用update方法来移动精灵&#34;&gt;使用update方法来移动精灵&lt;/h2&gt;

&lt;p&gt;我们还是接着上次使用的项目来继续，如果没有了，新建一个也很快，只需添加一个精灵到场景中即可。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GameViewController.swift&lt;/code&gt;代码如下，只是删除了一些现在用不到的东西：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import SpriteKit

class GameViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        let scene = GameScene(size: CGSize(width: 750.0, height: 1334.0))
        let skView = self.view as! SKView
        skView.showsFPS = true
        skView.showsNodeCount = true
        skView.ignoresSiblingOrder = true
        scene.scaleMode = .AspectFill
        skView.presentScene(scene)
    }
    override func prefersStatusBarHidden() -&amp;gt; Bool {
        return true
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GameScene.swift&lt;/code&gt;的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import SpriteKit

class GameScene: SKScene {

    let ship = SKSpriteNode(imageNamed: &amp;quot;Spaceship&amp;quot;)

    override func didMoveToView(view: SKView) {
        backgroundColor = SKColor.whiteColor()
        ship.position = CGPoint(x: size.width / 2, y: size.height / 2)
        addChild(ship)
    }

    override func update(currentTime: NSTimeInterval) {
        ship.position.y += 1.0
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我将精灵声明为了GameScene的属性，其次我在update方法中更新精灵位置的y坐标，每帧增加1。⌘R运行后的效果就是飞船精灵由屏幕的正中间向上飞行，当然，看起来像是在飞行。这里我就不贴图了。&lt;/p&gt;

&lt;p&gt;也许大家都注意到了屏幕右下角的一些信息，1 node 60.0fps，这里分别表示当前屏幕内有多少个节点，每秒绘制多少次。Frames per second (FPS)，表示每秒绘制的次数，值越高越好。通常来说游戏都会尽量保持30 ~ 60的FPS以保证动画的流畅，当低于30的时候就会感觉到呆滞。&lt;/p&gt;

&lt;p&gt;这里我们需要研究SpriteKit每帧都做了些什么事情，官方文档&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html&#34;&gt;About Sprite Kit&lt;/a&gt;开篇就讲了这个问题，看下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitActions/1.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;SpriteKit提供了图形渲染和动画基础，你可以用来使任意的纹理图像或者精灵动起来。SpriteKit使用传统的渲染循环，每一帧的内容会在这一帧渲染之前处理。你的游戏决定了场景的内容，以及场景内容在每一帧中怎么改变。SpriteKit使用图形硬件高效的绘制动画的每一帧。翻译的不好，大概意思就是这样。&lt;/p&gt;

&lt;p&gt;从图中可以看出调用update方法只是每一帧执行内容的一部分，除此之外还有很多其他的事情，最后才是渲染整个场景。这里就先不说其他的，后面需要的时候会再说。SpriteKit会尽量快得绘制每一帧，让FPS尽量的接近60。然而，如果你得update方法花了太多的时间，或者SpriteKit一次绘制了草果硬件能够处理的节点数量，FPS就会下降。而这下降就意味着两次调用update方法之间的时间间隔是不一样的，这就导致了我们精灵的位置始终是在我们期望的位置附近波动的。即使我们保持60FPS时，两次update方法之间的时间间隔仍然是波动的。只是这时波动较小，肉眼难以从动画中看出差别。&lt;/p&gt;

&lt;p&gt;接下来，我们添加代码来打印出两次方法调用之间的时间间隔：&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;GameScene.swift&lt;/code&gt;方法中添加如下两个属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var lastUpdateTime: NSTimeInterval = 0
var dt: NSTimeInterval = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在update方法中添加如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if lastUpdateTime &amp;gt; 0 {
    dt = currentTime - lastUpdateTime
} else {
    dt = 0
}
lastUpdateTime = currentTime
println(&amp;quot;\(dt*1000) milliseconds since last update&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;控制台输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;16.6635850000603 milliseconds since last update
16.6687409982842 milliseconds since last update
15.7276280006045 milliseconds since last update
17.6131959997292 milliseconds since last update
15.7501659996342 milliseconds since last update
17.1622560010292 milliseconds since last update
17.1266059987829 milliseconds since last update
15.6556320034724 milliseconds since last update
16.7910149975796 milliseconds since last update
16.4657300010731 milliseconds since last update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出是波动的，虽然是毫秒单位，人眼难以识别，但是毫秒对计算机来说已经是相当的一段时间了。所以这种波动的时间导致动画效果就如下图所示：图片来自&lt;a href=&#34;http://www.raywenderlich.com/store/ios-games-by-tutorials&#34;&gt;iOS Games by Tutorials Second Edition&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitActions/2.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;总会在我们期望的准确位置附近波动。我们接下来就来修复这个问题：&lt;/p&gt;

&lt;p&gt;首先我们保持update方法足够的快，应当避免在update方法里面执行复杂的算法；其次让场景中节点的数量越少越好，比如移除屏幕外的和不再需要的节点。&lt;/p&gt;

&lt;p&gt;下面我们添加一个movePointsPerSec属性到&lt;code&gt;GameScene.swift&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let movePointsPerSec: CGFloat = 480.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后修改update方法代码如下所示；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func update(currentTime: NSTimeInterval) {
    if lastUpdateTime &amp;gt; 0 {
        dt = currentTime - lastUpdateTime
    } else {
        dt = 0
    }
    lastUpdateTime = currentTime
    println(&amp;quot;\(dt*1000) milliseconds since last update&amp;quot;)
    ship.position.y += movePointsPerSec * CGFloat(dt)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们根据两次调用的时间差乘以期望每秒移动的距离，然后再加上原来位置的y坐标值，而不是像原来直接增加一个固定的值。&lt;/p&gt;

&lt;p&gt;示例很简单，是单坐标抽的移动，实际情况更复杂。但是思想是一样的，也能推导出来。比如，我想让飞船移动到我手指点击的那个点。首先我们在&lt;code&gt;touchesBegan&lt;/code&gt;方法里面获取点击的坐标位置，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func touchesBegan(touches: Set&amp;lt;NSObject&amp;gt;, withEvent event: UIEvent) {
    let touch = touches.first as! UITouch
    let touchLocation = touch.locationInNode(self)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有必要说一下，由于更新Swift1.2和Xcode6.3的原因，这个方法跟之前不一样了。原来是这样的&lt;code&gt;touchesBegan(touches: NSSet, withEvent event: UIEvent)&lt;/code&gt;，用&lt;code&gt;let touch = touches.anyObject() as UITouch&lt;/code&gt;获取&lt;code&gt;UITouch&lt;/code&gt;对象。简单的查了下集合类&lt;code&gt;Set&lt;/code&gt;的API改成上面那样获取&lt;code&gt;UITouch&lt;/code&gt;对象。包括as!，应该是Swift1.2版本更新的内容。这里先不说了，Xcode6.3也提供了方法将之前的Swift版本代码转变到最新版本的代码，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitActions/3.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;试了下效果貌似不理想，可能是我使用方法不对，没做深究，大家自己试试。&lt;/p&gt;

&lt;p&gt;添加一个&lt;code&gt;velocity&lt;/code&gt;属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var velocity = CGPointZero
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后添加吐下代码到&lt;code&gt;touchesBegan&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let offset = CGPoint(x: touchLocation.x - ship.position.x, y: touchLocation.y - ship.position.y)
let length = sqrt(Double(offset.x * offset.x + offset.y * offset.y))
let unit = CGPoint(x: offset.x / CGFloat(length), y: offset.y / CGFloat(length))
velocity = CGPoint(x: unit.x * movePointsPerSec, y: unit.y * movePointsPerSec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们首先计算点击的点到当前精灵位置的差值，然后利用勾股定理计算出两点之间的距离，这些我想大家都懂了，要是忘了去搜下，或者自己用手画画坐标系，模拟计算下两点之间的距离。然后我们计算出单位向量，这个单位向量是以原来精灵的位置为坐标原点的，希望大家能理解。最后我们用单位向量乘以每秒期望移动的距离，最后得出一个速度。每当点击屏幕的时候，我们都会计算出一个速度。&lt;/p&gt;

&lt;p&gt;最后修改&lt;code&gt;update&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func update(currentTime: NSTimeInterval) {
    if lastUpdateTime &amp;gt; 0 {
        dt = currentTime - lastUpdateTime
    } else {
        dt = 0
    }
    lastUpdateTime = currentTime
    println(&amp;quot;\(dt*1000) milliseconds since last update&amp;quot;)
    let amountToMove = CGPoint(x: velocity.x * CGFloat(dt), y: velocity.y * CGFloat(dt))
    ship.position = CGPoint(x: ship.position.x + amountToMove.x, y: ship.position.y + amountToMove.y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们用速度乘以时间差得出需要移动的距离，然后再加上精灵当前的位置。运行后就会发现精灵会向我们点击的点得方法移动，且会一直移动下去。怎么让精灵只移动到我们点击的点，大家自己试试。以及旋转飞机指向飞机前进的方向。&lt;/p&gt;

&lt;h2 id=&#34;skaction&#34;&gt;SKAction&lt;/h2&gt;

&lt;p&gt;注释掉&lt;code&gt;update&lt;/code&gt;和&lt;code&gt;touchesBegan&lt;/code&gt;方法，我们现在通过&lt;code&gt;SKAction&lt;/code&gt;来移动精灵。&lt;/p&gt;

&lt;h3 id=&#34;move-action&#34;&gt;Move action&lt;/h3&gt;

&lt;p&gt;修改&lt;code&gt;didMoveToView&lt;/code&gt;方法中的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func didMoveToView(view: SKView) {
    backgroundColor = SKColor.whiteColor()
    ship.position = CGPoint(x: size.width / 2, y: size.height / 2)
    ship.setScale(0.5)
    addChild(ship)

    let actionMove = SKAction.moveTo(CGPoint(x: ship.position.x, y: size.height), duration: 2.0)
    ship.runAction(actionMove)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过调用&lt;code&gt;SKAction&lt;/code&gt;的类方法来创建一个动作，如上创建的动作会使节点在指定的时间内移动到指定的点。精灵通过调用&lt;code&gt;runAction()&lt;/code&gt;方法来执行动作，任何SKNode节点都可以调用&lt;code&gt;runAction()&lt;/code&gt;。运行后就会看到飞船精灵从屏幕中心点移动到屏幕上方的中点。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;moveTo(duration:)&lt;/code&gt;方法会移动在指定时间移动节点到指定的位置，除此方法之外还有其他的移动精灵的方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;moveToX(duration:)&lt;/code&gt;和&lt;code&gt;moveToY(duration:)&lt;/code&gt;这两个移动方法会根据指定的x轴和y轴的值来移动，而其他的保持不变。比如上面的实例我们也可以用&lt;code&gt;moveToY(duration:)&lt;/code&gt;这个方法实现。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;moveByX(y:duration:)&lt;/code&gt;。“move to”的方法会移动精灵到指定的位置，但是有时候根据偏移量来移动精灵也是很方便的。比如上面的示例我们也可以用这个方法实现，传递“0”给x轴，传递“size.height / 2”给y轴。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;区别如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitActions/4.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;“[action] to”和“[action] by”这两种模式在其他种类的动作中也存在。比如“scale to”、“scale by”、“rotate by”、“rotate to”等等，大家运用的时候多看看方法说明。&lt;/p&gt;

&lt;p&gt;有时候我们可以通过&lt;code&gt;extension&lt;/code&gt;来拓展一个类添加新的功能。但是&lt;code&gt;SKAction&lt;/code&gt;类无法拓展，创建action的唯一方法就是调用&lt;code&gt;SKAction&lt;/code&gt;的相应的类方法。&lt;/p&gt;

&lt;h3 id=&#34;sequence-action&#34;&gt;Sequence action&lt;/h3&gt;

&lt;p&gt;单个动作有时满足不了我们的需求，需要完成一个动作之后接着执行另一个动作。我们需要把一连串的动作排成一个序列，然后让节点执行这个动作。&lt;code&gt;SKAction&lt;/code&gt;提供了相应的方法来满足这个需求。&lt;/p&gt;

&lt;p&gt;修改&lt;code&gt;didMoveToView()&lt;/code&gt;方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func didMoveToView(view: SKView) {
    backgroundColor = SKColor.whiteColor()
    ship.position = CGPoint(x: size.width / 2, y: size.height / 2)
    ship.setScale(0.5)
    addChild(ship)

    let moveUp = SKAction.moveByX(0, y: 100, duration: 1.0)
    let zoom = SKAction.scaleTo(2.0, duration: 0.25)
    let wait = SKAction.waitForDuration(0.5)
    let fadeAway = SKAction.fadeOutWithDuration(0.25)
    let removeNode = SKAction.removeFromParent()

    let sequence = SKAction.sequence([moveUp, zoom, wait, fadeAway, removeNode])
    ship.runAction(sequence)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;稍微讲下涉及到的一两个动作，将动作序列起来也很简单，大家应该一看就能领悟，动作的效果大家运行便知：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;wait 通常用到序列里面。这个动作只是简单的等待一段时间，然后就结束。&lt;/li&gt;
&lt;li&gt;removeNode 动作是瞬时的，没有执行时间。虽然这个动作是序列的一部分，你会看到这个动作并没有出现在下面序列的时间线里面。作为瞬时动作，在 fadeAway 动作结束了就开始，然后马上就结束了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitActions/5.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;group-action&#34;&gt;Group action&lt;/h3&gt;

&lt;p&gt;“group action”是一组动作的集合，当节点开始执行“group action”时，所有的动作都开始执行。修改&lt;code&gt;didMoveToView()&lt;/code&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func didMoveToView(view: SKView) {
    backgroundColor = SKColor.whiteColor()
    ship.position = CGPoint(x: size.width / 2, y: size.height / 2)
    ship.setScale(0)
    addChild(ship)


    let animate = SKAction.animateWithTextures([SKTexture(imageNamed: &amp;quot;Spaceship&amp;quot;)], timePerFrame: 2.0)
    let moveDown = SKAction.moveByX(0, y: -200, duration: 2.0)
    let scale = SKAction.scaleTo(1.0, duration: 1.0)
    let fadeIn = SKAction.fadeInWithDuration(1.0)

    let group = SKAction.group([animate, moveDown, scale, fadeIn])
    ship.runAction(group)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitActions/6.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图展示了“group action”的时间线，可以看出和“sequence action”的区别。“group action”里面的动作在同一时间开始执行，单个动作的结束时间取决于自己的执行时间，“group action”的执行时间取决于执行时间最长的动作。&lt;/p&gt;

&lt;h3 id=&#34;repeating-sequence-action&#34;&gt;Repeating Sequence action&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;override func didMoveToView(view: SKView) {
    backgroundColor = SKColor.whiteColor()
    ship.position = CGPoint(x: size.width / 2, y: size.height / 2)
    ship.setScale(0.5)
    addChild(ship)


    let fadeOut = SKAction.fadeOutWithDuration(1)
    let fadeIn = SKAction.fadeInWithDuration(1)
    let pulse = SKAction.sequence([fadeOut,fadeIn])

    let pulseThreeTimes = SKAction.repeatAction(pulse, count: 3)
    ship.runAction(pulseThreeTimes)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码很简单，下图展示了 pulseThreeTimes 动作的时间线。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitActions/7.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;repeating-group-action&#34;&gt;Repeating Group action&lt;/h3&gt;

&lt;p&gt;修改&lt;code&gt;didMoveToView()&lt;/code&gt;方法如下，循环执行一个“group action”：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func didMoveToView(view: SKView) {
    backgroundColor = SKColor.whiteColor()
    ship.position = CGPoint(x: size.width / 2, y: size.height / 2)
    ship.setScale(0.5)
    addChild(ship)


    let animate = SKAction.animateWithTextures([SKTexture(imageNamed: &amp;quot;Spaceship&amp;quot;)], timePerFrame: 2.0)
    let moveDown = SKAction.moveByX(0, y: -200, duration: 2.0)

    let group = SKAction.sequence([animate, moveDown])
    let repeat = SKAction.repeatActionForever(group)
    ship.runAction(repeat)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下图展示了 repeat 动作的时间线。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitActions/8.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;group-repeat-action&#34;&gt;Group repeat action&lt;/h3&gt;

&lt;p&gt;标题的名字是不是有点让人糊涂了，但是仔细理解，认真看代码就能明白是什么意思了。这个标题的意思就是把重复动作用group组合起来。修改&lt;code&gt;didMoveToView()&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func didMoveToView(view: SKView) {
    backgroundColor = SKColor.whiteColor()
    ship.position = CGPoint(x: size.width / 2, y: size.height / 2)
    ship.setScale(0.5)
    addChild(ship)


    let animate = SKAction.animateWithTextures([SKTexture(imageNamed: &amp;quot;Spaceship&amp;quot;)], timePerFrame: 1.0)
    let moveDown = SKAction.moveByX(0, y: -200, duration: 2.0)

    let repeatAnimation = SKAction.repeatActionForever(animate)
    let repeatMove = SKAction.repeatActionForever(moveDown)

    let group = SKAction.group([repeatAnimation, repeatMove])
    ship.runAction(group)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下图展示了 group 动作的时间线。其实group很好理解，完全可以理解为组合中得动作是互不相干的，这样思考起来可能就简单些了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitActions/9.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;run-block-action&#34;&gt;Run block action&lt;/h3&gt;

&lt;p&gt;有时我们希望运行一段block代码，比如我想在序列运行结束的时候打印一段log。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    let moveDown = SKAction.moveByX(0, y: -200, duration: 2.0)
    let logMessage = SKAction.runBlock() {
        println(&amp;quot;down 200.0!&amp;quot;)
    }
    ship.runAction(SKAction.sequence([moveDown, logMessage]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;控制台输出&lt;code&gt;down 200.0!&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;reversed-actions&#34;&gt;Reversed actions&lt;/h3&gt;

&lt;p&gt;上一个示例让精灵节点下移，现在我又想让精灵节点返回去。最直接的方法就是再创建一个上移的动作就可实现，但是我们有更好的选择。通过在指定的动作上调用&lt;code&gt;reversedAction()&lt;/code&gt;方法可以逆转这个动作，返回一个和原来动作对立的新动作。&lt;/p&gt;

&lt;p&gt;如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitActions/10.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不是所有的动作都是可逆的，比如&lt;code&gt;moveTo(duration:)&lt;/code&gt;就不是的。要知道一个动作是否是可逆的，请查看苹果的官方文档的说明。如果在不可逆的动作上调用了&lt;code&gt;reversedAction()&lt;/code&gt;方法，会返回原来的动作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    let moveDown = SKAction.moveByX(0, y: -200, duration: 2.0)
    let reversed = moveDown.reversedAction()        
    ship.runAction(SKAction.sequence([moveDown, reversed]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样的“sequence action”也是可逆的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    let moveDown = SKAction.moveByX(0, y: -200, duration: 2.0)
    let reversed = moveDown.reversedAction()
    let sequence = SKAction.sequence([moveDown, reversed])
    ship.runAction(SKAction.sequence([sequence, sequence.reversedAction()]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码，演示性不强，大家自行修改下动作让掩饰性更强些。“sequence action”的&lt;code&gt;reversedAction()&lt;/code&gt;方法，逆转了序列的顺序，也逆转了序列的每一个动作。上面代码的 sequence 动作的逆转，第一个动作就是 reversed 动作的逆转，第二个动作就是 moveDown 动作的逆转。可以得出 sequence 动作的逆转和 sequence 本身是一样的，所示最后运行的效果就像是执行了两遍 sequence 动作一样。&lt;/p&gt;

&lt;h3 id=&#34;animation-action&#34;&gt;Animation action&lt;/h3&gt;

&lt;p&gt;这个动作在前面我们已经用过了，就是这个样子的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let animate = SKAction.animateWithTextures([SKTexture(imageNamed: &amp;quot;Spaceship&amp;quot;)], timePerFrame: 2.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要运行这个动作，我们首先需要一组纹理。SpriteKit是通过纹理来展示图片的，用&lt;code&gt;SKTexture&lt;/code&gt;类表示。我们之前通过图片来创建精灵，其实SpriteKit还是先用图片创建了纹理，然后再将纹理赋值给精灵的&lt;code&gt;texture&lt;/code&gt;属性。我们可以在程序运行的时候随意改变精灵的&lt;code&gt;texture&lt;/code&gt;属性。实际上，“animation action”就是根据我们提供的那组纹理，以及timePerFrame参数来自动的为我们改变精灵的&lt;code&gt;texture&lt;/code&gt;属性。创建方法如上面代码所示，由于找不到美术资源，随意创建的。然后就像其他的动作一样在节点上运行。&lt;/p&gt;

&lt;p&gt;这个方法是我们以后会经常用到的，比如在游戏里面看见一些角色常常有一些基本的动作动画，这些就可以用这个动作实现。&lt;/p&gt;

&lt;h3 id=&#34;stopping-action&#34;&gt;Stopping action&lt;/h3&gt;

&lt;p&gt;在运行动作的时候，我们可以给动作一个key。之前调用&lt;code&gt;runAction()&lt;/code&gt;方法，现在&lt;code&gt;runAction(withKey:)&lt;/code&gt;方法替代，我们就可以调用&lt;code&gt;removeActionForKey()&lt;/code&gt;方法来停止一个动作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ship.runAction(moveDown, withKey: &amp;quot;MoveDown&amp;quot;)
ship.removeActionForKey(&amp;quot;MoveDown&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;scale-action&#34;&gt;Scale action&lt;/h3&gt;

&lt;p&gt;这个动作和前面我们用的“move to”的模式是很像的，这里就不上代码了，有几点需要注意下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;scaleXTo(duration:), scaleYTo(duration:) 和 scaleXTo(y:duration:): 这些可以允许你独立的缩放x或者y轴，可以用来实现拉伸、挤压一个节点的效果。&lt;/li&gt;
&lt;li&gt;scaleBy(duration:): 这个方法缩放的倍数是由当前节点的缩放倍数乘以传递过去的参数，通常我们没有设置缩放倍数时默认都是1.0。比如现在我传递过去的参数是2.0，那么现在就会变为原来的2倍，如果我再调用这个方法，就会变为4倍。所以如果我们一开始精灵的缩放倍数就是0，你调用这个方法始终都是0。&lt;/li&gt;
&lt;li&gt;scaleXBy(y:duration:): 允许你延x和y轴独立的缩放。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;sound-action&#34;&gt;Sound action&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;runAction(SKAction.playSoundFileNamed(&amp;quot;xxxx&amp;quot;, waitForCompletion: false))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个动作是用来播放音效的，通常运行在当前的场景节点上。&lt;/p&gt;

&lt;h3 id=&#34;sharing-actions&#34;&gt;Sharing actions&lt;/h3&gt;

&lt;p&gt;SpriteKit的动作是可以共享的，是SpriteKit很强大的。如果你像上面那样直接在需要的时候初始化一个音效，然后再来播放。很多时候第一次可能会卡顿，这是由于加载音频文件的原因。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SKAction&lt;/code&gt;对象本身并没有维持什么状态，所以我们可以同时在任意多个节点上重用动作。比如我们创建了一个子弹发射出去的动作，我们可能创建很多个子弹精灵，但是这个动作只需一个就够了，我们可以将这个动作运行到不同的子弹精灵上。&lt;/p&gt;

&lt;p&gt;其实解决音频卡顿的问题也很简单，可以将播放音效的动作赋值为当前场景的一个属性，在场景初始化的时候就初始化了这个动作，然后在需要的时候运行就可以了。&lt;/p&gt;

&lt;h2 id=&#34;结束&#34;&gt;结束&lt;/h2&gt;

&lt;p&gt;最后要讲得就是我们最开始的时候给了一张游戏渲染循环的一张图，如下，我还是贴出来：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitActions/1.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;之前我们讲了&lt;code&gt;update&lt;/code&gt;方法，要讲得就是接下来的。这里我们先做个假设，比如我们场景中有两个精灵，一个是我们的玩家角色，另外一个是怪物。怪物精灵执行动作从屏幕右边出现往屏幕左边移动。现在我们要检测这两个精灵的碰撞，我们在&lt;code&gt;update&lt;/code&gt;方法里面获取两个精灵的“frame”属性，然后调用&lt;code&gt;CGRectIntersectsRect(rect1: CGRect, rect2: CGRect)&lt;/code&gt;方法来检测两个精灵是否有交叉的地方，如果有就说明有碰撞。后面我们会利用SpriteKit的物理引擎来检测碰撞，这里就先这样做了。&lt;/p&gt;

&lt;p&gt;有了这个假设我们再仔细的看看上面的那个图，主要看&lt;code&gt;update&lt;/code&gt;后面的那两段。虽然不知道到底是干嘛，但是大致能想到跟action有关系。&lt;code&gt;-didEvaluateActions&lt;/code&gt;应该也是个方法。Evaluate查了下有个求值的意思，那么这个方法的大概意思就是已经对action求值了。那么在我们上面描述的逻辑中就有一个Bug存在，首先我们是在&lt;code&gt;update&lt;/code&gt;方法里面检测碰撞的，其次怪物精灵是通过执行动作来移动。而那时还没有对action求值，也就是说怪物精灵的位置还没有计算成最新的，获取的怪物CGRect值也不是最新的，任然是上一帧的，所以我们的检测总是慢了一帧。所以我们应该在&lt;code&gt;-didEvaluateActions&lt;/code&gt;方法里面获取两个精灵的“frame”属性，然后调用&lt;code&gt;CGRectIntersectsRect(rect1: CGRect, rect2: CGRect)&lt;/code&gt;方法来检测两个精灵是否有交叉的地方。&lt;/p&gt;

&lt;p&gt;这种情况可能对于一些游戏来说没有什么影响，人眼也难以区别这两者之间的不同。但是有的游戏可能就很容易区别出来，最好还是知道这一点。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SpriteKit：简介</title>
      <link>http://lynchwong.com/2015/04/spritekit%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sun, 12 Apr 2015 16:40:05 +0000</pubDate>
      
      <guid>http://lynchwong.com/2015/04/spritekit%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;前一段时间一直都在看这本书&lt;a href=&#34;http://www.raywenderlich.com/store/ios-games-by-tutorials&#34;&gt;iOS Games by Tutorials Second Edition&lt;/a&gt;，本想SpriteKit这个系列把书中的章节全部翻译过来就好了。但是书是需要购买的，有版权，包括书中配套的源码和艺术资源都是不能共享给别人的。所以这个系列还是得自己写，质量应该不会很高，仅供入门用用，高手不要喷。当然还是推荐大家去看这种原版书籍，支持正版。
&lt;/p&gt;

&lt;p&gt;我们就直接从新建一个项目开始吧，当前操作系统版本是10.10.3，Xcode是6.3，Swift的版本应该是1.2。&lt;/p&gt;

&lt;h2 id=&#34;创建spritekit项目&#34;&gt;创建SpriteKit项目&lt;/h2&gt;

&lt;p&gt;打开Xcode，我们选择&lt;strong&gt;Create a new Xcode project&lt;/strong&gt;，然后选择&lt;strong&gt;iOS&lt;/strong&gt;中&lt;strong&gt;Application&lt;/strong&gt;的&lt;strong&gt;Game&lt;/strong&gt;选项,点击&lt;strong&gt;Next&lt;/strong&gt;，在选项框中填好对应的选项，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitIntro/1.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们语言选择Swift，这里多说一句。我自己的项目现在都是用Swift写，公司项目还是用OC，毕竟OC更稳定。不过觉得Swift是趋势，会成为主流，所以早点学习更好。&lt;strong&gt;Game Technology&lt;/strong&gt;选择SpriteKit，下拉选项里面还有SceneKit、Metal和OpenGL ES。SceneKit带来了3D引擎和一些增强功能。Metal可以说是跟OpenGL ES类似的东西，只不过只适用于苹果的平台，对苹果的硬件有特别的优化，并且很多游戏引擎如Unity3D都支持了Metal。OpenGL ES是一个编程接口规范，在不同的平台有不同的实现，直接和GPU打交道，属于比较底层的API。在以前没有引擎的时候，那些游戏开发的大神都是基于OpenGL ES开发游戏。&lt;strong&gt;Devices&lt;/strong&gt;这项选择Universal，即iPhone和iPad都适用。&lt;/p&gt;

&lt;p&gt;我们点击&lt;strong&gt;Next&lt;/strong&gt;，然后&lt;strong&gt;Create&lt;/strong&gt;，创建后的项目结构截图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitIntro/2.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;点击上面那个三角形的按钮Build and Run，或者快捷键⌘R，模拟器选择iPhone 6。效果图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitIntro/3.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;每次点击屏幕都会增加一个旋转的飞机到场景里面。&lt;/p&gt;

&lt;p&gt;所以我们打开GameScene.swift文件去看看源代码。&lt;code&gt;didMoveToView()&lt;/code&gt;方法会在SpriteKit将你的场景展示到View之前调用；所以这个方法是你初始化场景内容的一个好地方。&lt;code&gt;update()&lt;/code&gt;方法是SpriteKit每一帧都会自动调用的，这个方法里面会处理一些游戏逻辑。&lt;code&gt;touchesBegan()&lt;/code&gt;方法处理用户对屏幕的操作。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html&#34;&gt;SpriteKit Programming Guide&lt;/a&gt;这里讲解了SpriteKit的很多基本原理及编程指南，中文版的应该也能搜到，建议大家看下。&lt;/p&gt;

&lt;p&gt;将GameScene.swift文件内容替换成如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import SpriteKit

class GameScene: SKScene {
    override func didMoveToView(view: SKView) {
        backgroundColor = SKColor.whiteColor()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在创建SpriteKit项目的时候，模板会自动创建GameScene.sks文件。你可以用Xcode新的内建的编辑器编辑这个文件，用来可视化展示你的游戏场景。这个场景编辑器对于SpriteKit来说就像Interface Builder对于UIKit一样。后面学习粒子系统时候也会用到这个场景编辑器。现在我们删除这个文件，使用代码创建场景。邮件选择文件删除，&lt;strong&gt;Move to Trash&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;打开GameViewController.swift文件，删除如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension SKNode {
    class func unarchiveFromFile(file : String) -&amp;gt; SKNode? {
        if let path = NSBundle.mainBundle().pathForResource(file, ofType: &amp;quot;sks&amp;quot;) {
            var sceneData = NSData(contentsOfFile: path, options: .DataReadingMappedIfSafe, error: nil)!
            var archiver = NSKeyedUnarchiver(forReadingWithData: sceneData)

            archiver.setClass(self.classForKeyedUnarchiver(), forClassName: &amp;quot;SKScene&amp;quot;)
            let scene = archiver.decodeObjectForKey(NSKeyedArchiveRootObjectKey) as! GameScene
            archiver.finishDecoding()
            return scene
        } else {
            return nil
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仔细看看这段代码就会发现是用来加载上面提到的.sks文件的，所以这里就不需要了，后面用到.sks文件加载场景的时候就需要用到这段代码了。替换GameViewController.swift的内容为如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import SpriteKit

class GameViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        let scene = GameScene(size: CGSize(width: 750.0, height: 1334.0))
        let skView = self.view as! SKView
        skView.showsFPS = true
        skView.showsNodeCount = true
        skView.ignoresSiblingOrder = true
        scene.scaleMode = .AspectFill
        skView.presentScene(scene)
    }
    override func prefersStatusBarHidden() -&amp;gt; Bool {
        return true
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;添加精灵到场景中&#34;&gt;添加精灵到场景中&lt;/h2&gt;

&lt;p&gt;当制作2D游戏时，我们通常会把图片放到场景中来代表我们游戏中各种各样的元素：英雄，敌人，子弹，怪物等等。所有这些我们都称作为“精灵”。现在我们来添加第一个精灵，打开GameScene.swift文件修改&lt;code&gt;didMoveToView()&lt;/code&gt;方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func didMoveToView(view: SKView) {
    backgroundColor = SKColor.whiteColor()
    let ship = SKSpriteNode(imageNamed: &amp;quot;Spaceship&amp;quot;)
    addChild(ship)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改背景颜色为白色，然后用飞船的图片初始化了一个精灵，然后添加到场景中。⌘R启动模拟器，效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitIntro/4.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;设置精灵位置&#34;&gt;设置精灵位置&lt;/h2&gt;

&lt;p&gt;飞船的位置跟大家期望的肯定不一样，这里有几点需要说明一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;SpriteKit的坐标系统和UIKit的是不一样的，UIKit的坐标原点在左上角，SpriteKit的坐标原点在左下角。&lt;/li&gt;
&lt;li&gt;对于没有设置位置（属性为position）的精灵，SpriteKit默认设置为(0, 0)。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以飞船的位置就出现在了左下角的坐标原点处。现在我们将飞船位置设置到正中间，在添加到场景前添加如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ship.position = CGPoint(x: size.width / 2, y: size.height / 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⌘R运行，飞船就显示到正中间了，这里就不贴图了。&lt;/p&gt;

&lt;h2 id=&#34;精灵的anchorpoint属性&#34;&gt;精灵的anchorPoint属性&lt;/h2&gt;

&lt;p&gt;也许大家注意到了，在设置飞船精灵的位置时，相当于是把精灵的中点设置到了那个位置。跟UIKit里面也是不一样的，这种效果是由精灵的anchorPoint属性决定。当没有设置精灵的anchorPoint属性时，SpriteKit默认设置为(0.5, 0.5)。anchorPoint是一个点，取值范围从0 ~ 1。默认(0.5, 0.5)即表示中点；(0.0, 0.0)的时候表示左下角；(1.0, 1.0)的时候表示右上角；大家可以依次类推。&lt;/p&gt;

&lt;p&gt;下图展示了不同anchorPoint的值时，精灵的位置：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitIntro/5.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们注释掉之前设置精灵位置的代码，然后设置精灵的anchorPoint为(0.0, 0.0)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ship.anchorPoint = CGPoint(x: 0.0, y: 0.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模拟器效果如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitIntro/6.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因为我们注释掉了设置位置的代码，所以SpriteKit默认设置了position属性为(0.0, 0.0)。然后设置了anchorPoint为(0.0, 0.0)，效果就如上图中间一样，只是position变为了原点，而不是中点。所以大家就看到了飞船完整的出现在了原点的位置。如果将anchorPoint为(1.0, 1.0)，大家就看不到飞船了，大家可以试下。现在大家也可以解释为什么最开始的时候只有飞船的右上部分出现在屏幕上。大家可以设置不同的position和anchorPoint然后看看不同的飞船位置，以确保自己理解了anchorPoint。&lt;/p&gt;

&lt;p&gt;通常情况下，大家都可以不用管anchorPoint，SpriteKit会默认设置为(0.5, 0.5)，除非你需要精灵按照你指定的点进行旋转，后面我们会提到。&lt;/p&gt;

&lt;p&gt;简单点说就是：当你设置精灵的位置时，默认的你就是设置了精灵的中点到那个位置。&lt;/p&gt;

&lt;h2 id=&#34;旋转精灵&#34;&gt;旋转精灵&lt;/h2&gt;

&lt;p&gt;添加如下代码在添加精灵到场景之前：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ship.zRotation = CGFloat(M_PI) / 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/SpriteKitIntro/7.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;zRotation属性接受弧度值，类型为&lt;code&gt;CGFloat&lt;/code&gt;，这里&lt;code&gt;M_PI&lt;/code&gt;是&lt;code&gt;Double&lt;/code&gt;类型，所以使用&lt;code&gt;CGFloat&lt;/code&gt;把&lt;code&gt;M_PI&lt;/code&gt;转换成&lt;code&gt;Double&lt;/code&gt;。弧度值换乘以180然后除以π就是角度值；角度值乘以π然后除以180就是弧度值。所以这个角度值就是22.5度。&lt;/p&gt;

&lt;p&gt;这里是围绕anchorPoint旋转的，所以这里anchorPoint的作用就显示出来了。大家设想一下，比如我有一个人物较色，我需要旋转角色的手臂，那么我就需要设置人物手臂的anchorPoint到关节处。&lt;/p&gt;

&lt;h2 id=&#34;精灵的尺寸&#34;&gt;精灵的尺寸&lt;/h2&gt;

&lt;p&gt;有时我们需要知道精灵的尺寸，精灵默认的尺寸就是图片的大小。在SpriteKit中，我们用纹理代表图片。添加如下代码到&lt;code&gt;didMoveToView()&lt;/code&gt;方法的最后来获取飞船精灵的大小。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let shipSize = ship.size
println(&amp;quot;Size: \(shipSize)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行之后控制台会输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Size: (394.0, 347.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;精灵和节点&#34;&gt;精灵和节点&lt;/h2&gt;

&lt;p&gt;如果我们要精灵显示在屏幕上，我们就需要将精灵添加为场景的子节点，或者子节点的子节点。&lt;/p&gt;

&lt;p&gt;所有出现在屏幕上得元素都是&lt;code&gt;SKNode&lt;/code&gt;的子类，值得注意的是&lt;code&gt;SKNode&lt;/code&gt;并不绘制实际的内容。场景类(&lt;code&gt;SKScene&lt;/code&gt;)也继承自&lt;code&gt;SKNode&lt;/code&gt;，精灵类（&lt;code&gt;SKSpriteNode&lt;/code&gt;）同样也继承自&lt;code&gt;SKNode&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这里推荐给大家&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKNode_Ref/index.html#//apple_ref/doc/uid/TP40013023&#34;&gt;SKNode Class Reference&lt;/a&gt;，这里面有&lt;code&gt;SKNode&lt;/code&gt;得很多属性和方法的讲解，同时也讲解了一些&lt;code&gt;SKNode&lt;/code&gt;的使用技巧，比如用来管理场景内容等。这里就不赘述了。&lt;/p&gt;

&lt;p&gt;每个节点都有一个叫作zPosition的属性，默认值为0。每个节点绘制子节点都是按照zPosition值得顺序绘制的，即从小到大。在GameViewController.swift中我们设置了ignoresSiblingOrder属性为true。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;skView.ignoresSiblingOrder = true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果ignoresSiblingOrder属性为true，当一个节点中的两个子节点有相同的zPosition值时，SpriteKit无法保证绘制的顺序。如果ignoresSiblingOrder属性为false，SpriteKit会按照添加到父节点的顺序绘制。通常设置为true更好一些，因为SpriteKit会做一些优化使游戏运行的更快。&lt;/p&gt;

&lt;p&gt;如果ignoresSiblingOrder属性为true，我们最好不要设置相同的zPosition值。比如我们有一个表示背景的精灵，那我们应该设置其zPosition值为-1来避免背景覆盖了玩家精灵。&lt;/p&gt;

&lt;p&gt;这章主要就讲了一些很基础的东西，还有一些大家可能需要注意的东西。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SpriteKit：引言</title>
      <link>http://lynchwong.com/2015/04/spritekit%E5%BC%95%E8%A8%80/</link>
      <pubDate>Sun, 12 Apr 2015 15:04:36 +0000</pubDate>
      
      <guid>http://lynchwong.com/2015/04/spritekit%E5%BC%95%E8%A8%80/</guid>
      <description>&lt;p&gt;对于一个想学习游戏开发的新手来说，我觉得第一件事首先就是选择一款游戏引擎。如果你想从构建游戏引擎开始着手来开发一款游戏，对个人开发者以及一些小团队来说真的是有点小题大做了，毕竟免费得游戏引擎很多，而且大多都很优秀，背后有强有力的团队在更新和维护。所以我觉得结合自己的条件，以及游戏的特点选择合适的游戏引擎是很好的选择。
&lt;/p&gt;

&lt;p&gt;所以我们先来分析自身的条件：首先鄙人是做iOS App的开发，对iOS的开发虽谈不上精通，但很熟悉，所以我希望开发移动端的手游（规模不大，一个人能完成最好，偏向于2D游戏）；其次鄙人一直都想在空余闲暇的时候做游戏开发，纯粹点说就是个人爱好而已，觉得自己和朋友能玩上鄙人开发的小游戏是一件很有成就感的事情；最后就是游戏运行在多平台上这个需求不是很在意，所以引擎的跨平台性对我来说不是很重要。&lt;/p&gt;

&lt;p&gt;分析完自身条件，我们再来列举一些现在主流的一些移动端的游戏开发引擎，然后选出对自己最优的那个。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Cocos2D系列&lt;/li&gt;
&lt;li&gt;Unity3D&lt;/li&gt;
&lt;li&gt;SpriteKit&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;光Cocos2D系列就有很多个版本的引擎，最先的游戏引擎就是Cocos2D-iPhone这样的，那时针对不同的平台有不同的Cocos2D引擎对应，开发者需要根据不同的平台选择不同的引擎版本。近年来由于跨平台的需求，所以Cocos2D-x的份额越来越大。在Cocos2D-x下还有很多不同语言的版本，比如Cocos2D-lua、JS等，这些脚本语言开发起来更简单、更快速。而lua语言的的简单性和热更新使得Cocos2D-lua大受欢迎，而IDE环境的支持，功能的不断更新大大降低了开发的难度以及开发者的工作量。Cocos2D-x的跨平台性，完整的生态圈，强大的技术支持使得它成为国内手游厂商的最佳选择。而Cocos2D-iPhone随着单一的平台支持、以及苹果在iOS7.0时推出自家引擎后慢慢的淡出了大家的视线。貌似现在Cocos2D-iPhone和SpriteBuilder整合在一起了。&lt;/p&gt;

&lt;p&gt;Unity3D是近年来得一匹大黑马，抢占了移动端3D游戏引擎的大部分份额，一些很有名的移动端手游都是基于Unity3D开发。这匹黑马搞得很多传统大牌的桌面端引擎厂商都慌了，纷纷推出自家移动端的游戏引擎。Unity3D的优势不仅跨平台，还提供了可视化的IDE环境。同时还提供了很多超级棒的子系统，比如物理引擎、粒子系统、动画系统等等，同时还提供了很多有用的资源。Pro版是需要购买授权的，貌似4.0开始有免费版的可以选择使用。如果你得游戏能火，授权费跟游戏赚得钱根本不值一提，专业版还是值得考虑的。&lt;/p&gt;

&lt;p&gt;SpriteKit是苹果在iOS7.0的时候推出的，缺点当然就是不跨平台了。优点对于iOS开发者来说，我到觉得是一大推，根本就不需要说了。其实很早之前就有系统学习过Cocos2D-iPhone，后来学习SpriteKit的时候上手就很快，感觉很多东西都是类似的，概念都是相同的。SpriteKit是2D的，在iOS8.0的时候苹果又推出了SceneKit和Metal。&lt;/p&gt;

&lt;p&gt;说了这么多，我最后的选择就是SpriteKit，因为我不需要跨平台，其次偏向于2D小游戏。我觉得学会一种游戏引擎，然后再转向另一种应该也不会太难。就像精通了一门语言，再学另一门语言一样。&lt;/p&gt;

&lt;p&gt;接下来就开始学习SpriteKit，开始之前还是推荐一本书给大家&lt;a href=&#34;http://www.raywenderlich.com/store/ios-games-by-tutorials&#34;&gt;iOS Games by Tutorials Second Edition&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Swift之高级运算符</title>
      <link>http://lynchwong.com/2015/03/swift%E4%B9%8B%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Sat, 07 Mar 2015 23:24:32 +0000</pubDate>
      
      <guid>http://lynchwong.com/2015/03/swift%E4%B9%8B%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>&lt;p&gt;除了在之前介绍过的基本运算符,Swift 中还有许多可以对数值进行复杂操作的高级运算符。这些高级运算符包含 了在 C 和 Objective-C 中已经被大家所熟知的位运算符和移位运算符。
&lt;/p&gt;

&lt;p&gt;与C语言中的算术运算符不同,Swift 中的算术运算符默认是不会溢出的。所有溢出行为都会被捕获并报告为错 误。如果想让系统允许溢出行为,可以选择使用 Swift 中另一套默认支持溢出的运算符,比如溢出加法运算 符( &amp;amp;+ )。所有的这些溢出运算符都是以 &amp;amp; 开头的。&lt;/p&gt;

&lt;p&gt;在定义自有的结构体、类和枚举时,最好也同时为它们提供标准Swift运算符的实现。Swift简化了运算符的自定 义实现,也使判断不同类型所对应的行为更为简单。&lt;/p&gt;

&lt;p&gt;我们不用被预定义的运算符所限制。在 Swift 当中可以自由地定义中缀、前缀、后缀和赋值运算符,以及相应的 优先级与结合性。这些运算符在代码中可以像预设的运算符一样使用,我们甚至可以扩展已有的类型以支持自定 义的运算符。&lt;/p&gt;

&lt;h2 id=&#34;位运算符&#34;&gt;位运算符&lt;/h2&gt;

&lt;p&gt;位运算符( Bitwise operators )可以操作一个数据结构中每个独立的位。它们通常被用在底层开发中,比如图形编 程和创建设备驱动。位运算符在处理外部资源的原始数据时也十分有用,比如对自定义通信协议传输的数据进行 编码和解码。&lt;/p&gt;

&lt;p&gt;Swift 支持C语言中的全部位运算符,具体如下:&lt;/p&gt;

&lt;p&gt;按位取反运算符&lt;/p&gt;

&lt;p&gt;按位取反运算符( ~ ) 可以对一个数值的全部位进行取反:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSAdvancedOperators/1.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;按位取反操作符是一个前置运算符,需要直接放在操作数的之前,并且它们之间不能添加任何空格。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let initialBits: UInt8 = 0b00001111
let invertedBits = ~initialBits  // equals 11110000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UInt8 类型的整数有 8 个比特位,可以存储 0 ~ 255之间的任意整数。这个例子初始化了一个 UInt8 类型的整 数,并赋值为二进制的 00001111 ,它的前 4 位都为 0 ,后 4 位都为 1 。这个值等价于十进制的 15 。&lt;/p&gt;

&lt;p&gt;接着使用按位取反运算符创建了一个名为 invertedBits 的常量,这个常量的值与全部位取反后的 initialBits 相 等。即所有的 0 都变成了 1 ,同时所有的 1 都变成 0 。 invertedBits 的二进制值为 11110000 ,等价于无 符号十进制数的 240 。&lt;/p&gt;

&lt;h3 id=&#34;按位与运算符&#34;&gt;按位与运算符&lt;/h3&gt;

&lt;p&gt;按位与运算符( &amp;amp; )可以对两个数的比特位进行合并。它返回一个新的数,只有当两个操作数的对应位都为 1 的 时候,该数的对应位才为 1 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSAdvancedOperators/2.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在下面的示例当中, firstSixBits 和 lastSixBits 中间 4 个位的值都为 1 。按位与运算符对它们进行了运算,得 到二进制数值 00111100 ,等价于无符号十进制数的 60 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let firstSixBits: UInt8 = 0b11111100
let lastSixBits: UInt8  = 0b00111111
let middleFourBits = firstSixBits &amp;amp; lastSixBits  // equals 00111100
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;按位或运算&#34;&gt;按位或运算&lt;/h3&gt;

&lt;p&gt;按位或运算符( | )可以对两个数的比特位进行比较。它返回一个新的数,只要两个操作数的对应位中有任意一个为 1 时,该数的对应位就为 1 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSAdvancedOperators/3.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在下面的示例当中, someBits 和 moreBits 将不同的位设置为 1 。接位或运算符对它们进行了运算,得到二 进制数值 11111110 ,等价于无符号十进制数的 254 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let someBits: UInt8 = 0b10110010
let moreBits: UInt8 = 0b01011110
let combinedbits = someBits | moreBits  // equals 11111110
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;按位异或运算符&#34;&gt;按位异或运算符&lt;/h3&gt;

&lt;p&gt;按位异或运算符( ^ )可以对两个数的比特位进行比较。它返回一个新的数,当两个操作数的对应位不相同时,该 数的对应位就为 1 :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSAdvancedOperators/4.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在下面的示例当中, firstBits 和 otherBits 都有一个自己设置为 1 而对方设置为 0 的位。 按位异或运算符 将这两个位都设置为 1 ,同时将其它位都设置为 0 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let firstBits: UInt8 = 0b00010100
let otherBits: UInt8 = 0b00000101
let outputBits = firstBits ^ otherBits  // equals 00010001
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;按位左移-右移运算符&#34;&gt;按位左移/右移运算符&lt;/h3&gt;

&lt;p&gt;按位左移运算符( &amp;lt;&amp;lt; )和按位右移运算符( &amp;gt;&amp;gt; )可以对一个数进行指定位数的左移和右移,但是需要遵守下面定义 的规则。&lt;/p&gt;

&lt;p&gt;对一个数进行按位左移或按位右移,相当于对这个数进行乘以 2 或除以 2 的运算。将一个整数左移一位,等价于 将这个数乘以 2,同样地,将一个整数右移一位,等价于将这个数除以 2。&lt;/p&gt;

&lt;h3 id=&#34;无符整型的移位操作&#34;&gt;无符整型的移位操作&lt;/h3&gt;

&lt;p&gt;对无符号整型进行移位的规则如下:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;已经存在的比特位按指定的位数进行左移和右移。&lt;/li&gt;
&lt;li&gt;任何移动超出整型存储边界的位都会被丢弃。&lt;/li&gt;
&lt;li&gt;用 0 来填充移动后产生的空白位。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种方法称为逻辑移位( logical shift )。&lt;/p&gt;

&lt;p&gt;以下这张图展示了 11111111 &amp;lt;&amp;lt; 1 (即把 11111111 向左移动 1 位),和 11111111 &amp;gt;&amp;gt; 1 (即把 11111111 向右移动 1 位) 的结果。蓝色的部分是被移位的,灰色的部分是被抛弃的,橙色的部分则是被填充进来的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSAdvancedOperators/5.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面的代码演示了 Swift 中的移位操作:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let shiftBits: UInt8 = 4   // 00000100 in binary
shiftBits &amp;lt;&amp;lt; 1             // 00001000
shiftBits &amp;lt;&amp;lt; 2             // 00010000
shiftBits &amp;lt;&amp;lt; 5             // 10000000
shiftBits &amp;lt;&amp;lt; 6             // 00000000
shiftBits &amp;gt;&amp;gt; 2             // 00000001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用移位操作对其他的数据类型进行编码和解码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let pink: UInt32 = 0xCC6699
let redComponent = (pink &amp;amp; 0xFF0000) &amp;gt;&amp;gt; 16    // redComponent is 0xCC, or 204
let greenComponent = (pink &amp;amp; 0x00FF00) &amp;gt;&amp;gt; 8   // greenComponent is 0x66, or 102
let blueComponent = pink &amp;amp; 0x0000FF           // blueComponent is 0x99, or 153
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个示例使用了一个命名为 pink 的 UInt32 型常量来存储层叠样式表( CSS )中粉色的颜色值。该 CSS 的十 六进制颜色值 #CC6699 , 在 Swift 中表示为 0xCC6699 。然后利用按位与运算符( &amp;amp; )和按位右移运算
符( &amp;gt;&amp;gt; )从这个颜色值中分解出红( CC )、绿( 66 )以及蓝( 99 )三个部分。&lt;/p&gt;

&lt;p&gt;红色部分是通过对 0xCC6699 和 0xFF0000 进行按位与运算后得到的。 0xFF0000 中的 0 部分作为掩 码,掩盖了 OxCC6699 中的第二和第三个字节,使得数值中的 6699 被忽略,只留下 0xCC0000 。&lt;/p&gt;

&lt;p&gt;然后,再将这个数按向右移动 16 位( &amp;gt;&amp;gt; 16 )。十六进制中每两个字符表示 8 个比特位,所以移动 16 位后 0xC C0000 就变为 0x0000CC 。这个数和 0xCC 是等同的,也就是十进制数值的 204 。&lt;/p&gt;

&lt;p&gt;同样的,绿色部分通过对 0xCC6699 和 0x00FF00 进行按位与运算得到 0x006600 。然后将这个数向右移 动 8 位,得到 0x66 ,也就是十进制数值的 102 。&lt;/p&gt;

&lt;p&gt;最后,蓝色部分通过对 0xCC6699 和 0x0000FF 进行按位与运算得到 0x000099 。并且不需要进行向右移 位,所以结果为 0x99 ,也就是十进制数值的 153 。&lt;/p&gt;

&lt;h3 id=&#34;有符整型的移位操作&#34;&gt;有符整型的移位操作&lt;/h3&gt;

&lt;p&gt;对比无符号整型来说,有符整型的移位操作相对复杂得多,这种复杂性源于有符号整数的二进制表现形式。(为了 简单起见,以下的示例都是基于 8 位有符号整数的,但是其中的原理对任何位数的有符号整数都是通用的。)&lt;/p&gt;

&lt;p&gt;有符号整数使用第 1 个比特位(通常被称为符号位)来表示这个数的正负。符号位为 0 代表正数,为 1 代表负 数。&lt;/p&gt;

&lt;p&gt;其余的比特位(通常被称为数值位)存储了这个数的真实值。有符号正整数和无符号数的存储方式是一样的,都是从 0 开始算起。这是值为 4 的 Int8 型整数的二进制位表现形式:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSAdvancedOperators/6.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;符号位为 0 ,说明这是一个正数,另外 7 位则代表了十进制数值 4 的二进制表示。&lt;/p&gt;

&lt;p&gt;负数的存储方式略有不同。它存储的是 2 的 n 次方减去它的真实值绝对值,这里的 n 为数值位的位数。一个 8 位的数有 7 个数值位,所以是 2 的 7 次方,即 128。&lt;/p&gt;

&lt;p&gt;这是值为 -4 的 Int8 型整数的二进制位表现形式:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSAdvancedOperators/7.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这次的符号位为 1 ,说明这是一个负数,另外 7 个位则代表了数值 124 (即 128 - 4 ) 的二进制表示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSAdvancedOperators/8.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;负数的表示通常被称为二进制补码( two&amp;rsquo;s complement )表示法。用这种方法来表示负数乍看起来有点奇怪,但 它有几个优点。&lt;/p&gt;

&lt;p&gt;首先,如果想对 -1 和 -4 进行加法操作,我们只需要将这两个数的全部 8 个比特位进行相加,并且将计算结 果中超出 8 位的数值丢弃:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSAdvancedOperators/9.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其次,使用二进制补码可以使负数的按位左移和右移操作得到跟正数同样的效果,即每向左移一位就将自身的数 值乘以 2,每向右一位就将自身的数值除以 2。要达到此目的,对有符号整数的右移有一个额外的规则:&lt;/p&gt;

&lt;p&gt;当对正整数进行按位右移操作时,遵循与无符号整数相同的规则,但是对于移位产生的空白位使用符号位进 行填充,而不是用 0。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSAdvancedOperators/10.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个行为可以确保有符号整数的符号位不会因为右移操作而改变,这通常被称为算术移位( arithmetic shift )。&lt;/p&gt;

&lt;p&gt;由于正数和负数的特殊存储方式,在对它们进行右移的时候,会使它们越来越接近 0。在移位的过程中保持符号 位不变,意味着负整数在接近 0 的过程中会一直保持为负。&lt;/p&gt;

&lt;h2 id=&#34;溢出运算符&#34;&gt;溢出运算符&lt;/h2&gt;

&lt;p&gt;在默认情况下,当向一个整数赋超过它容量的值时,Swift 默认会报错,而不是生成一个无效的数。这个行为给我 们操作过大或着过小的数的时候提供了额外的安全性。&lt;/p&gt;

&lt;p&gt;例如, Int16 型整数能容纳的有符号整数范围是 -32768 到 32767 ,当为一个 Int16 型变量赋的值超过这个 范围时,系统就会报错:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var potentialOverflow = Int16.max
// potentialOverflow equals 32767, which is the largest value an Int16 can hold
potentialOverflow += 1
// this causes an error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为过大或者过小的数值提供错误处理,能让我们在处理边界值时更加灵活。&lt;/p&gt;

&lt;p&gt;当然,你有意在溢出时对有效位进行截断,你可采用溢出运算,而非错误处理。Swfit 为整型计算提供了 5 个&amp;amp;符号开头的溢出运算符。&lt;/p&gt;

&lt;p&gt;溢出加法 &amp;amp;+
溢出减法 &amp;amp;-
溢出乘法 &amp;amp;*&lt;/p&gt;

&lt;h3 id=&#34;数值溢出&#34;&gt;数值溢出&lt;/h3&gt;

&lt;p&gt;数值有可能出现上溢或者下溢。&lt;/p&gt;

&lt;p&gt;这个示例演示了当我们对一个无符号整数使用溢出加法( &amp;amp;+ )进行上溢运算时会发生什么:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var unsignedOverflow = UInt8.max
// unsignedOverflow equals 255, which is the largest value a UInt8 can hold
unsignedOverflow = unsignedOverflow &amp;amp;+ 1
// unsignedOverflow is now equal to 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;unsignedOverflow 被初始化为 UInt8 所能容纳的最大整数( 255 ,以二进制表示即 11111111 )。然后使用了 溢出加法运算符( &amp;amp;+ )对其进行加 1 操作。这使得它的二进制表示正好超出 UInt8 所能容纳的位数,也就导致了 数值的溢出,如下图所示。数值溢出后,留在 UInt8 边界内的值是 00000000 ,也就是十进制数值的 0。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSAdvancedOperators/11.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同样地,当我们对一个无符号整数使用溢出减法( &amp;amp;- )进行下溢运算时也会产生类似的现象:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var unsignedOverflow = UInt8.min
// unsignedOverflow equals 0, which is the smallest value a UInt8 can hold
unsignedOverflow = unsignedOverflow &amp;amp;- 1
// unsignedOverflow is now equal to 255
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UInt8 的最小值是 0(二进制为 00000000)。使用&amp;amp;-进行溢出减 1,就会得到二进制的 11111111 即十进制的 255。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSAdvancedOperators/12.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;溢出也会发生在有符号整型数值上。在对有符号整型数值进行溢出加法或溢出减法运算时,符号位也需要参与计
算,正如按位左移/右移运算符所描述的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var signedUnderflow = Int8.min
// signedUnderflow equals -128, which is the smallest value an Int8 can hold
signedUnderflow = signedUnderflow &amp;amp;- 1
// signedUnderflow is now equal to 127
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Int8 型整数能容纳的最小值是 -128,以二进制表示即 10000000。当使用溢出减法操作符对其进行减 1 操作 时,符号位被翻转,得到二进制数值 01111111,也就是十进制数值的 127,这个值也是 Int8 型整数所能容纳的最大值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSAdvancedOperators/13.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;对于无符号与有符号整型数值来说,当出现上溢时,它们会从数值所能容纳的最大数变成最小的数。同样地,当
发生下溢时,它们会从所能容纳的最小数变成最大的数。&lt;/p&gt;

&lt;h2 id=&#34;优先级和结合性&#34;&gt;优先级和结合性&lt;/h2&gt;

&lt;p&gt;运算符的优先级( precedence )使得一些运算符优先于其他运算符,高优先级的运算符会先被计算。&lt;/p&gt;

&lt;p&gt;结合性( associativity )定义了相同优先级的运算符是如何结合(或关联)的 —— 是与左边结合为一组,还是与右 边结合为一组。可以将这意思理解为“它们是与左边的表达式结合的”或者“它们是与右边的表达式结合的”。&lt;/p&gt;

&lt;p&gt;在复合表达式的运算顺序中,运算符的优先级和结合性是非常重要的。举例来说,为什么下面这个表达式的运算 结果是 4 ?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2 + 3 * 4 % 5
// this equals 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果严格地从左到右进行运算,则运算的过程是这样的:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;2 plus 3 equals 5&lt;/li&gt;
&lt;li&gt;5 times 4 equals 20&lt;/li&gt;
&lt;li&gt;20 remainder 5 equals 0&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是正确答案是 4 而不是 0 。优先级高的运算符要先于优先级低的运算符进行计算。与C语言类似,在 Swift 当中,乘法运算符( * )与取余运算符( % )的优先级高于加法运算符( + )。因此,它们的计算顺序要先于加法运 算。&lt;/p&gt;

&lt;p&gt;而乘法与取余的优先级相同。这时为了得到正确的运算顺序,还需要考虑结合性。乘法与取余运算都是左结合
的。可以将这考虑成为这两部分表达式都隐式地加上了括号:&lt;/p&gt;

&lt;p&gt;2 + ((3 * 4) % 5)
(3 * 4) = 12 ,所以表达式相当于:
2 + (12 % 5)
12 % 5 = 2 ,所以表达式相当于:
2 +2&lt;/p&gt;

&lt;p&gt;此时可以容易地看出计算的结果为 4 。&lt;/p&gt;

&lt;p&gt;如果想查看完整的 Swift 运算符优先级和结合性规则,请参考表达式。&lt;/p&gt;

&lt;p&gt;注意:对于C语言和 Objective-C 来说,Swift 的运算符优先级和结合性规则是更加简洁和可预测的。但是,这也意味着它们于那些基于C的语言不是完全一致的。在对现有的代码进行移植的时候,要注意确保运算符的行为仍然 是按照你所想的那样去执行。&lt;/p&gt;

&lt;h2 id=&#34;运算符函数&#34;&gt;运算符函数&lt;/h2&gt;

&lt;p&gt;类和结构可以为现有的操作符提供自定义的实现,这通常被称为运算符重载( overloading )。&lt;/p&gt;

&lt;p&gt;下面的例子展示了如何为自定义的结构实现加法操作符( + )。算术加法运算符是一个两目运算符( binary operator ),因为它可以对两个目标进行操作,同时它还是中缀( infix )运算符,因为它出现在两个目标中间。&lt;/p&gt;

&lt;p&gt;例子中定义了一个名为 Vector2D 的结构体用来表示二维坐标向量 (x, y) ,紧接着定义了一个可以对两个 or2D 结构体进行相加的运算符函数( operator function ):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Vector2D {
    var x = 0.0, y = 0.0
}

func + (left: Vector2D, right: Vector2D) -&amp;gt; Vector2D {
    return Vector2D(x: left.x + right.x, y: left.y + right.y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该运算符函数被定义为一个全局函数,并且函数的名字与它要进行重载的 + 名字一致。因为算术加法运算符是 双目运算符,所以这个运算符函数接收两个类型为 Vector2D 的输入参数,同时有一个 Vector2D 类型的返回 值。&lt;/p&gt;

&lt;p&gt;在这个实现中,输入参数分别被命名为 left 和 right ,代表在 + 运算符左边和右边的两个 Vector2D 对 象。函数返回了一个新的 Vector2D 的对象,这个对象的 x 和 y 分别等于两个参数对象的 x 和 y 的值之 和。&lt;/p&gt;

&lt;p&gt;这个函数被定义成全局的,而不是 Vector2D 结构的成员方法,所以任意两个 Vector2D 对象都可以使用这个 中缀运算符:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let vector = Vector2D(x: 3.0, y: 1.0)
let anotherVector = Vector2D(x: 2.0, y: 4.0)
let combinedVector = vector + anotherVector
// combinedVector is a Vector2D instance with values of (5.0, 5.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子实现两个向量 (3.0,1.0) 和 (2.0,4.0) 相加,得到向量 (5.0,5.0) 的过程。如 下图示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSAdvancedOperators/14.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;前缀和后缀运算符&#34;&gt;前缀和后缀运算符&lt;/h3&gt;

&lt;p&gt;上个例子演示了一个双目中缀运算符的自定义实现。类与结构体也能提供标准单目运算符( unary operators )的 实现。单目运算符只有一个操作目标。当运算符出现在操作目标之前时,它就是前缀( prefix )的(比如 -a ),而 当它出现在操作目标之后时,它就是后缀( postfix )的(比如 i++ )。&lt;/p&gt;

&lt;p&gt;要实现前缀或者后缀运算符,需要在声明运算符函数的时候在 func 关键字之前指定 prefix 或者 postfix 限定 符:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prefix func - (vector: Vector2D) -&amp;gt; Vector2D {
    return Vector2D(x: -vector.x, y: -vector.y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码为 Vector2D 类型实现了单目减运算符( -a )。由于单目减运算符是前缀运算符,所以这个函数需要加 上 prefix 限定符。&lt;/p&gt;

&lt;p&gt;对于简单数值,单目减运算符可以对它们的正负性进行改变。对于 Vector2D 来说,单目减运算将其 x 和 y 属性的正负性都进行了改变。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let positive = Vector2D(x: 3.0, y: 4.0)
let negative = -positive
// negative is a Vector2D instance with values of (-3.0, -4.0)
let alsoPositive = -negative
// alsoPositive is a Vector2D instance with values of (3.0, 4.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;复合赋值运算符&#34;&gt;复合赋值运算符&lt;/h3&gt;

&lt;p&gt;复合赋值运算符( Compound assignment operators )将赋值运算符( = )与其它运算符进行结合。比如,将加法 与赋值结合成加法赋值运算符( += )。在实现的时候,需要把运算符的左参数设置成 inout 类型,因为这个参数 的值会在运算符函数内直接被修改。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func += (inout left: Vector2D, right: Vector2D) {
    left = left + right
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为加法运算在之前已经定义过了,所以在这里无需重新定义。在这里可以直接利用现有的加法运算符函数,用
它来对左值和右值进行相加,并再次赋值给左值:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var original = Vector2D(x: 1.0, y: 2.0)
let vectorToAdd = Vector2D(x: 3.0, y: 4.0)
original += vectorToAdd
// original now has values of (4.0, 6.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以将赋值与 prefix 或 postfix 限定符结合起来,下面的代码为 Vector2D 实例实现了前缀自增运算符( ++a ):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prefix func ++ (inout vector: Vector2D) -&amp;gt; Vector2D {
    vector += Vector2D(x: 1.0, y: 1.0)
    return vector
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个前缀自增运算符使用了前面定义的加法赋值操作。它对 Vector2D 的 x 和 y 属性都进行了加 1 操 作,再将结果返回:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var toIncrement = Vector2D(x: 3.0, y: 4.0)
let afterIncrement = ++toIncrement
// toIncrement now has values of (4.0, 5.0)
// afterIncrement also has values of (4.0, 5.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:不能对默认的赋值运算符( = )进行重载。只有组合赋值符可以被重载。同样地,也无法对三目条件运算 符 a ? b : c 进行重载。&lt;/p&gt;

&lt;h3 id=&#34;等价操作符&#34;&gt;等价操作符&lt;/h3&gt;

&lt;p&gt;自定义的类和结构体没有对等价操作符( equivalence operators )进行默认实现,等价操作符通常被称为“相 等”操作符( == )与“不等”操作符( != )。对于自定义类型,Swift 无法判断其是否“相等”,因为“相等”的 含义取决于这些自定义类型在你的代码中所扮演的角色。&lt;/p&gt;

&lt;p&gt;为了使用等价操作符来对自定义的类型进行判等操作,需要为其提供自定义实现,实现的方法与其它中缀运算符
一样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func == (left: Vector2D, right: Vector2D) -&amp;gt; Bool {
    return (left.x == right.x) &amp;amp;&amp;amp; (left.y == right.y)
}
func != (left: Vector2D, right: Vector2D) -&amp;gt; Bool {
    return !(left == right)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码实现了“相等”运算符( == )来判断两个 Vector2D 对象是否有相等。对于 Vector2D 类型来 说,“相等”意味“两个实例的 x 属性 和 y 属性都相等”,这也是代码中用来进行判等的逻辑。示例里同时也 实现了“不等”操作符( != ),它简单地将“相等”操作符进行取反后返回。&lt;/p&gt;

&lt;p&gt;现在我们可以使用这两个运算符来判断两个 Vector2D 对象是否相等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let twoThree = Vector2D(x: 2.0, y: 3.0)
let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)
if twoThree == anotherTwoThree {
    println(&amp;quot;These two vectors are equivalent.&amp;quot;)
}
// prints &amp;quot;These two vectors are equivalent.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;自定义运算符&#34;&gt;自定义运算符&lt;/h2&gt;

&lt;p&gt;除了实现标准运算符,在 Swift 当中还可以声明和实现自定义运算符( custom operators )。可以用来自定义运算 符的字符列表请参考操作符 (页 0)&lt;/p&gt;

&lt;p&gt;新的运算符要在全局作用域内,使用 operator 关键字进行声明,同时还要指定 prefix 、 infix 或者 postfix 限定符:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prefix operator +++ {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码定义了一个新的名为 +++ 的前缀运算符。对于这个运算符,在 Swift 中并没有意义,因为我们针对 Vector2D 的实例来定义它的意义。对这个示例来讲, +++ 被实现为“前缀双自增”运算符。它使用了前面定
义的复合加法操作符来让矩阵对自身进行相加,从而让 Vector2D 实例的 x 属性和 y 属性的值翻倍:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prefix func +++ (inout vector: Vector2D) -&amp;gt; Vector2D {
    vector += vector
    return vector
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vector2D 的 +++ 的实现和 ++ 的实现很相似, 唯一不同的是前者对自身进行相加, 而后者是与另一个值为 (1.0, 1.0) 的向量相加.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var toBeDoubled = Vector2D(x: 1.0, y: 4.0)
let afterDoubling = +++toBeDoubled
// toBeDoubled now has values of (2.0, 8.0)
// afterDoubling also has values of (2.0, 8.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;自定义中缀运算符的优先级和结合性&#34;&gt;自定义中缀运算符的优先级和结合性&lt;/h3&gt;

&lt;p&gt;自定义的中缀( infix )运算符也可以指定优先级( precedence )和结合性( associativity )。优先级和结合性 (页0)中详细阐述了这两个特性是如何对中缀运算符的运算产生影响的。&lt;/p&gt;

&lt;p&gt;结合性( associativity )可取的值有 left , right 和 none 。当左结合运算符跟其他相同优先级的左结合运算符 写在一起时,会跟左边的操作数进行结合。同理,当右结合运算符跟其他相同优先级的右结合运算符写在一起 时,会跟右边的操作数进行结合。而非结合运算符不能跟其他相同优先级的运算符写在一起。&lt;/p&gt;

&lt;p&gt;结合性( associativity )的默认值是 none ,优先级( precedence )如果没有指定,则默认为 100 。&lt;/p&gt;

&lt;p&gt;以下例子定义了一个新的中缀运算符 +- ,此操作符是左结合的,并且它的优先级为 140 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;infix operator +- { associativity left precedence 140 }
func +- (left: Vector2D, right: Vector2D) -&amp;gt; Vector2D {
    return Vector2D(x: left.x + right.x, y: left.y - right.y)
}
let firstVector = Vector2D(x: 1.0, y: 2.0)
let secondVector = Vector2D(x: 3.0, y: 4.0)
let plusMinusVector = firstVector +- secondVector
// plusMinusVector is a Vector2D instance with values of (4.0, -2.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个运算符把两个向量的 x 值相加,同时用第一个向量的 y 值减去第二个向量的 y 值。因为它本质上是属 于“加型”运算符,所以将它的结合性和优先级被设置为( left 和 140 ),这与 + 和 - 等默认的中缀加型操作 符是相同的。完整的 Swift 操作符默认结合性与优先级请参考表达式。&lt;/p&gt;

&lt;p&gt;注意: 当定义前缀与后缀操作符的时候,我们并没有指定优先级。然而,如果对同一个操作数同时使用前缀与 后缀操作符,则后缀操作符会先被执行。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Swift之访问控制</title>
      <link>http://lynchwong.com/2015/03/swift%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Sat, 07 Mar 2015 23:24:25 +0000</pubDate>
      
      <guid>http://lynchwong.com/2015/03/swift%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid>
      <description>&lt;p&gt;访问控制可以限定其他源文件或模块中代码对你代码的访问级别。这个特性可以让我们隐藏功能实现的一些细
节,并且可以明确的申明我们提供给其他人的接口中哪些部分是他们可以访问和使用的。
&lt;/p&gt;

&lt;p&gt;你可以明确地给单个类型(类、结构体、枚举)设置访问级别,也可以给这些类型的属性、函数、初始化方
法、基本类型、下标索引等设置访问级别。协议也可以被限定在一定的范围内使用,包括协议里的全局常量、变
量和函数。&lt;/p&gt;

&lt;p&gt;在提供了不同访问级别的同时,Swift还为某些典型场景提供了默认的访问级别,这样就不需要我们在每段代码中 都申明显式访问级别。其实,如果只是开发一个单目标应用程序,我们完全可以不用申明代码的显式访问级别。&lt;/p&gt;

&lt;p&gt;注意:简单起见,代码中可以设置访问级别的特性(属性、基本类型、函数等),在下面的章节中我们会以“实
体”代替。&lt;/p&gt;

&lt;h2 id=&#34;模块和源文件&#34;&gt;模块和源文件&lt;/h2&gt;

&lt;p&gt;Swift 中的访问控制模型基于模块和源文件这两个概念。&lt;/p&gt;

&lt;p&gt;模块指的是以独立单元构建和发布的 Framework 或 Application 。在Swift 中的一个模块可以使用 import 关键 字引入另外一个模块。&lt;/p&gt;

&lt;p&gt;在 Swift 中,Xcode的每个构建目标(比如 Framework 或 app bundle )都被当作模块处理。如果你是为了实 现某个通用的功能,或者是为了封装一些常用方法而将代码打包成独立的 Framework ,这个 Framework 在 S wift 中就被称为模块。当它被引入到某个 app 工程或者另外一个 Framework 时,它里面的一切(属性、函数 等)仍然属于这个独立的模块。&lt;/p&gt;

&lt;p&gt;源文件指的是 Swift 中的 Swift File ,就是编写 Swift 源代码的文件,它通常属于一个模块。尽管一般我们将不 同的 类 分别定义在不同的源文件中,但是同一个源文件可以包含多个 类 和 函数 的定义。&lt;/p&gt;

&lt;h2 id=&#34;访问级别&#34;&gt;访问级别&lt;/h2&gt;

&lt;p&gt;Swift 为代码中的实体提供了三种不同的访问级别。这些访问级别不仅与源文件中定义的实体相关,同时也与源文 件所属的模块相关。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;public:可以访问自己模块中源文件里的任何实体,别人也可以通过引入该模块来访问源文件里的所有实 体。通常情况下, Framework 中的某个接口是可以被任何人使用时,你可以将其设置为 public 级别。&lt;/li&gt;
&lt;li&gt;internal:可以访问自己模块中源文件里的任何实体,但是别人不能访问该模块中源文件里的实体。通常情 况下,某个接口或 Framework 作为内部结构使用时,你可以将其设置为 internal 级别。&lt;/li&gt;
&lt;li&gt;private:只能在当前源文件中使用的实体,称为私有实体。使用 private 级别,可以用作隐藏某些功能的 实现细节。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;public 为最高级的访问级别，private 为最低级的访问级别。&lt;/p&gt;

&lt;p&gt;注意:Swift中的 private 访问和其他语言中的 private 访问不太一样,它的范围限于整个源文件,而不是声 明。这就意味着,一个类可以访问定义该类的源文件中定义的所有 private 实体,但是如果一个类的扩展 是定义在独立的源文件中,那么就不能访问这个类的 private 成员。&lt;/p&gt;

&lt;h3 id=&#34;访问级别的使用原则&#34;&gt;访问级别的使用原则&lt;/h3&gt;

&lt;p&gt;Swift 中的访问级别遵循一个使用原则:访问级别统一性。 比如说:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个 public 访问级别的变量,不能将它的类型定义为 internal 和 private 。因为变量可以被任何人访问,但 是定义它的类型不可以,所以这样就会出现错误。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;默认访问级别&#34;&gt;默认访问级别&lt;/h3&gt;

&lt;p&gt;如果你不为代码中的所有实体定义显式访问级别,那么它们默认为 internal 级别。在大多数情况下,我们不需要 设置实体的显式访问级别。因为我们一般都是在开发一个 app bundle。&lt;/p&gt;

&lt;h3 id=&#34;单目标应用程序的访问级别&#34;&gt;单目标应用程序的访问级别&lt;/h3&gt;

&lt;p&gt;当你编写一个单目标应用程序时,该应用的所有功能都是为该应用服务,不需要提供给其他应用或者模块使 用,所以我们不需要明确设置访问级别,使用默认的访问级别 internal 即可。但是如果你愿意,你也可以使用 private 级别,用于隐藏一些功能的实现细节。&lt;/p&gt;

&lt;h3 id=&#34;framework的访问级别&#34;&gt;Framework的访问级别&lt;/h3&gt;

&lt;p&gt;当你开发 Framework 时,就需要把一些对外的接口定义为 public 级别,以便其他人导入该 Framework 后可以
正常使用其功能。这些被你定义为 public 的接口,就是这个 Framework 的API。&lt;/p&gt;

&lt;p&gt;注意: Framework 的内部实现细节依然可以使用默认的 internal 级别,或者也可以定义为 private 级别。只
有当你想把它作为 API 的一部分的时候,才将其定义为 public 级别。&lt;/p&gt;

&lt;h3 id=&#34;单元测试目标的访问级别&#34;&gt;单元测试目标的访问级别&lt;/h3&gt;

&lt;p&gt;当你的app有单元测试目标时,为了方便测试,测试模块需要能访问到你app中的代码。默认情况下只有 public 级别的实体才可以被其他模块访问。然而,如果在引入一个生产模块时使用 @testable 注解,然后用带测试的方 式编译这个生产模块,单元测试目标就可以访问所有 internal 级别的实体。&lt;/p&gt;

&lt;h2 id=&#34;访问控制语法&#34;&gt;访问控制语法&lt;/h2&gt;

&lt;p&gt;通过修饰符 public 、 internal 、 private 来声明实体的访问级别:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SomePublicClass {} 
internal class SomeInternalClass {} 
private class SomePrivateClass {}
public var somePublicVariable = 0 
internal let someInternalConstant = 0 
private func somePrivateFunction() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除非有特殊的说明,否则实体都使用默认的访问级别 internal ,可以查阅默认访问级别 (页 0)这一节。这意味着 在不使用修饰符声明显式访问级别的情况下, SomeInternalClass 和 someInternalConstant 仍然拥有隐式的访 问级别 internal :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class SomeInternalClass {} // 隐式访问级别 internal 
var someInternalConstant = 0 // 隐式访问级别 internal
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;自定义类型&#34;&gt;自定义类型&lt;/h2&gt;

&lt;p&gt;如果想为一个自定义类型申明显式访问级别,那么要明确一点。那就是你要确保新类型的访问级别和它实际的作 用域相匹配。比如说,如果你定义了一个 private 类,那这个类就只能在定义它的源文件中当作属性类型、函数 参数或者返回类型使用。&lt;/p&gt;

&lt;p&gt;类的访问级别也可以影响到类成员(属性、函数、初始化方法等)的默认访问级别。如果你将类申明为 private 类,那么该类的所有成员的默认访问级别也会成为 private 。如果你将类申明为 public 或者 internal 类(或者不 明确的申明访问级别,而使用默认的 internal 访问级别),那么该类的所有成员的访问级别是 internal 。&lt;/p&gt;

&lt;p&gt;注意:上面提到,一个 public 类的所有成员的访问级别默认为 internal 级别,而不是 public 级别。如果你想 将某个成员申明为 public 级别,那么你必须使用修饰符明确的声明该成员。这样做的好处是,在你定义公共接 口API的时候,可以明确的选择哪些属性或方法是需要公开的,哪些是内部使用的,可以避免将内部使用的属性 方法公开成公共API的错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SomePublicClass { // 显式的 public 类
    public var somePublicProperty = 0 // 显式的 public 类成员 
    var someInternalProperty = 0 // 隐式的 internal 类成员 
    private func somePrivateMethod() {} // 显式的 private 类成员
}
class SomeInternalClass { // 隐式的 internal 类
    var someInternalProperty = 0 // 隐式的 internal 类成员 
    private func somePrivateMethod() {} // 显式的 private 类成员
}
private class SomePrivateClass { // 显式的 private 类
    var somePrivateProperty = 0 // 隐式的 private 类成员
    func somePrivateMethod() {} // 隐式的 private 类成员
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;元组类型&#34;&gt;元组类型&lt;/h3&gt;

&lt;p&gt;元组的访问级别使用是所有类型的访问级别使用中最为严谨的。比如说,如果你构建一个包含两种不同类型元素 的元组,其中一个元素类型的访问级别为 internal ,另一个为 private 级别,那么这个元组的访问级别为 private 。也就是说元组的访问级别与元组中访问级别最低的类型一致。&lt;/p&gt;

&lt;p&gt;注意:元组不同于类、结构体、枚举、函数那样有单独的定义。元组的访问级别是在它被使用时自动推导出的,而不是明确的申明。&lt;/p&gt;

&lt;h3 id=&#34;函数类型&#34;&gt;函数类型&lt;/h3&gt;

&lt;p&gt;函数的访问级别需要根据该函数的参数类型和返回类型的访问级别得出。如果根据参数类型和返回类型得出的函
数访问级别不符合默认上下文,那么就需要明确地申明该函数的访问级别。&lt;/p&gt;

&lt;p&gt;下面的例子定义了一个名为 someFunction 全局函数,并且没有明确地申明其访问级别。也许你会认为该函数应 该拥有默认的访问级别 internal ,但事实并非如此。事实上,如果按下面这种写法,代码是无法编译通过的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func someFunction() -&amp;gt; (SomeInternalClass, SomePrivateClass) {
    // function implementation goes here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到,这个函数的返回类型是一个元组,该元组中包含两个自定义的类(可查阅自定义类型)。其中一个类的访问级别是 internal ,另一个的访问级别是 private ,所以根据元组访问级别的原则,该元 组的访问级别是 private (元组的访问级别与元组中访问级别最低的类型一致)。&lt;/p&gt;

&lt;p&gt;因为该函数返回类型的访问级别是 private ,所以你必须使用 private 修饰符,明确的声明该函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private func someFunction() -&amp;gt; (SomeInternalClass, SomePrivateClass) {
    // function implementation goes here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将该函数申明为 public 或 internal ,或者使用默认的访问级别 internal 都是错误的,因为如果把该函数当做 public 或 internal 级别来使用的话,是无法得到 private 级别的返回值的。&lt;/p&gt;

&lt;h3 id=&#34;枚举类型&#34;&gt;枚举类型&lt;/h3&gt;

&lt;p&gt;枚举中成员的访问级别继承自该枚举,你不能为枚举中的成员单独申明不同的访问级别。&lt;/p&gt;

&lt;p&gt;比如下面的例子,枚举 CompassPoint 被明确的申明为 public 级别，那么它的成员 North，South，East，West的访问级别同样也是public：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public enum CompassPoint {
    case North
    case South
    case East
    case West
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;原始值和关联值&#34;&gt;原始值和关联值&lt;/h3&gt;

&lt;p&gt;枚举定义中的任何原始值或关联值的类型都必须有一个访问级别,这个级别至少要不低于枚举的访问级别。比如 说,你不能在一个 internal 访问级别的枚举中定义 private 级别的原始值类型。&lt;/p&gt;

&lt;h3 id=&#34;嵌套类型&#34;&gt;嵌套类型&lt;/h3&gt;

&lt;p&gt;如果在 private 级别的类型中定义嵌套类型,那么该嵌套类型就自动拥有 private 访问级别。如果在 public 或者 internal 级别的类型中定义嵌套类型,那么该嵌套类型自动拥有 internal 访问级别。如果想让嵌套类型拥有 public 访问级别,那么需要明确地申明该嵌套类型的访问级别。&lt;/p&gt;

&lt;h2 id=&#34;子类&#34;&gt;子类&lt;/h2&gt;

&lt;p&gt;子类的访问级别不得高于父类的访问级别。比如说,父类的访问级别是 internal ,子类的访问级别就不能申明为 public 。&lt;/p&gt;

&lt;p&gt;此外,在满足子类不高于父类访问级别以及遵循各访问级别作用域(即模块或源文件)的前提下,你可以重写任
意类成员(方法、属性、初始化方法、下标索引等)。&lt;/p&gt;

&lt;p&gt;如果我们无法直接访问某个类中的属性或函数等,那么可以继承该类,从而可以更容易的访问到该类的类成 员。下面的例子中,类 A 的访问级别是 public ,它包含一个函数 someMethod ,访问级别为 private 。类 B 继承类 A ,并且访问级别申明为 internal ,但是在类 B 中重写了类 A 中访问级别为 private 的方法 someMet hod ,并重新申明为 internal 级别。通过这种方式,我们就可以访问到某类中 private 级别的类成员,并且可以 重新申明其访问级别,以便其他人使用:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class A {
    private func someMethod() {}
}

internal class B: A {
    override internal func someMethod() {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要满足子类不高于父类访问级别以及遵循各访问级别作用域的前提下(即 private 的作用域在同一个源文件中, internal 的作用域在同一个模块下),我们甚至可以在子类中,用子类成员访问父类成员,哪怕父类成员的 访问级别比子类成员的要低:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class A {
    private func someMethod() {}
}

internal class B: A {
    override internal func someMethod() {
    super.someMethod() }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为父类 A 和子类 B 定义在同一个源文件中,所以在类 B 中可以在重写的 someMethod 方法中调用 super.someMethod()。&lt;/p&gt;

&lt;h2 id=&#34;常量-变量-属性-下标&#34;&gt;常量、变量、属性、下标&lt;/h2&gt;

&lt;p&gt;常量、变量、属性不能拥有比它们的类型更高的访问级别。比如说,你定义一个 public 级别的属性,但是它的类
型是 private 级别的,这是编译器所不允许的。同样,下标也不能拥有比索引类型或返回类型更高的访问级别。&lt;/p&gt;

&lt;p&gt;如果常量、变量、属性、下标索引的定义类型是 private 级别的,那么它们必须要明确的申明访问级别为 private:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private var privateInstance = SomePrivateClass()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;getter和setter&#34;&gt;Getter和Setter&lt;/h3&gt;

&lt;p&gt;常量、变量、属性、下标索引的 Getters 和 Setters 的访问级别继承自它们所属成员的访问级别。&lt;/p&gt;

&lt;p&gt;Setter 的访问级别可以低于对应的 Getter 的访问级别,这样就可以控制变量、属性或下标索引的读写权限。在
var 或 subscript 定义作用域之前,你可以通过 private(set) 或 internal(set) 先为它们的写权限申明一个较低的 访问级别。&lt;/p&gt;

&lt;p&gt;注意:这个规定适用于用作存储的属性或用作计算的属性。即使你不明确地申明存储属性的 Getter 、 Sette r ,Swift也会隐式的为其创建 Getter 和 Setter ,用于对该属性进行读取操作。使用 private(set) 和 interna l(set) 可以改变Swift隐式创建的 Setter 的访问级别。这对计算属性也同样适用。&lt;/p&gt;

&lt;p&gt;下面的例子中定义了一个名为 TrackedString 的结构体,它记录了 value 属性被修改的次数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct TrackedString {
    private(set) var numberOfEdits = 0
    var value: String = &amp;quot;&amp;quot; {
        didSet {
            numberOfEdits++
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TrackedString 结构体定义了一个用于存储 String 类型的属性 value，并将初始化值设为&amp;rdquo;&amp;ldquo;(即一个空字符串)。该结构体同时也定义了另一个用于存储 Int 类型的属性名 numberOfEdits，它用于记录属性 value 被修改的次数。这个功能的实现通过属性 value 的 didSet 方法实现，每当给 value 赋新值时就会调用 didSet 方法，然后将 numberOfEdits 的值加一。&lt;/p&gt;

&lt;p&gt;结构体 TrackedString 和它的属性 value 均没有申明显式访问级别，所以他们都拥有默认的访问级别 internal。但是该结构体的 numberOfEdits 属性使用 private(set) 修饰符进行申明，这意味着 numberOfEdits 属性只能在定义该结构体的源文件中赋值。numberOfEdits 属性的 Getter 依然是默认的访问级别 internal，但是 Setter 的访问级别是 private ，这表示该属性只有在当前源文件中是可读写的，而在当前源文件所属的模块中它只是一个可读的属性。&lt;/p&gt;

&lt;p&gt;如果你实例化 TrackedString 结构体,并且多次对 value 属性的值进行修改,你就会看到 numberOfEdits 的值会随着修改次数进行变化:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var stringToEdit = TrackedString()
stringToEdit.value = &amp;quot;This string will be tracked.&amp;quot;
stringToEdit.value += &amp;quot; This edit will increment numberOfEdits.&amp;quot;
stringToEdit.value += &amp;quot; So will this one.&amp;quot;
print(&amp;quot;The number of edits is \(stringToEdit.numberOfEdits)&amp;quot;)
// prints &amp;quot;The number of edits is 3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然你可以在其他的源文件中实例化该结构体并且获取到 numberOfEdits 属性的值。这样就能很好的告诉使用者,你只管使用,而不需要知道其实现细节。&lt;/p&gt;

&lt;p&gt;如果有必要你可以为 Getter 和 Setter 方法设定显式访问级别。下面的例子就是明确申明了 public 访问级别的 TrackedString 结构体。结构体的成员(包括 numberOfEdits 属性)拥有默认的访问级别 internal 。你可以结
合 public 和 private(set) 修饰符把结构体中的 numberOfEdits 属性 Getter 方法的访问级别设置为 public，而 Setter 方法的访问级别设置为 private :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public struct TrackedString {
    public private(set) var numberOfEdits = 0
    public var value: String = &amp;quot;&amp;quot; {
        didSet {
            numberOfEdits++
        }
    }
    public init() {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;

&lt;p&gt;我们可以给自定义的初始化方法申明访问级别,但是要不高于它所属类的访问级别。但必要构造器例 外,它的访问级别必须和所属类的访问级别相同。&lt;/p&gt;

&lt;p&gt;如同函数或方法参数,初始化方法参数的访问级别也不能低于初始化方法的访问级别。&lt;/p&gt;

&lt;h3 id=&#34;默认初始化方法&#34;&gt;默认初始化方法&lt;/h3&gt;

&lt;p&gt;Swift为结构体、类都提供了一个默认的无参初始化方法,用于给它们的所有属性提供赋值操作,但不会给出具体 值。默认初始化方法可以参阅默认构造器。默认初始化方法的访问级别与所属类型的访问级别相同。&lt;/p&gt;

&lt;p&gt;注意:如果一个类型被申明为 public 级别,那么默认的初始化方法的访问级别为 internal 。如果你想让无参的 初始化方法在其他模块中可以被使用,那么你必须提供一个具有 public 访问级别的无参初始化方法。&lt;/p&gt;

&lt;h3 id=&#34;结构体的默认成员初始化方法&#34;&gt;结构体的默认成员初始化方法&lt;/h3&gt;

&lt;p&gt;如果结构体中的任一存储属性的访问级别为 private ,那么它的默认成员初始化方法访问级别就是 private 。尽 管如此,结构体的初始化方法的访问级别依然是 internal 。&lt;/p&gt;

&lt;p&gt;如果你想在其他模块中使用该结构体的默认成员初始化方法,那么你需要提供一个访问级别为 public 的默认成员初始化方法。&lt;/p&gt;

&lt;h2 id=&#34;协议&#34;&gt;协议&lt;/h2&gt;

&lt;p&gt;如果想为一个协议明确的申明访问级别,那么需要注意一点,就是你要确保该协议只在你申明的访问级别作用域
中使用。&lt;/p&gt;

&lt;p&gt;协议中的每一个必须要实现的函数都具有和该协议相同的访问级别。这样才能确保该协议的使用者可以实现它所
提供的函数。&lt;/p&gt;

&lt;p&gt;注意:如果你定义了一个 public 访问级别的协议,那么实现该协议提供的必要函数也会是 public 的访问级 别。这一点不同于其他类型,比如, public 访问级别的其他类型,他们成员的访问级别为 internal。&lt;/p&gt;

&lt;h3 id=&#34;协议继承&#34;&gt;协议继承&lt;/h3&gt;

&lt;p&gt;如果定义了一个新的协议,并且该协议继承了一个已知的协议,那么新协议拥有的访问级别最高也只和被继承协 议的访问级别相同。比如说,你不能定义一个 public 的协议而去继承一个 internal 的协议。&lt;/p&gt;

&lt;h3 id=&#34;协议一致性&#34;&gt;协议一致性&lt;/h3&gt;

&lt;p&gt;类可以采用比自身访问级别低的协议。比如说,你可以定义一个 public 级别的类,可以让它在其他模块中使 用,同时它也可以采用一个 internal 级别的协议,并且只能在定义了该协议的模块中使用。&lt;/p&gt;

&lt;p&gt;采用了协议的类的访问级别取它本身和所采用协议中最低的访问级别。也就是说如果一个类是 public 级别,采用 的协议是 internal 级别,那么采用了这个协议后,该类的访问级别也是 internal。&lt;/p&gt;

&lt;p&gt;如果你采用了协议,那么实现了协议所必须的方法后,该方法的访问级别遵循协议的访问级别。比如说,一个 public 级别的类,采用了 internal 级别的协议,那么该类实现协议的方法至少也得是 internal 。&lt;/p&gt;

&lt;p&gt;注意:Swift和Objective-C一样,协议的一致性保证了一个类不可能在同一个程序中用不同的方法采用同一个协议。&lt;/p&gt;

&lt;h2 id=&#34;扩展&#34;&gt;扩展&lt;/h2&gt;

&lt;p&gt;你可以在条件允许的情况下对类、结构体、枚举进行扩展。扩展成员应该具有和原始类成员一致的访问级别。比
如你扩展了一个公共类型,那么你新加的成员应该具有和原始成员一样的默认的 internal 访问级别。&lt;/p&gt;

&lt;p&gt;或者,你可以明确申明扩展的访问级别(比如使用 private extension )给该扩展内所有成员申明一个新的默认访
问级别。这个新的默认访问级别仍然可以被单独成员所申明的访问级别所覆盖。&lt;/p&gt;

&lt;h3 id=&#34;协议的扩展&#34;&gt;协议的扩展&lt;/h3&gt;

&lt;p&gt;如果一个扩展采用了某个协议,那么你就不能对该扩展使用访问级别修饰符来申明了。该扩展中实现协议的方法
都会遵循该协议的访问级别。&lt;/p&gt;

&lt;h2 id=&#34;泛型&#34;&gt;泛型&lt;/h2&gt;

&lt;p&gt;泛型类型或泛型函数的访问级别取泛型类型、函数本身、泛型类型参数三者中的最低访问级别。&lt;/p&gt;

&lt;h2 id=&#34;类型别名&#34;&gt;类型别名&lt;/h2&gt;

&lt;p&gt;任何你定义的类型别名都会被当作不同的类型,以便于进行访问控制。一个类型别名的访问级别不可高于原类型 的访问级别。比如说,一个 private 级别的类型别名可以设定给一个 public 、 internal 、 private 的类型,但是 一个 public 级别的类型别名只能设定给一个 public 级别的类型,不能设定给 internal 或 private 级别的类型。&lt;/p&gt;

&lt;p&gt;注意:这条规则也适用于为满足协议一致性而给相关类型命名别名的情况。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Swift之泛型</title>
      <link>http://lynchwong.com/2015/03/swift%E4%B9%8B%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Sat, 07 Mar 2015 22:51:36 +0000</pubDate>
      
      <guid>http://lynchwong.com/2015/03/swift%E4%B9%8B%E6%B3%9B%E5%9E%8B/</guid>
      <description>&lt;p&gt;泛型代码可以让你写出根据自我需求定义、适用于任何类型的,灵活且可重用的函数和类型。它可以让你避免重复的代码,用一种清晰和抽象的方式来表达代码的意图。
&lt;/p&gt;

&lt;p&gt;泛型是 Swift 强大特征中的其中一个,许多 Swift 标准库是通过泛型代码构建出来的。事实上,泛型的使用贯穿了整本语言手册,只是你没有发现而已。例如,Swift 的数组和字典类型都是泛型集。你可以创建一个 Int 数组,也可创建一个 String 数组,或者甚至于可以是任何其他 Swift 的类型数据数组。同样的,你也可以创建存储任何指定类型的字典(dictionary),而且这些类型可以是没有限制的。&lt;/p&gt;

&lt;h2 id=&#34;泛型所解决的问题&#34;&gt;泛型所解决的问题&lt;/h2&gt;

&lt;p&gt;这里是一个标准的,非泛型函数 swapTwoInts ,用来交换两个Int值:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func swapTwoInts(inout a: Int, inout b: Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数使用写入读出(in-out)参数来交换 a 和 b 的值,请参考输入输出参数。&lt;/p&gt;

&lt;p&gt;swapTwoInts(&lt;em&gt;:&lt;/em&gt;:) 函数可以交换 b 的原始值到 a ,也可以交换a的原始值到 b ,你可以调用这个函数交换两 个 Int 变量值:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var someInt = 3
var anotherInt = 107
swapTwoInts(&amp;amp;someInt, &amp;amp;anotherInt)
println(&amp;quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&amp;quot;)
// prints &amp;quot;someInt is now 107, and anotherInt is now 3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;swapTwoInts(&lt;em&gt;:&lt;/em&gt;:) 函数是非常有用的,但是它只能交换 Int 值,如果你想要交换两个 String 或者 Double ,就不得不写更多的函数,如 swapTwoStrings 和 swapTwoDoubles(&lt;em&gt;:&lt;/em&gt;:) ,如同如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func swapTwoStrings(inout a: String, inout b: String) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swapTwoDoubles(inout a: Double, inout b: Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能注意到 swapTwoInts 、 swapTwoStrings 和 swapTwoDoubles(&lt;em&gt;:&lt;/em&gt;:) 函数功能都是相同的,唯一不同之处就在于传入的变量类型不同,分别是 Int 、 String 和 Double 。&lt;/p&gt;

&lt;p&gt;但实际应用中通常需要一个用处更强大并且尽可能的考虑到更多的灵活性单个函数,可以用来交换两个任何类型值,很幸运的是,泛型代码帮你解决了这种问题。(一个这种泛型函数后面已经定义好了。)&lt;/p&gt;

&lt;p&gt;注意: 在所有三个函数中, a 和 b 的类型是一样的。如果 a 和 b 不是相同的类型,那它们俩就不能互换值。Swift 是类型安全的语言,所以它不允许一个 String 类型的变量和一个 Double 类型的变量互相交换值。如果一定要做,Swift 将报编译错误。&lt;/p&gt;

&lt;h2 id=&#34;泛型函数&#34;&gt;泛型函数&lt;/h2&gt;

&lt;p&gt;泛型函数 可以工作于任何类型,这里是一个上面 swapTwoInts(&lt;em&gt;:&lt;/em&gt;:) 函数的泛型版本,用于交换两个值:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func swapTwoValues&amp;lt;T&amp;gt;(inout a: T, inout b: T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;swapTwoValues(&lt;em&gt;:&lt;/em&gt;:) 函数主体和 swapTwoInts(&lt;em&gt;:&lt;/em&gt;:) 函数是一样的,它只在第一行稍微有那么一点点不同于 swapTwoInts ,如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func swapTwoInts(inout a: Int, inout b: Int)
func swapTwoValues&amp;lt;T&amp;gt;(inout a: T, inout b: T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数的泛型版本使用了占位类型名字(通常此情况下用字母 T 来表示)来代替实际类型名(如 In、String 或 Doubl)。占位类型名没有提示 T 必须是什么类型,但是它提示了 a 和 b 必须是同一类型T,而不管T表示什么类型。只有 swapTwoValues(&lt;em&gt;:&lt;/em&gt;:) 函数在每次调用时所传入的实际类型才能决定 T 所代表的类型。&lt;/p&gt;

&lt;p&gt;另外一个不同之处在于这个泛型函数名后面跟着的展位类型名字(T)是用尖括号括起来 的()。这个尖括号告诉 Swift 那个 T 是 swapTwoValues(&lt;em&gt;:&lt;/em&gt;:) 函数所定义的一个类型。因为 T 是一个占位命名类型,Swift 不会去查找命名为 T 的实际类型。&lt;/p&gt;

&lt;p&gt;swapTwoValues(&lt;em&gt;:&lt;/em&gt;:) 函数除了要求传入的两个任何类型值是同一类型外,也可以作为 swapTwoInts 函数被调用。每次 swapTwoValues 被调用,T 所代表的类型值都会传给函数。&lt;/p&gt;

&lt;p&gt;在下面的两个例子中,T 分别代表 Int 和 String:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var someInt = 3
var anotherInt = 107
swapTwoValues(&amp;amp;someInt, &amp;amp;anotherInt)
// someInt is now 107, and anotherInt is now 3

var someString = &amp;quot;hello&amp;quot;
var anotherString = &amp;quot;world&amp;quot;
swapTwoValues(&amp;amp;someString, &amp;amp;anotherString)
// someString is now &amp;quot;world&amp;quot;, and anotherString is now &amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:上面定义的函数 swapTwoValues(&lt;em&gt;:&lt;/em&gt;:) 是受 swap 函数启发而实现的。swap 函数存在于Swift 标准库,并可以在其它类中任意使用。如果你在自己代码中需要类似 swapTwoValues 函数的功能,你可以使用已存在的交换函数 swap(&lt;em&gt;:&lt;/em&gt;:) 函数。&lt;/p&gt;

&lt;h2 id=&#34;类型参数&#34;&gt;类型参数&lt;/h2&gt;

&lt;p&gt;在上面的 swapTwoValues 例子中,占位类型 T 是一种类型参数的示例。类型参数指定并 命名为一个占位类型,并且紧随在函数名后面,使用一对尖括号括起来(如)。&lt;/p&gt;

&lt;p&gt;一旦一个类型参数被指定,那么其可以被使用来定义一个函数的参数类型(如swapTwoValues(&lt;em&gt;:&lt;/em&gt;:) 函数中的参数 a 和 b),或作为一个函数返回类型,或用作函数主体中的 注释类型。在这种情况下,被类型参数所代表的占位类型不管函数任何时候被调用,都会 被实际类型所替换(在上面 swapTwoValues 例子中,当函数第一次被调用时,T 被 Int 替换,第二次调用时,被 String 替换。)。&lt;/p&gt;

&lt;p&gt;你可支持多个类型参数,命名在尖括号中,用逗号分开。&lt;/p&gt;

&lt;h2 id=&#34;命名类型参数&#34;&gt;命名类型参数&lt;/h2&gt;

&lt;p&gt;在简单的情况下,泛型函数或泛型类型需要指定一个占位类型(如上面的 swapTwoValues 泛型函数,或一个存储单一类型的泛型集,如数组),通常用一单个字母 T 来命名类型参 数。不过,你可以使用任何有效的标识符来作为类型参数名。&lt;/p&gt;

&lt;p&gt;如果你使用多个参数定义更复杂的泛型函数或泛型类型,那么使用更多的描述类型参数是 非常有用的。如,Swift 字典(Dictionary)类型有两个类型参数,一个是键,另外一个是值。如果你自己写字典,你或许会定义这两个类型参数为 KeyType 和 ValueType,用来 记住它们在你的泛型代码中的作用。&lt;/p&gt;

&lt;p&gt;注意:请始终使用大写字母开头的驼峰式命名法(例如 T 和 KeyType)来给类型参数命 名,以表明它们是类型的占位符,而非类型值。&lt;/p&gt;

&lt;h2 id=&#34;泛型类型&#34;&gt;泛型类型&lt;/h2&gt;

&lt;p&gt;通常在泛型函数中,Swift 允许你定义你自己的泛型类型。这些自定义类、结构体和枚举 作用于任何类型,如同 Array 和 Dictionary 的用法。&lt;/p&gt;

&lt;p&gt;这部分向你展示如何写一个泛型集类型&amp;ndash;Stack(栈)。一个栈是一系列值域的集合,和 Array(数组)类似,但其是一个比 Swift 的 Array 类型更多限制的集合。一个数组可以允 许其里面任何位置的插入/删除操作,而栈,只允许在集合的末端添加新的项(如同 push 一个新值进栈)。同样的一个栈也只能从末端移除项(如同 pop 一个值出栈)。&lt;/p&gt;

&lt;p&gt;注意:栈的概念已被 UINavigationController 类使用来模拟试图控制器的导航结构。你通过调用UINavigationController 的 pushViewController:animated:方法来为导航栈添加 (add)新的试图控制器;而通过 popViewControllerAnimated:的方法来从导航栈中移除 (pop)某个试图控制器。每当你需要一个严格的后进先出方式来管理集合,堆栈都是最实用的模型。&lt;/p&gt;

&lt;p&gt;下图展示了一个栈的压栈(push)/出栈(pop)的行为:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSGenerics/1.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;现在有三个值在栈中;&lt;/li&gt;
&lt;li&gt;第四个值“pushed”到栈的顶部;&lt;/li&gt;
&lt;li&gt;现在有四个值在栈中,最近的那个在顶部;&lt;/li&gt;
&lt;li&gt;栈中最顶部的那个项被移除,或称之为“popped”;&lt;/li&gt;
&lt;li&gt;移除掉一个值后,现在栈又重新只有三个值。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里展示了如何写一个非泛型版本的栈,Int 值型的栈:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct IntStack {
    var items = [Int]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&amp;gt; Int {
        return items.removeLast()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个结构体在栈中使用一个 Array 性质的 items 存储值。Stack 提供两个方法:push 和 pop,从栈中压进一个值和移除一个值。这些方法标记为可变的,因为他们需要修改(或 转换)结构体的 items 数组。&lt;/p&gt;

&lt;p&gt;上面所展现的 IntStack 类型只能用于 Int 值,不过,其对于定义一个泛型 Stack 类(可以处理任何类型值的栈)是非常有用的。&lt;/p&gt;

&lt;p&gt;这里是一个相同代码的泛型版本:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Stack&amp;lt;T&amp;gt; {
    var items = [T]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -&amp;gt; T {
        return items.removeLast()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到 Stack 的泛型版本基本上和非泛型版本相同,但是泛型版本的占位类型参数为 T 代替了实际 Int 类型。这种类型参数包含在一对尖括号里(&lt;T&gt;),紧随在结构体名字后面。&lt;/p&gt;

&lt;p&gt;T 定义了一个名为“某种类型 T”的节点提供给后来用。这种将来类型可以在结构体的定义里 任何地方表示为“T”。在这种情况下,T 在如下三个地方被用作节点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建一个名为 items 的属性,使用空的 T 类型值数组对其进行初始化;&lt;/li&gt;
&lt;li&gt;指定一个包含一个参数名为 item 的 push 方法,该参数必须是 T 类型;&lt;/li&gt;
&lt;li&gt;指定一个 pop 方法的返回值,该返回值将是一个 T 类型值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于 Stack 是泛型类型,所以在 Swift 中其可以用来创建任何有效类型的栈,这种方式如同 Array 和 Dictionary。&lt;/p&gt;

&lt;p&gt;你可以通过在尖括号里写出栈中需要存储的数据类型来创建并初始化一个 Stack 实例。比如,要创建一个 strings 的栈,你可以写成 Stack&lt;String&gt;() :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var stackOfStrings = Stack&amp;lt;String&amp;gt;()
stackOfStrings.push(&amp;quot;uno&amp;quot;)
stackOfStrings.push(&amp;quot;dos&amp;quot;)
stackOfStrings.push(&amp;quot;tres&amp;quot;)
stackOfStrings.push(&amp;quot;cuatro&amp;quot;)
// the stack now contains 4 strings
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下图将展示 stackOfStrings 如何 push 这四个值进栈的过程:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSGenerics/2.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;p&gt;￼从栈中 pop 并移除值&amp;rdquo;cuatro&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let fromTheTop = stackOfStrings.pop()
// fromTheTop is equal to &amp;quot;cuatro&amp;quot;, and the stack now contains 3 strings
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下图展示了如何从栈中 pop 一个值的过程:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/iOSGenerics/3.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;扩展一个泛型类型&#34;&gt;扩展一个泛型类型&lt;/h2&gt;

&lt;p&gt;当你扩展一个泛型类型的时候,你并不需要在扩展的定义中提供类型参数列表。更加方便的是,原始类型定义中声明的类型参数列表在扩展里是可以使用的,并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。&lt;/p&gt;

&lt;p&gt;下面的例子扩展了泛型 Stack 类型,为其添加了一个名为 topItem 的只读计算属性,它将会返回当前栈顶端的元 素而不会将其从栈中移除。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Stack { var topItem: T? {
    return items.isEmpty ? nil : items[items.count - 1] }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;topItem 属性会返回一个 T 类型的可选值。当栈为空的时候, topItem 将会返回 nil ;当栈不为空的时候, Item 会返回 items 数组中的最后一个元素。&lt;/p&gt;

&lt;p&gt;注意这里的扩展并没有定义一个类型参数列表。相反的, Stack 类型已有的类型参数名称, T ,被用在扩展中当做 topItem 计算属性的可选类型。&lt;/p&gt;

&lt;p&gt;topItem 计算属性现在可以被用来返回任意 Stack 实例的顶端元素而无需移除它:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if let topItem = stackOfStrings.topItem {
    print(&amp;quot;The top item on the stack is \(topItem).&amp;quot;)
}
// 输出 &amp;quot;The top item on the stack is tres.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;类型约束&#34;&gt;类型约束&lt;/h2&gt;

&lt;p&gt;swapTwoValues(&lt;em&gt;:&lt;/em&gt;:) 函数和 Stack 类型可以作用于任何类型,不过,有的时候对使用在泛型函数和泛型类型上的类型强制约束为某种特定类型是非常有用的。类型约束指定了一个必须继承自指定类的类型参数,或者遵循一个特定的协议或协议构成。&lt;/p&gt;

&lt;p&gt;例如,Swift 的 Dictionary 类型对作用于其键的类型做了些限制。在字典的描述中,字典的键类型必须是可哈希,也就是说,必须有一种方法可以使其被唯一的表示。 Dictionary 之所以需要其键是可哈希是为了以便于其检查其是否已经包含某个特定键的值。如无此需求, Dictionary 既不会告诉是否插入或者替换了某个特定键的值,也不能查找到已经存储在字典里面的给定键值。&lt;/p&gt;

&lt;p&gt;这个需求强制加上一个类型约束作用于 Dictionary 的键上,当然其键类型必须遵循 Hashable 协议(Swift 标准库中定义的一个特定协议)。所有的 Swift 基本类型(如String,Int, Double 和 Bool)默认都是可哈希。&lt;/p&gt;

&lt;p&gt;当你创建自定义泛型类型时,你可以定义你自己的类型约束,当然,这些约束要支持泛型编程的强力特征中的多数。抽象概念如可哈希具有的类型特征是根据他们概念特征来界定的,而不是他们的直接类型特征。&lt;/p&gt;

&lt;h3 id=&#34;类型约束语法&#34;&gt;类型约束语法&lt;/h3&gt;

&lt;p&gt;你可以写一个在一个类型参数名后面的类型约束,通过冒号分割,来作为类型参数链的一部分。这种作用于泛型函数的类型约束的基础语法如下所示(和泛型类型的语法相同):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func someFunction&amp;lt;T: SomeClass, U: SomeProtocol&amp;gt;(someT: T, someU: U) {
    // function body goes here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个假定函数有两个类型参数。第一个类型参数 T,有一个需要 T 必须是 SomeClass 子类的类型约束;第二个类型参数 U,有一个需要 U 必须遵循 SomeProtocol 协议的类型 约束。&lt;/p&gt;

&lt;h3 id=&#34;类型约束行为&#34;&gt;类型约束行为&lt;/h3&gt;

&lt;p&gt;这里有个名为 findStringIndex 的非泛型函数,该函数功能是去查找包含一给定 String 值的数组。若查找到匹配的字符串,findStringIndex 函数返回该字符串在数组中的索引值 (Int),反之则返回 nil:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func findStringIndex(array: [String], valueToFind: String) -&amp;gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;findStringIndex(&lt;em&gt;:&lt;/em&gt;:) 函数可以作用于查找一字符串数组中的某个字符串:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let strings = [&amp;quot;cat&amp;quot;, &amp;quot;dog&amp;quot;, &amp;quot;llama&amp;quot;, &amp;quot;parakeet&amp;quot;, &amp;quot;terrapin&amp;quot;]
if let foundIndex = findStringIndex(strings, &amp;quot;llama&amp;quot;) {
    println(&amp;quot;The index of llama is \(foundIndex)&amp;quot;)
}
// prints &amp;quot;The index of llama is 2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果只是针对字符串而言查找在数组中的某个值的索引,用处不是很大,不过,你可以写出相同功能的泛型函数 findIndex,用某个类型 T 值替换掉提到的字符串。&lt;/p&gt;

&lt;p&gt;这里展示如何写一个你或许期望的 findStringIndex 的泛型版本 findIndex。请注意这个函数 仍然返回 Int,是不是有点迷惑呢,而不是泛型类型?那是因为函数返回的是一个可选的索引数,而不是从数组中得到的一个可选值。需要提醒的是,这个函数不会编译,原因在例子后面会说明:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func findIndex&amp;lt;T&amp;gt;(array: [T], valueToFind: T) -&amp;gt; Int? {
   for (index, value) in enumerate(array) {
       if value == valueToFind {
           return index
       }
   }
   return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面所写的函数不会编译。这个问题的位置在等式的检查上,“if value == valueToFind”。不是所有的 Swift 中的类型都可以用等式符(==)进行比较。例如,如果你创建一个你自 己的类或结构体来表示一个复杂的数据模型,那么 Swift 没法猜到对于这个类或结构体而言“等于”的意思。正因如此,这部分代码不能可能保证工作于每个可能的类型 T,当你试图 编译这部分代码时估计会出现相应的错误。&lt;/p&gt;

&lt;p&gt;不过,所有的这些并不会让我们无从下手。Swift 标准库中定义了一个 Equatable 协议, 该协议要求任何遵循的类型实现等式符(==)和不等符(!=)对任何两个该类型进行比 较。所有的 Swift 标准类型自动支持Equatable 协议。&lt;/p&gt;

&lt;p&gt;任何 Equatable 类型都可以安全的使用在 findIndex(&lt;em&gt;:&lt;/em&gt;:) 函数中,因为其保证支持等式操作。 为了说明这个事实,当你定义一个函数时,你可以写一个 Equatable 类型约束作为类型参数定义的一部分:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func findIndex&amp;lt;T: Equatable&amp;gt;(array: [T], valueToFind: T) -&amp;gt; Int? {
    for (index, value) in enumerate(array) {
        if value == valueToFind {
            return index
        }
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;findIndex 中这个单个类型参数写做:T : Equatable,也就意味着“任何 T 类型都遵循 Equatable 协议”。&lt;/p&gt;

&lt;p&gt;findIndex(&lt;em&gt;:&lt;/em&gt;:) 函数现在则可以成功的编译过,并且作用于任何遵循 Equatable 的类型,如 Double 或 String:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let doubleIndex = findIndex([3.14159, 0.1, 0.25], 9.3)
// doubleIndex is an optional Int with no value, because 9.3 is not in the array
let stringIndex = findIndex([&amp;quot;Mike&amp;quot;, &amp;quot;Malcolm&amp;quot;, &amp;quot;Andrea&amp;quot;], &amp;quot;Andrea&amp;quot;)
// stringIndex is an optional Int containing a value of 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关联类型&#34;&gt;关联类型&lt;/h2&gt;

&lt;p&gt;当定义一个协议时,有的时候声明一个或多个关联类型作为协议定义的一部分是非常有用的。一个关联类型给定作用于协议部分的类型一个节点名(或别名)。作用于关联类型上实际类型是不需要指定的,直到该协议接受。关联类型被指定为 typealias 关键字。&lt;/p&gt;

&lt;h3 id=&#34;关联类型行为&#34;&gt;关联类型行为&lt;/h3&gt;

&lt;p&gt;这里是一个 Container 协议的例子,定义了一个 ItemType 关联类型:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol Container {
    typealias ItemType
    mutating func append(item: ItemType)
    var count: Int { get }
    subscript(i: Int) -&amp;gt; ItemType { get }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Container 协议定义了三个任何容器必须支持的兼容要求:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;必须可以通过 append 方法添加一个新 item 到容器里;&lt;/li&gt;
&lt;li&gt;必须可以通过使用 count 属性获取容器里 items 的数量,并返回一个 Int 值;&lt;/li&gt;
&lt;li&gt;必须可以通过容器的 Int 索引值下标可以检索到每一个 item。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个协议没有指定容器里 item 是如何存储的或何种类型是允许的。这个协议只指定三个任何遵循 Container 类型所必须支持的功能点。一个遵循的类型也可以提供其他额外的功能,只要满足这三个条件。&lt;/p&gt;

&lt;p&gt;任何遵循 Container 协议的类型必须指定存储在其里面的值类型,必须保证只有正确类型的 items 可以加进容器里,必须明确可以通过其下标返回 item 类型。&lt;/p&gt;

&lt;p&gt;为了定义这三个条件,Container 协议需要一个方法指定容器里的元素将会保留,而不需要知道特定容器的类型。Container 协议需要指定任何通过 append 方法添加到容器里的值 和容器里元素是相同类型,并且通过容器下标返回的容器元素类型的值的类型是相同类型。&lt;/p&gt;

&lt;p&gt;为了达到此目的, Container 协议声明了一个 ItemType 的关联类型,写作 typealias ItemType 。这个协议不 会定义 ItemType 是什么的别名,这个信息将由任何遵循协议的类型来提供。尽管如此, ItemType 别名提供了 一种识别 Container 中元素类型的方法,并且用于 append(_:) 方法和 subscript 方法的类型定义,以便保证任 何 Container 期望的行为能够被执行。&lt;/p&gt;

&lt;p&gt;这里是一个早前 IntStack 类型的非泛型版本,遵循 Container 协议:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct IntStack: Container {
    // original IntStack implementation
    var items = [Int]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() -&amp;gt; Int {
        return items.removeLast()
    }
    // conformance to the Container protocol
    typealias ItemType = Int
    mutating func append(item: Int) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -&amp;gt; Int {
        return items[i]
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IntStack 类型实现了 Container 协议的所有三个要求,在 IntStack 类型的每个包含部分的功能都满足这些要求。&lt;/p&gt;

&lt;p&gt;此外,IntStack 指定了 Container 的实现,适用的 ItemType 被用作 Int 类型。对于这个 Container 协议实现而言,定义 typealias ItemType = Int,将抽象的 ItemType 类型转换为具体的 Int 类型。&lt;/p&gt;

&lt;p&gt;感谢 Swift 类型参考,你不用在 IntStack 定义部分声明一个具体的 Int 的 ItemType。由于IntStack 遵循 Container 协议的所有要求,只要通过简单的查找 append 方法的 item 参数类型和下标返回的类型,Swift 就可以推断出合适的 ItemType 来使用。确实,如果上面的代码中你删除了 typealias ItemType = Int 这一行,一切仍旧可以工作,因为它清楚的知道ItemType 使用的是何种类型。&lt;/p&gt;

&lt;p&gt;你也可以生成遵循 Container 协议的泛型 Stack 类型:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Stack&amp;lt;T&amp;gt;: Container {
    // original Stack&amp;lt;T&amp;gt; implementation
    var items = [T]()
    mutating func push(item: T) {
        items.append(item)
    }
    mutating func pop() -&amp;gt; T {
        return items.removeLast()
    }
    // conformance to the Container protocol
    mutating func append(item: T) {
        self.push(item)
    }
    var count: Int {
        return items.count
    }
    subscript(i: Int) -&amp;gt; T {
        return items[i]
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候,占位类型参数 T 被用作 append 方法的 item 参数和下标的返回类型。Swift 因此可以推断出被用作这个特定容器的 ItemType 的 T 的合适类型。&lt;/p&gt;

&lt;h3 id=&#34;扩展一个存在的类型为一指定关联类型&#34;&gt;扩展一个存在的类型为一指定关联类型&lt;/h3&gt;

&lt;p&gt;在使用扩展来添加协议兼容性中有描述扩展一个存在的类型添加遵循一个协议。这个类型包含一个关联类型的协议。&lt;/p&gt;

&lt;p&gt;Swift 的 Array 已经提供 append(_:) 方法,一个 count 属性和通过下标来查找一个自己的元素。这三个功能都达到 Container 协议的要求。也就意味着你可以扩展 Array 去遵循Container 协议,只要通过简单声明 Array 适用于该协议而已。如何实践这样一个空扩展, 在使用扩展来声明协议的采纳中有描述这样一个实现一个空扩展的行为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Array: Container {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如同上面的泛型 Stack 类型一样,Array 的 append 方法和下标保证 Swift 可以推断出ItemType 所使用的适用的类型。定义了这个扩展后,你可以将任何 Array 当作 Container 来使用。&lt;/p&gt;

&lt;h2 id=&#34;where-语句&#34;&gt;Where 语句&lt;/h2&gt;

&lt;p&gt;类型约束能够确保类型符合泛型函数或类的定义约束。&lt;/p&gt;

&lt;p&gt;对关联类型定义约束是非常有用的。你可以在参数列表中通过where语句定义参数的约束。一个 where 语句能够使一个关联类型遵循一个特定的协议,以及(或)那个特定的类型参数和关联类型可以是相同的。你可以写一个 where 语句,紧跟在类型参数列表后面,where语句后跟一个或者多个针对关联类型的约束,以及(或)一个或多个类型和关联类型间的等价(equality)关系。&lt;/p&gt;

&lt;p&gt;下面的列子定义了一个名为 allItemsMatch 的泛型函数,用来检查是否两个 Container 单例 包含具有相同顺序的相同元素。如果匹配到所有的元素,那么返回一个为 true 的 Boolean值,反之,则相反。&lt;/p&gt;

&lt;p&gt;被检查的两个 可以不是相同类型的容器(虽然它们可以是),但它们确实拥有相同类型的元素。这个 需求通过一个类型约束和 语句结合来表示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func allItemsMatch&amp;lt;
    C1: Container, C2: Container
    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&amp;gt;
    (someContainer: C1, anotherContainer: C2) -&amp;gt; Bool {

        // check that both containers contain the same number of items
        if someContainer.count != anotherContainer.count {
            return false
        }

        // check each pair of items to see if they are equivalent
        for i in 0..&amp;lt;someContainer.count {
            if someContainer[i] != anotherContainer[i] {
                return false
            }
        }

        // all items match, so return true
        return true

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数用了两个参数:someContainer 和 anotherContainer。someContainer 参数是类型C1,anotherContainer 参数是类型 C2。C1 和 C2 是容器的两个占位类型参数,决定了这个函数何时被调用。&lt;/p&gt;

&lt;p&gt;这个函数的类型参数列紧随在两个类型参数需求的后面:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C1 必须遵循 Container 协议 (写作 C1: Container)。&lt;/li&gt;
&lt;li&gt;C2 必须遵循 Container 协议 (写作 C2: Container)。&lt;/li&gt;
&lt;li&gt;C1 的 ItemType 同样是 C2 的 ItemType(写作 C1.ItemType == C2.ItemType)。&lt;/li&gt;
&lt;li&gt;C1 的 ItemType 必须遵循 Equatable 协议 (写作 C1.ItemType: Equatable)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第三个和第四个要求被定义为一个 where 语句的一部分,写在关键字 where 后面,作为函 数类型参数链的一部分。&lt;/p&gt;

&lt;p&gt;这些要求意思是:&lt;/p&gt;

&lt;p&gt;someContainer 是一个 C1 类型的容器。 anotherContainer 是一个 C2 类型的容器。someContainer 和 anotherContainer 包含相同的元素类型。 someContainer 中的元素可以通过不等于操作(!=)来检查它们是否彼此不同。&lt;/p&gt;

&lt;p&gt;第三个和第四个要求结合起来的意思是 anotherContainer 中的元素也可以通过 != 操作来检查,因为他们在 someContainer 中元素确实是相同的类型。&lt;/p&gt;

&lt;p&gt;这些要求能够使 allItemsMatch 函数比较两个容器,即便他们是不同的容器类型。&lt;/p&gt;

&lt;p&gt;allItemsMatch(&lt;em&gt;:&lt;/em&gt;:) 首先检查两个容器是否拥有同样数目的 items,如果他们的元素数目不同,没有办法进行匹配,函数就会 false。&lt;/p&gt;

&lt;p&gt;检查完之后,函数通过 for-in 循环和半闭区间操作(..&amp;lt;)来迭代 someContainer 中的所有元素。对于每个元素,函数检查是否 someContainer 中的元素不等于对应的 anotherContainer 中的元素,如果这两个元素不等,则这两个容器不匹配,返回 false。&lt;/p&gt;

&lt;p&gt;如果循环体结束后未发现没有任何的不匹配,那表明两个容器匹配,函数返回 true。&lt;/p&gt;

&lt;p&gt;这里演示了allItemsMatch 函数运算的过程:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var stackOfStrings = Stack&amp;lt;String&amp;gt;()
stackOfStrings.push(&amp;quot;uno&amp;quot;)
stackOfStrings.push(&amp;quot;dos&amp;quot;)
stackOfStrings.push(&amp;quot;tres&amp;quot;)

var arrayOfStrings = [&amp;quot;uno&amp;quot;, &amp;quot;dos&amp;quot;, &amp;quot;tres&amp;quot;]

if allItemsMatch(stackOfStrings, arrayOfStrings) {
    println(&amp;quot;All items match.&amp;quot;)
} else {
    println(&amp;quot;Not all items match.&amp;quot;)
}
// prints &amp;quot;All items match.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子创建一个 Stack 单例来存储 String,然后压了三个字符串进栈。这个例子也创建了一个 Array 单例,并初始化包含三个同栈里一样的原始字符串。即便栈和数组否是不 同的类型,但他们都遵循 Container 协议,而且他们都包含同样的类型值。你因此可以调 用 allItemsMatch 函数,用这两个容器作为它的参数。在上面的例子中,allItemsMatch 函数正确的显示了所有的这两个容器的 items 匹配。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Swift之协议</title>
      <link>http://lynchwong.com/2015/03/swift%E4%B9%8B%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Fri, 06 Mar 2015 14:12:12 +0000</pubDate>
      
      <guid>http://lynchwong.com/2015/03/swift%E4%B9%8B%E5%8D%8F%E8%AE%AE/</guid>
      <description>&lt;p&gt;协议定义了一个蓝图,规定了用来实现某一特定工作或者功能所必需的方法和属性。类,结构体或枚举类型都可以遵循协议,并提供具体实现来完成协议定义的方法和功能。任意能够满足协议要求的类型被称为遵循(conform)这个协议。
&lt;/p&gt;

&lt;h2 id=&#34;协议的语法&#34;&gt;协议的语法&lt;/h2&gt;

&lt;p&gt;协议的定义与类,结构体,枚举的定义非常相似,如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol SomeProtocol {
    // protocol definition goes here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要使类遵循某个协议,需要在类型名称后加上协议名称,中间以冒号 : 分隔,作为类型定义的一部分。遵循多个 协议时,各协议之间用逗号 , 分隔。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct SomeStructure: FirstProtocol, AnotherProtocol {
    // structure definition goes here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果类在遵循协议的同时拥有父类,应该将父类名放在协议名之前,以逗号分隔。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {
    // class definition goes here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;对属性的规定&#34;&gt;对属性的规定&lt;/h2&gt;

&lt;p&gt;协议可以规定其遵循者提供特定名称和类型的实例属性(instance property) 或 类属性(type property) ,而不指定是存储型属性(stored property)还是计算型属性(calculate property) 。此外还必须指明是只读的还是可读可写 的。&lt;/p&gt;

&lt;p&gt;如果协议规定属性是可读可写的,那么这个属性不能是常量或只读的计算属性。如果协议只要求属性是只读的(ge ttable),那个属性不仅可以是只读的,如果你代码需要的话,也可以是可写的。&lt;/p&gt;

&lt;p&gt;协议中通常用var来声明属性,在类型声明后加上 { set get } 来表示属性是可读可写的,只读属性则用 { get } 来表示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在协议中定义类属性(type property)时,总是使用 static 关键字作为前缀。当协议的遵循者是类时,可以使用 class 或 static 关键字来声明类属性,但是在协议的定义中,仍然要使用 static 关键字。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol AnotherProtocol {
    static var someTypeProperty: Int { get set }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如下所示,这是一个含有一个实例属性要求的协议。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol FullyNamed {
    var fullName: String { get }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FullyNamed 协议除了要求协议的遵循者提供fullName属性外,对协议遵循者的类型并没有特别的要求。这个协议表示,任何遵循协议的类型,都具有一个可读的   类型实例属性fullName。&lt;/p&gt;

&lt;p&gt;下面是一个遵循 FullyNamed 协议的简单结构体。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Person: FullyNamed {
    var fullName: String
}
let john = Person(fullName: &amp;quot;John Appleseed&amp;quot;)
// john.fullName is &amp;quot;John Appleseed&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子中定义了一个叫做 Person 的结构体,用来表示具有名字的人。从第一行代码中可以看出,它遵循了 FullyNamed 协议。&lt;/p&gt;

&lt;p&gt;Person 结构体的每一个实例都会有一个叫做fullName,String类型的存储属性。这正好满足了 FullyNamed 协议的要求,也就意味着,Person 结构体完整的遵循了协议。(如果协议要求未被完全满足，在编译时会报错)&lt;/p&gt;

&lt;p&gt;下面是一个更为复杂的类,它采用并遵循了 FullyNamed 协议:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Starship: FullyNamed {
    var prefix: String?
    var name: String
    init(name: String, prefix: String? = nil) {
        self.name = name
        self.prefix = prefix
    }
    var fullName: String {
        return (prefix != nil ? prefix! + &amp;quot; &amp;quot; : &amp;quot;&amp;quot;) + name
    }
}
var ncc1701 = Starship(name: &amp;quot;Enterprise&amp;quot;, prefix: &amp;quot;USS&amp;quot;)
// ncc1701.fullName is &amp;quot;USS Enterprise&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Starship类把 fullName 属性实现为只读的计算型属性。每一个 Starship 类的实例都有一个名为 name 的属性和一个名为 prefix 的可选属性。当 prefix 存在时,将 prefix 插入到 name 之前来为Starship构建 fullName, prefix 不存在时,则将直接用 name 构建 fullName。&lt;/p&gt;

&lt;h2 id=&#34;对方法的规定&#34;&gt;对方法的规定&lt;/h2&gt;

&lt;p&gt;协议可以要求其遵循者实现某些指定的实例方法或类方法。这些方法作为协议的一部分,像普通的方法一样放在协议的定义中,但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法,和普通方法的定义方式相同。但是在协议的方法定义中,不支持参数默认值。&lt;/p&gt;

&lt;p&gt;正如对属性的规定中所说的,在协议中定义类方法的时候,总是使用 static 关键字作为前缀。当协议的遵循者是类的时候,虽然你可以在类的实现中使用 class 或者 static 来实现类方法,但是在协议中声明类方法,仍然要使用 static 关键字。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol SomeProtocol {
    static func someTypeMethod()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的例子定义了含有一个实例方法的协议。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol RandomNumberGenerator {
    func random() -&amp;gt; Double
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RandomNumberGenerator 协议要求其遵循者必须拥有一个名为 random, 返回值类型为Double 的实例方法。尽管这里并未指明，但是我们假设返回值在[0,1)区间内。&lt;/p&gt;

&lt;p&gt;RandomNumberGenerator 协议并不在意每一个随机数是怎样生成的,它只强调这里有一个随机数生成器。&lt;/p&gt;

&lt;p&gt;如下所示,下边是一个遵循了 RandomNumberGenerator 协议的类。该类实现了一个叫做线性同余生成器(linear congruential generator)的伪随机数算法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -&amp;gt; Double {
        lastRandom = ((lastRandom * a + c) % m)
        return lastRandom / m
    }
}
let generator = LinearCongruentialGenerator()
println(&amp;quot;Here&#39;s a random number: \(generator.random())&amp;quot;)
// prints &amp;quot;Here&#39;s a random number: 0.37464991998171&amp;quot;
println(&amp;quot;And another one: \(generator.random())&amp;quot;)
// prints &amp;quot;And another one: 0.729023776863283&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;对mutating方法的规定&#34;&gt;对Mutating方法的规定&lt;/h2&gt;

&lt;p&gt;有时需要在方法中改变它的实例。例如,值类型(结构体,枚举)的实例方法中,将 mutating 关键字作为函数的前缀,写在 func 之前,表示可以在该方法中修改它所属的实例及其实例属性的值。这一过程在在实例方法中修改值类型章节中有详细描述。&lt;/p&gt;

&lt;p&gt;如果你在协议中定义了一个方法旨在改变遵循该协议的实例,那么在协议定义时需要在方法前加 mutating 关键字。这使得结构和枚举遵循协议并满足此方法要求。&lt;/p&gt;

&lt;p&gt;注意:用类实现协议中的 mutating 方法时,不用写 mutating 关键字;用结构体,枚举实现协议中的 mutating 方法 时,必须写 mutating 关键字。&lt;/p&gt;

&lt;p&gt;如下所示, Togglable 协议含有名为 toggle 的实例方法。根据名称推测, toggle() 方法将通过改变实例属性,来切换遵循该协议的实例的状态。&lt;/p&gt;

&lt;p&gt;toggle() 方法在定义的时候,使用 mutating 关键字标记,这表明当它被调用时该方法将会改变协议遵循者实例的状态。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol Togglable {
    mutating func toggle()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当使用枚举或结构体来实现 Togglable 协议时,需要提供一个带有 mutating 前缀的 toggle 方法。
￼
下面定义了一个名为 OnOffSwitch 的枚举类型。这个枚举类型在两种状态之间进行切换,用枚举成员 On 和 Off 表示。枚举类型的 toggle 方法被标记为 mutating 以满足 Togglable 协议的要求。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum OnOffSwitch: Togglable {
    case Off, On
    mutating func toggle() {
        switch self {
        case Off:
            self = On
        case On:
            self = Off
        }
    }
}
var lightSwitch = OnOffSwitch.Off
lightSwitch.toggle()
// lightSwitch is now equal to .On
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;对构造器的规定&#34;&gt;对构造器的规定&lt;/h2&gt;

&lt;p&gt;协议可以要求它的遵循者实现指定的构造器。你可以像书写普通的构造器那样,在协议的定义里写下构造器的声明,但不需要写花括号和构造器的实体:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol SomeProtocol { 
    init(someParameter: Int)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;协议构造器规定在类中的实现&#34;&gt;协议构造器规定在类中的实现&lt;/h3&gt;

&lt;p&gt;你可以在遵循该协议的类中实现构造器,并指定其为类的指定构造器(designated initializer)或者便利构造器(co nvenience initializer)。在这两种情况下,你都必须给构造器实现标上&amp;rdquo;required&amp;rdquo;修饰符:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class SomeClass: SomeProtocol { 
    required init(someParameter: Int) {
        //构造器实现 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 required 修饰符可以保证:所有的遵循该协议的子类,同样能为构造器规定提供一个显式的实现或继承实现。&lt;/p&gt;

&lt;p&gt;关于 required 构造器的更多内容,请参考必要构造器。&lt;/p&gt;

&lt;p&gt;注意:如果类已经被标记为 final ,那么不需要在协议构造器的实现中使用 required 修饰符。因为final类不能有子类。关于 final 修饰符的更多内容,请参见防止重写。&lt;/p&gt;

&lt;p&gt;如果一个子类重写了父类的指定构造器,并且该构造器遵循了某个协议的规定,那么该构造器的实现需要被同时标示 required 和 override 修饰符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol SomeProtocol { 
    init()
}

class SomeSuperClass { 
    init() {
        // 构造器的实现 
    }
}

class SomeSubClass: SomeSuperClass, SomeProtocol {
    // 因为遵循协议,需要加上&amp;quot;required&amp;quot;; 因为继承自父类,需要加上&amp;quot;override&amp;quot; 
    required override init() {
        // 构造器实现 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;可失败构造器的规定&#34;&gt;可失败构造器的规定&lt;/h3&gt;

&lt;p&gt;可以通过给协议 Protocols 中添加可失败构造器来使遵循该协议的类型必须实现该可失败构造器。&lt;/p&gt;

&lt;p&gt;如果在协议中定义一个可失败构造器,则在遵循该协议的类型中必须添加同名同参数的可失败构造器或非可失败构造器。如果在协议中定义一个非可失败构造器,则在遵循该协议的类型中必须添加同名同参数的非可失败构造器或隐式解析类型的可失败构造器( init! )。&lt;/p&gt;

&lt;h2 id=&#34;协议类型&#34;&gt;协议类型&lt;/h2&gt;

&lt;p&gt;尽管协议本身并不实现任何功能,但是协议可以被当做类型来使用。&lt;/p&gt;

&lt;p&gt;协议可以像其他普通类型一样使用,使用场景:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;作为函数,方法或构造器中的参数类型,返回值类型&lt;/li&gt;
&lt;li&gt;作为常量,变量,属性的类型&lt;/li&gt;
&lt;li&gt;作为数组,字典或其他容器中的元素类型&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意:协议是一种类型,因此协议类型的名称应与其他类型(Int,Double,String)的写法相同,使用大写字母开头的 驼峰式写法,例如( FullyNamed 和 RandomNumberGenerator )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -&amp;gt; Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子中定义了一个 Dice 类,用来代表桌游中的拥有N个面的骰子。 Dice 的实例含有 sides 和 generator 两个属性,前者是整型,用来表示骰子有几个面,后者为骰子提供一个随机数生成器。&lt;/p&gt;

&lt;p&gt;generator 属性的类型为 RandomNumberGenerator ,因此任何遵循了 RandomNumberGenerator 协议的 类型的实例都可以赋值给 generator ,除此之外,无其他要求。&lt;/p&gt;

&lt;p&gt;Dice 类中也有一个构造器(initializer),用来进行初始化操作。构造器中含有一个名为 generator ,类型为 Ran domNumberGenerator 的形参。在调用构造方法时创建 Dice 的实例时,可以传入任何遵循 RandomNumberG enerator 协议的实例给generator。&lt;/p&gt;

&lt;p&gt;Dice 类也提供了一个名为 roll 的实例方法用来模拟骰子的面值。它先使用 generator 的 random() 方法来创建 一个[0,1)区间内的随机数,然后使用这个随机数生成正确的骰子面值。因为generator遵循了 RandomNumber Generator 协议,因而保证了 random 方法可以被调用。&lt;/p&gt;

&lt;p&gt;下面的例子展示了如何使用 LinearCongruentialGenerator 的实例作为随机数生成器创建一个六面骰子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())
for _ in 1...5 {
    println(&amp;quot;Random dice roll is \(d6.roll())&amp;quot;)
}
// Random dice roll is 3
// Random dice roll is 5
// Random dice roll is 4
// Random dice roll is 5
// Random dice roll is 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;委托-代理-模式&#34;&gt;委托(代理)模式&lt;/h2&gt;

&lt;p&gt;委托是一种设计模式,它允许类或结构体将一些需要它们负责的功能交由(委托)给其他的类型的实例。委托模式的实现很简单: 定义协议来封装那些需要被委托的函数和方法,使其遵循者拥有这些被委托的函数和方法 。委托模式可以用来响应特定的动作或接收外部数据源提供的数据,而无需要知道外部数据源的类型信息。&lt;/p&gt;

&lt;p&gt;下文是两个基于骰子游戏的协议:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol DiceGame {
    var dice: Dice { get }
    func play()
}
protocol DiceGameDelegate {
    func gameDidStart(game: DiceGame)
    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)
    func gameDidEnd(game: DiceGame)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DiceGame 协议可以在任意含有骰子的游戏中实现,DiceGameDelegate 协议可以用来追踪 DiceGame 的游戏过程。&lt;/p&gt;

&lt;p&gt;如下所示,SnakesAndLadders 是 Snakes and Ladders(控制流章节有该游戏的详细介绍)游戏的新版本。新版本使用 Dice 作为骰子,并且实现了 DiceGame 和 DiceGameDelegate 协议,后者用来记录游戏的过程:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class SnakesAndLadders: DiceGame {
    let finalSquare = 25
    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())
    var square = 0
    var board: [Int]
    init() {
        board = [Int](count: finalSquare + 1, repeatedValue: 0)
        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
    }
    var delegate: DiceGameDelegate?
    func play() {
        square = 0
        delegate?.gameDidStart(self)
        gameLoop: while square != finalSquare {
            let diceRoll = dice.roll()
            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)
            switch square + diceRoll {
            case finalSquare:
                break gameLoop
            case let newSquare where newSquare &amp;gt; finalSquare:
                continue gameLoop
            default:
                square += diceRoll
                square += board[square]
            }
        }
        delegate?.gameDidEnd(self)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个版本的游戏封装到了 SnakesAndLadders 类中,该类遵循了 DiceGame 协议,并且提供了相应的可读的 dice 属性和 play 实例方法。( dice 属性在构造之后就不再改变,且协议只要求 dice 为只读的,因此将 dice 声明为常量属性。)&lt;/p&gt;

&lt;p&gt;游戏使用 SnakesAndLadders 类的 构造器(initializer) 初始化游戏。所有的游戏逻辑被转移到了协议中的 play 方法, play 方法使用协议规定的 dice 属性提供骰子摇出的值。&lt;/p&gt;

&lt;p&gt;注意: delegate 并不是游戏的必备条件,因此 delegate 被定义为遵循 DiceGameDelegate 协议的可选属性。因为 delegate 是可选值,因此在初始化的时候被自动赋值为 nil 。随后,可以在游戏中为 delegate 设置适当的 值。&lt;/p&gt;

&lt;p&gt;DicegameDelegate 协议提供了三个方法用来追踪游戏过程。被放置于游戏的逻辑中,即 play() 方法内。分别在游戏开始时,新一轮开始时,游戏结束时被调用。&lt;/p&gt;

&lt;p&gt;因为 delegate 是一个遵循 DiceGameDelegate 的可选属性,因此在 play() 方法中使用了 可选链 来调用委托方 法。 若 delegate 属性为 nil , 则delegate所调用的方法失效,并不会产生错误。若 delegate 不为 nil ,则方 法能够被调用。&lt;/p&gt;

&lt;p&gt;如下所示,DiceGameTracker 遵循了 DiceGameDelegate 协议&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class DiceGameTracker: DiceGameDelegate {
    var numberOfTurns = 0
    func gameDidStart(game: DiceGame) {
        numberOfTurns = 0
        if game is SnakesAndLadders {
            println(&amp;quot;Started a new game of Snakes and Ladders&amp;quot;)
        }
        println(&amp;quot;The game is using a \(game.dice.sides)-sided dice&amp;quot;)
    }
    func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
        ++numberOfTurns
        println(&amp;quot;Rolled a \(diceRoll)&amp;quot;)
    }
    func gameDidEnd(game: DiceGame) {
        println(&amp;quot;The game lasted for \(numberOfTurns) turns&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DiceGameTracker 实现了 DiceGameDelegate 协议的方法要求,用来记录游戏已经进行的轮数。当游戏开始时,numberOfTurns 属性被赋值为 0;在每新一轮中递加;游戏结束后, 输出打印游戏的总轮数。&lt;/p&gt;

&lt;p&gt;gameDidStart 方法从 game 参数获取游戏信息并输出。game 在方法中被当做 DiceGame 类型而不是 SnakeAndLadders 类型,所以方法中只能访问 DiceGame 协议中的成员。当然了,这些方法也可以在类型转换之后调用。在上例代码中,通过 is 操作符检查 game 是否为 SnakesAndLadders 类型的实例,如果是,则打印出相应的内容。&lt;/p&gt;

&lt;p&gt;DiceGameTracker 的运行情况,如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let tracker = DiceGameTracker()
let game = SnakesAndLadders()
game.delegate = tracker
game.play()
// Started a new game of Snakes and Ladders
// The game is using a 6-sided dice
// Rolled a 3
// Rolled a 5
// Rolled a 4
// Rolled a 5
// The game lasted for 4 turns
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;在扩展中添加协议成员&#34;&gt;在扩展中添加协议成员&lt;/h2&gt;

&lt;p&gt;即便无法修改源代码,依然可以通过扩展(Extension)来扩充已存在类型(译者注: 类,结构体,枚举等)。扩展可以为已存在的类型添加属性,方法,下标脚本,协议等成员。详情请在扩展章节中查看。&lt;/p&gt;

&lt;p&gt;注意:通过扩展为已存在的类型遵循协议时,该类型的所有实例也会随之添加协议中的方法。&lt;/p&gt;

&lt;p&gt;例如 TextRepresentable 协议,任何想要表示一些文本内容的类型都可以遵循该协议。这些想要表示的内容可以是类型本身的描述,也可以是当前内容的版本:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol TextRepresentable {
    func asText() -&amp;gt; String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过扩展,为上一节中提到的 Dice 增加类遵循 TextRepresentable 协议的功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Dice: TextRepresentable {
    func asText() -&amp;gt; String {
        return &amp;quot;A \(sides)-sided dice&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在,通过扩展使得 Dice 类型遵循了一个新的协议,这和 Dice 类型在定义的时候声明为遵循 TextRepresentable 协议的效果相同。在扩展的时候,协议名称写在类型名之后,以冒号隔开,在大括号内写明新添加的协议内容。&lt;/p&gt;

&lt;p&gt;现在所有 Dice 的实例都遵循了 TextRepresentable 协议:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())
println(d12.asText())
// prints &amp;quot;A 12-sided dice&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样 SnakesAndLadders 类也可以通过 扩展 的方式来遵循 TextRepresentable 协议:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension SnakesAndLadders: TextRepresentable {
    func asText() -&amp;gt; String {
        return &amp;quot;A game of Snakes and Ladders with \(finalSquare) squares&amp;quot;
    }
}
println(game.asText())
// prints &amp;quot;A game of Snakes and Ladders with 25 squares&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;通过扩展补充协议声明&#34;&gt;通过扩展补充协议声明&lt;/h2&gt;

&lt;p&gt;当一个类型已经实现了协议中的所有要求,却没有声明为遵循该协议时,可以通过扩展(空的扩展体)来补充协议声明:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Hamster {
    var name: String
    func asText() -&amp;gt; String {
        return &amp;quot;A hamster named \(name)&amp;quot;
    }
}
extension Hamster: TextRepresentable {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从现在起, Hamster 的实例可以作为 TextRepresentable 类型使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let simonTheHamster = Hamster(name: &amp;quot;Simon&amp;quot;)
let somethingTextRepresentable: TextRepresentable = simonTheHamster
println(somethingTextRepresentable.asText())
// prints &amp;quot;A hamster named Simon&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:即使满足了协议的所有要求,类型也不会自动转变,因此你必须为它做出显式的协议声明。&lt;/p&gt;

&lt;h2 id=&#34;集合中的协议类型&#34;&gt;集合中的协议类型&lt;/h2&gt;

&lt;p&gt;协议类型可以在集合使用,表示集合中的元素均为协议类型,下面的例子创建了一个类型为 TextRepresentable 的数组:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let things: [TextRepresentable] = [game, d12, simonTheHamster]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如下所示, things 数组可以被直接遍历,并打印每个元素的文本表示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for thing in things {
    println(thing.asText())
}
// A game of Snakes and Ladders with 25 squares
// A 12-sided dice
// A hamster named Simon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;￼thing 被当做是 TextRepresentable 类型而不是 Dice,DiceGame,Hamster 等类型。因此 能且仅能调用 asText 方法&lt;/p&gt;

&lt;h2 id=&#34;协议的继承&#34;&gt;协议的继承&lt;/h2&gt;

&lt;p&gt;协议能够继承一个或多个其他协议,可以在继承的协议基础上增加新的内容要求。协议的继承语法与类的继承相似,多个被继承的协议间用逗号分隔:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol InheritingProtocol: SomeProtocol, AnotherProtocol {
    // protocol definition goes here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如下所示, PrettyTextRepresentable 协议继承了 TextRepresentable 协议&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol PrettyTextRepresentable: TextRepresentable {
    func asPrettyText() -&amp;gt; String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例子中定义了一个新的协议 PrettyTextRepresentable ,它继承自 TextRepresentable 协议。任何遵循 TextRepresentable 协议的类型在满足该协议的要求时,也必须满足 TextRepresentable 协议的要求。在这个 例子中, PrettyTextRepresentable 协议要求其遵循者提供一个返回值为 String 类型的 asPrettyText 方法。&lt;/p&gt;

&lt;p&gt;如下所示,用扩展为 SnakesAndLadders 遵循 PrettyTextRepresentable 协议:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension SnakesAndLadders: PrettyTextRepresentable {
    func asPrettyText() -&amp;gt; String {
        var output = asText() + &amp;quot;:\n&amp;quot;
        for index in 1...finalSquare {
            switch board[index] {
            case let ladder where ladder &amp;gt; 0:
                output += &amp;quot;▲ &amp;quot;
            case let snake where snake &amp;lt; 0:
                output += &amp;quot;▼ &amp;quot;
            default:
                output += &amp;quot;○ &amp;quot;
            }
        }
        return output
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述扩展使得 SnakesAndLadders 遵循了 PrettyTextRepresentable 协议，并为每个 SnakesAndLadders 类型提供了协议要求的 asPrettyText() 方法。每个 PrettyTextRepresentable 类型同时也是 TextRepresentable 类型，所以在 asPrettyText 的实现中，可以调用 asText() 方法。之后在每一行加上换行符，作为输出的开始。然后遍历数组中的元素，输出一个几何图形来表示遍历的结果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当从数组中迭代出的元素的值大于 0 时,用▲表示。&lt;/li&gt;
&lt;li&gt;当从数组中迭代出的元素的值小于 0 时,用▼表示。&lt;/li&gt;
&lt;li&gt;当从数组中迭代出的元素的值等于 0 时,用○表示。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;任意 SankesAndLadders 的实例都可以使用 asPrettyText()方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;println(game.asPrettyText())
// A game of Snakes and Ladders with 25 squares:
// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;类专属协议&#34;&gt;类专属协议&lt;/h2&gt;

&lt;p&gt;你可以在协议的继承列表中,通过添加 class 关键字,限制协议只能适配到类(class)类型。(结构体或枚举不能遵循该协议)。该 class 关键字必须是第一个出现在协议的继承列表中,其后才是其他继承协议。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol { 
    // class-only protocol definition goes here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在以上例子中,协议 SomeClassOnlyProtocol 只能被类(class)类型适配。如果尝试让结构体或枚举类型适配该协议,则会出现编译错误。&lt;/p&gt;

&lt;p&gt;注意:当协议想要定义的行为,要求(或假设)它的遵循类型必须是引用语义而非值语义时,应该采用类专属协议。关于引用语义,值语义的更多内容,请查看结构体和枚举是值类型和类是引用类型。&lt;/p&gt;

&lt;h2 id=&#34;协议合成&#34;&gt;协议合成&lt;/h2&gt;

&lt;p&gt;有时候需要同时遵循多个协议。你可以将多个协议采用 protocol&lt;SomeProtocol, AnotherProtocol&gt; 这样的格式进行组合,称为协议合成(protocol composition) 。你可以在 &amp;lt;&amp;gt; 中罗列任意多个你想要遵循的协议,以逗号分隔。&lt;/p&gt;

&lt;p&gt;下面的例子中,将 Named 和 Aged 两个协议按照上述的语法组合成一个协议:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol Named {
    var name: String { get }
}
protocol Aged {
    var age: Int { get }
}
struct Person: Named, Aged {
    var name: String
    var age: Int
}
func wishHappyBirthday(celebrator: protocol&amp;lt;Named, Aged&amp;gt;) {
    println(&amp;quot;Happy birthday \(celebrator.name) - you&#39;re \(celebrator.age)!&amp;quot;)
}
let birthdayPerson = Person(name: &amp;quot;Malcolm&amp;quot;, age: 21)
wishHappyBirthday(birthdayPerson)
// prints &amp;quot;Happy birthday Malcolm - you&#39;re 21!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Named 协议包含 String 类型的 name 属性;Aged 协议包含 Int 类型的 age 属性。Person 结构体遵循了这两个协议。&lt;/p&gt;

&lt;p&gt;wishHappyBirthday 函数的形参 celebrator 的类型为 protocol&lt;Named,Aged&gt;。可以传入任意遵循这两个协议的类型的实例。&lt;/p&gt;

&lt;p&gt;注意:协议合成并不会生成一个新协议类型,而是将多个协议合成为一个临时的协议,超出范围后立即失效。&lt;/p&gt;

&lt;h2 id=&#34;检验协议的一致性&#34;&gt;检验协议的一致性&lt;/h2&gt;

&lt;p&gt;你可以使用 is 和 as 操作符来检查是否遵循某一协议或强制转化为某一类型。检查和转化的语法和之前相同(详情查看类型转换):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;is 操作符用来检查实例是否遵循了某个协议&lt;/li&gt;
&lt;li&gt;as? 返回一个可选值,当实例遵循协议时,返回该协议类型;否则返回nil&lt;/li&gt;
&lt;li&gt;as 用以强制向下转型,如果强转失败,会引起运行时错误。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面的例子定义了一个 HasArea 的协议,要求有一个 Double 类型可读的 area :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol HasArea {
    var area: Double { get }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如下所示,定义了 Circle 和 Country 类,它们都遵循了 HasArea 协议&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Circle: HasArea {
    let pi = 3.1415927
    var radius: Double
    var area: Double { return pi * radius * radius }
    init(radius: Double) { self.radius = radius }
}
class Country: HasArea {
    var area: Double
    init(area: Double) { self.area = area }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Circle 类把 area 实现为基于存储型属性 radius 的计算型属性,Country 类则把 area 实现为存储型属性。这两个类都遵循了 HasArea 协议。&lt;/p&gt;

&lt;p&gt;如下所示,Animal是一个没有实现 HasArea 协议的类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Animal {
    var legs: Int
    init(legs: Int) { self.legs = legs }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Circle,Country,Animal 并没有一个相同的基类,然而,它们都是类,它们的实例都可以作为 AnyObject 类型的变量，存储在同一个数组中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let objects: [AnyObject] = [
    Circle(radius: 2.0),
    Country(area: 243_610),
    Animal(legs: 4)
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;objects 数组使用字面量初始化,数组包含一个 radius 为2的 Circle 的实例,一个保存了英国面积的 Country 实例和一个 legs 为4的 Animal 实例。&lt;/p&gt;

&lt;p&gt;如下所示,objects数组可以被迭代,对迭代出的每一个元素进行检查,看它是否遵循了 HasArea 协议:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for object in objects {
    if let objectWithArea = object as? HasArea {
        println(&amp;quot;Area is \(objectWithArea.area)&amp;quot;)
    } else {
        println(&amp;quot;Something that doesn&#39;t have an area&amp;quot;)
    }
}
// Area is 12.5663708
// Area is 243610.0
// Something that doesn&#39;t have an area
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当数组中的元素遵循 HasArea 协议时,通过 as?操作符将其可选绑定(optional binding)到 objectWithArea 常量上。objectWithArea 是 HasArea 协议类型的实例，因此 area 属性是可以被访问和打印的。&lt;/p&gt;

&lt;p&gt;objects 数组中元素的类型并不会因为强转而丢失类型信息,它们仍然是Circle,Country,Animal类型。然而,当它们被赋值给 objectWithArea 常量时,则只被视为 HasArea 类型,因此只有 area 属性能够被访问。&lt;/p&gt;

&lt;h2 id=&#34;对可选协议的规定&#34;&gt;对可选协议的规定&lt;/h2&gt;

&lt;p&gt;协议可以含有可选成员,其遵循者可以选择是否实现这些成员。在协议中使用 optional 关键字作为前缀来定义可选成员。&lt;/p&gt;

&lt;p&gt;可选协议在调用时使用可选链,因为协议的遵循者可能没有实现可选内容,详细内容在可选链章节中查看。&lt;/p&gt;

&lt;p&gt;像 someOptionalMethod?(someArgument) 这样,你可以在可选方法名称后加上 ? 来检查该方法是否被实现。可选方法和可选属性都会返回一个 可选值(optional value),当其不可访问时, ? 之后语句不会执行,并整体返回 nil。&lt;/p&gt;

&lt;p&gt;注意:可选协议只能在含有 @objc 前缀的协议中生效。且 @objc 的协议只能被类遵循,这个前缀表示协议将暴露给Objective-C代码,详情参见 Using Swift with Cocoa and Objective-C 。即使你不打算和Objective-C有什么交互,如果你想要指明协议包含可选属性,那么还是要加上 @objc 前缀。&lt;/p&gt;

&lt;p&gt;下面的例子定义了一个叫 Counter 的整数加法类,它使用外部的数据源来实现每次的增量。数据源是两个可选属性,在 CounterDataSource 协议中定义:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@objc protocol CounterDataSource {
    optional func incrementForCount(count: Int) -&amp;gt; Int
    optional var fixedIncrement: Int { get }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CounterDataSource 含有 incrementForCount 可选方法和 fiexdIncrement 可选属性,它们使用了不同的方法 来从数据源中获取合适的增量值。&lt;/p&gt;

&lt;p&gt;注意:CounterDataSource 中的属性和方法都是可选的,因此可以在类中声明都不实现这些成员,尽管技术上允许
 这样做,不过最好不要这样写。&lt;/p&gt;

&lt;p&gt;Counter 类含有 CounterDataSource?类型的可选属性 dataSource,如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@objc class Counter {
    var count = 0
    var dataSource: CounterDataSource?
    func increment() {
        if let amount = dataSource?.incrementForCount?(count) {
            count += amount
        } else if let amount = dataSource?.fixedIncrement {
            count += amount
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类 Counter 使用 count 来存储当前的值。该类同时定义了一个 increment 方法,每次调用该方法的时候,将会 增加 count 的值。&lt;/p&gt;

&lt;p&gt;increment() 方法首先试图使用 incrementForCount(&lt;em&gt;:) 方法来得到每次的增量。 increment() 方法使用可选链 来尝试调用 incrementForCount(&lt;/em&gt;:) ,并将当前的 count 值作为参数传入。&lt;/p&gt;

&lt;p&gt;这里使用了两种可选链方法。由于 dataSource 可能为 nil ,因此在 dataSource 后边加上了 ? 标记来表明只在 dataSource 非空时才去调用 incrementForCount 方法。即使 dataSource 存在,但是也无法保证其是否实现了 incrementForCount 方法,因此在 incrementForCount 方法后边也加有 ? 标记。&lt;/p&gt;

&lt;p&gt;调用 incrementForCount 方法在上述两种情形都有可能失败,所以返回值为可选 Int 类型。虽然在 CounterDat aSource 中,incrementForCount 被定义为一个非可选 Int (non-optional),但是这里我们仍然需要返回可选 Int 类型。&lt;/p&gt;

&lt;p&gt;在调用 incrementForCount 方法后, Int 型可选值通过可选绑定(optional binding)自动拆包并赋值给常量 amount。如果可选值确实包含一个数值,这表示 delegate 和方法都存在,之后便将 amount 加到 count 上,增加操作完成。&lt;/p&gt;

&lt;p&gt;如果没有从 incrementForCount(_:) 获取到值,可能是 dataSource 为nil,或者它并没有实现 incrementForCount 方法——那么 increment() 方法将试图从数据源的 fixedIncrement 属性中获取增量。 fixedIncrement 也是一个可选型,所以在属性名的后面添加 ? 来试图取回可选属性的值。和之前一样,返回值为可选型。&lt;/p&gt;

&lt;p&gt;ThreeSource 实现了 CounterDataSource 协议,它实现来可选属性 fixedIncrement ,每次返回值 3 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ThreeSource: CounterDataSource {
    let fixedIncrement = 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用 ThreeSource 的实例作为 Counter 实例的数据源:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var counter = Counter()
counter.dataSource = ThreeSource()
for _ in 1...4 {
    counter.increment()
    println(counter.count)
}
// 3
// 6
// 9
// 12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码新建了一个 Counter 实例;将它的数据源设置为 TreeSource 实例;调用 increment() 4次。和你预想的一样,每次在调用的时候,count 的值增加3.&lt;/p&gt;

&lt;p&gt;下面是一个更为复杂的数据源 TowardsZeroSource ,它将使得最后的值变为0:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class TowardsZeroSource: CounterDataSource {
    func incrementForCount(count: Int) -&amp;gt; Int {
        if count == 0 {
            return 0
        } else if count &amp;lt; 0 {
            return 1
        } else {
            return -1
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TowardsZeroSource 实现了 CounterDataSource 协议中的 incrementForCount(_:) 方法,以 count 参数为依据,计算出每次的增量。如果 count 已经为0,方法返回0,这表示之后不会再有增量。&lt;/p&gt;

&lt;p&gt;你可以配合使用 TowardsZeroSource 实例和 Counter 实例来从 -4 增加到 0 .一旦增加到 0 ,数值便不会再 有变动。&lt;/p&gt;

&lt;p&gt;在下面的例子中,将从 -4 增加到 0 。一旦结果为 0 ,便不在增加:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;counter.count = -4
counter.dataSource = TowardsZeroSource()
for _ in 1...5 {
    counter.increment()
    println(counter.count)
}
// -3
// -2
// -1
// 0
// 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;协议扩展&#34;&gt;协议扩展&lt;/h2&gt;

&lt;p&gt;使用扩展协议的方式可以为遵循者提供方法或属性的实现。通过这种方式,可以让你无需在每个遵循者中都实现一次,无需使用全局函数,你可以通过扩展协议的方式进行定义。&lt;/p&gt;

&lt;p&gt;例如,可以扩展 RandomNumberGenerator 协议,让其提供 randomBool() 方法。该方法使用协议中要求的 random() 方法来实现:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension RandomNumberGenerator { 
    func randomBool() -&amp;gt; Bool {
        return random() &amp;gt; 0.5 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过扩展协议,所有协议的遵循者,在不用任何修改的情况下,都自动得到了这个扩展所增加的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let generator = LinearCongruentialGenerator()
print(&amp;quot;Here&#39;s a random number: \(generator.random())&amp;quot;)
// 输出 &amp;quot;Here&#39;s a random number: 0.37464991998171&amp;quot;
print(&amp;quot;And here&#39;s a random Boolean: \(generator.randomBool())&amp;quot;) 
// 输出 &amp;quot;And here&#39;s a random Boolean: true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;提供默认实现&#34;&gt;提供默认实现&lt;/h3&gt;

&lt;p&gt;可以通过协议扩展的方式来为协议规定的属性和方法提供默认的实现。如果协议的遵循者对规定的属性和方法提供了自己的实现,那么遵循者提供的实现将被使用。&lt;/p&gt;

&lt;p&gt;注意:通过扩展协议提供的协议实现和可选协议规定有区别。虽然协议遵循者无需自己实现,通过扩展提供的默认实现,可以不是用可选链调用。&lt;/p&gt;

&lt;p&gt;例如, PrettyTextRepresentable 协议,继承了 TextRepresentable 协议,可以为其提供一个默认的 asPrettyText() 方法来简化返回值:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension PrettyTextRepresentable { 
    func asPrettyText() -&amp;gt; String {
        return asText() 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;为协议扩展添加限制条件&#34;&gt;为协议扩展添加限制条件&lt;/h3&gt;

&lt;p&gt;在扩展协议的时候,可以指定一些限制,只有满足这些限制的协议遵循者,才能获得协议扩展提供的属性和方法。这些限制写在协议名之后,使用 where 关键字来描述限制情况:&lt;/p&gt;

&lt;p&gt;例如,你可以扩展 CollectionType 协议,只适用于元素遵循 TextRepresentable 的情况:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension CollectionType where Generator.Element : TextRepresentable { 
    func asList() -&amp;gt; String {
        return &amp;quot;(&amp;quot; + &amp;quot;, &amp;quot;.join(map({$0.asText()})) + &amp;quot;)&amp;quot; 
    }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;asList() 方法将每个元素以 asText() 的方式表示，最后以逗号分隔链接起来。&lt;/p&gt;

&lt;p&gt;现在我们来看 Hamster,它遵循 TextRepresentable：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let murrayTheHamster = Hamster(name: &amp;quot;Murray&amp;quot;)
let morganTheHamster = Hamster(name: &amp;quot;Morgan&amp;quot;)
let mauriceTheHamster = Hamster(name: &amp;quot;Maurice&amp;quot;)
let hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为 Array 遵循 CollectionType 协议,数组的元素又遵循 TextRepresentable 协议,所以数组可以使用 asList() 方法得到数组内容的文本表示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print(hamsters.asList())
// 输出 &amp;quot;(A hamster named Murray, A hamster named Morgan, A hamster named Maurice)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:如果有多个协议扩展,而一个协议的遵循者又同时满足它们的限制,那么将会使用所满足限制最多的那个扩展。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Swift之扩展</title>
      <link>http://lynchwong.com/2015/03/swift%E4%B9%8B%E6%89%A9%E5%B1%95/</link>
      <pubDate>Fri, 06 Mar 2015 11:43:37 +0000</pubDate>
      
      <guid>http://lynchwong.com/2015/03/swift%E4%B9%8B%E6%89%A9%E5%B1%95/</guid>
      <description>&lt;p&gt;扩展就是向一个已有的类、结构体、枚举类型或者协议类型添加新功能(functionality)。这包括在没有权限获取原始源代码的情况下扩展类型的能力(即逆向建模)。扩展和 Objective-C 中的分类(categories)类似。(不过与 Objective-C 不同的是,Swift 的扩展没有名字。)
&lt;/p&gt;

&lt;p&gt;Swift 中的扩展可以:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;添加计算型属性和计算静态属性&lt;/li&gt;
&lt;li&gt;定义实例方法和类型方法&lt;/li&gt;
&lt;li&gt;提供新的构造器&lt;/li&gt;
&lt;li&gt;定义下标&lt;/li&gt;
&lt;li&gt;定义和使用新的嵌套类型&lt;/li&gt;
&lt;li&gt;使一个已有类型符合某个协议&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 Swift 中,你甚至可以对一个协议(Procotol)进行扩展,提供协议需要的实现,或者添加额外的功能能够对合适的类型带来额外的好处。你可以从协议扩展获取更多的细节。&lt;/p&gt;

&lt;h2 id=&#34;扩展语法-extension-syntax&#34;&gt;扩展语法(Extension Syntax)&lt;/h2&gt;

&lt;p&gt;声明一个扩展使用关键字 extension :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension SomeType {
    // new functionality to add to SomeType goes here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个扩展可以扩展一个已有类型,使其能够适配一个或多个协议(protocol)。当这种情况发生时,协议的名字应该完全按照类或结构体的名字的方式进行书写:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension SomeType: SomeProtocol, AnotherProtocol {
    // implementation of protocol requirements goes here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照这种方式添加的协议遵循者(protocol conformance)被称之为在扩展中添加协议遵循者。&lt;/p&gt;

&lt;p&gt;注意:如果你定义了一个扩展向一个已有类型添加新功能,那么这个新功能对该类型的所有已有实例中都是可用的,即使它们是在你的这个扩展的前面定义的。&lt;/p&gt;

&lt;h2 id=&#34;计算型属性-computed-properties&#34;&gt;计算型属性(Computed Properties)&lt;/h2&gt;

&lt;p&gt;扩展可以向已有类型添加计算型实例属性和计算型类型属性。下面的例子向 Swift 的内建 Double 类型添加了5个计算型实例属性,从而提供与距离单位协作的基本支持:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let oneInch = 25.4.mm
println(&amp;quot;One inch is \(oneInch) meters&amp;quot;)
// prints &amp;quot;One inch is 0.0254 meters&amp;quot;
let threeFeet = 3.ft
println(&amp;quot;Three feet is \(threeFeet) meters&amp;quot;)
// prints &amp;quot;Three feet is 0.914399970739201 meters&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些计算属性表达的含义是把一个   型的值看作是某单位下的长度值。即使它们被实现为计算型属性,但这些属性仍可以接一个带有dot语法的浮点型字面值,而这恰恰是使用这些浮点型字面量实现距离转换的方式。&lt;/p&gt;

&lt;p&gt;在上述例子中,一个 Double 型的值 1.0 被用来表示“1 米”。这就是为什么 m 计算型属性返 回 self——表达式 1.m 被认为是计算 1.0 的 Double 值。&lt;/p&gt;

&lt;p&gt;其它单位则需要一些转换来表示在米下测量的值。1 千米等于 1,000 米,所以 km 计算型属 性要把值乘以 1_000.00 来转化成单位米下的数值。类似地,1 米有 3.28024 英尺,所以 ft计算型属性要把对应的 Double 值除以 3.28024 来实现英尺到米的单位换算。&lt;/p&gt;

&lt;p&gt;这些属性是只读的计算型属性,所有从简考虑它们不用 get 关键字表示。它们的返回值是 Double 型,而且可以用于所有接受 Double 的数学计算中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let aMarathon = 42.km + 195.m
println(&amp;quot;A marathon is \(aMarathon) meters long&amp;quot;)
// prints &amp;quot;A marathon is 42195.0 meters long&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:扩展可以添加新的计算属性,但是不可以添加存储属性,也不可以向已有属性添加属 性观测器(property observers)。&lt;/p&gt;

&lt;h2 id=&#34;构造器-initializers&#34;&gt;构造器(Initializers)&lt;/h2&gt;

&lt;p&gt;扩展可以向已有类型添加新的构造器。这可以让你扩展其它类型,将你自己的定制类型作为构造器参数,或者提供该类型的原始实现中没有包含的额外初始化选项。&lt;/p&gt;

&lt;p&gt;扩展能向类中添加新的便利构造器,但是它们不能向类中添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现来提供。&lt;/p&gt;

&lt;p&gt;注意: 如果你使用扩展向一个值类型添加一个构造器,在该值类型已经向所有的存储属性提供默认值,而且没有定义任何定制构造器(custom initializers)时,你可以在值类型的扩展构造器中调用默认构造器(default initializers)和逐一成员构造器(memberwise initializers)。&lt;/p&gt;

&lt;p&gt;正如在值类型的构造器代理中描述的,如果你已经把构造器写成值类型原始实现的一部分,上述规则不再适用。&lt;/p&gt;

&lt;p&gt;下面的例子定义了一个用于描述几何矩形的定制结构体 Rect 。这个例子同时定义了两个辅助结构体 Size 和 nt ,它们都把 0.0 作为所有属性的默认值:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为结构体 Rect 提供了其所有属性的默认值,所以正如默认构造器中描述的,它可以自动接受一个默认构造器和一个逐一成员构造器。这些构造器可以用于构造新的 Rect 实例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let defaultRect = Rect()
let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),
    size: Size(width: 5.0, height: 5.0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以提供一个额外的使用特殊中心点和大小的构造器来扩展 Rect 结构体:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Rect {
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个新的构造器首先根据提供的 center 和 size 值计算一个合适的原点。然后调用该结构体自动的逐一成员构造 器 init(origin:size:) ,该构造器将新的原点和大小存到了合适的属性中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let centerRect = Rect(center: Point(x: 4.0, y: 4.0),
    size: Size(width: 3.0, height: 3.0))
// centerRect&#39;s origin is (2.5, 2.5) and its size is (3.0, 3.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:如果你使用扩展提供了一个新的构造器,你依旧有责任保证构造过程能够让所有实例完全初始化。&lt;/p&gt;

&lt;h2 id=&#34;方法-methods&#34;&gt;方法(Methods)&lt;/h2&gt;

&lt;p&gt;扩展可以向已有类型添加新的实例方法和类型方法。下面的例子向 Int 类型添加一个名为 repetitions 的新实例方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Int {
    func repetitions(task: () -&amp;gt; ()) {
        for _ in 0..&amp;lt;self {
            task()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个 repetitions 方法使用了一个 () -&amp;gt; () 类型的单参数(single argument),表明函数没有参数而且没有返回值。&lt;/p&gt;

&lt;p&gt;定义该扩展之后,你就可以对任意整数调用 repetitions 方法,实现的功能则是多次执行某任务:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3.repetitions({
    println(&amp;quot;Hello!&amp;quot;)
})
// Hello!
// Hello!
// Hello!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用 trailing 闭包使调用更加简洁:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3.repetitions {
    println(&amp;quot;Goodbye!&amp;quot;)
}
// Goodbye!
// Goodbye!
// Goodbye!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;修改实例方法-mutating-instance-methods&#34;&gt;修改实例方法(Mutating Instance Methods)&lt;/h3&gt;

&lt;p&gt;通过扩展添加的实例方法也可以修改该实例本身。结构体和枚举类型中修改 self 或其属性的方法必须将该实例方法标注为 mutating ,正如来自原始实现的修改方法一样。&lt;/p&gt;

&lt;p&gt;下面的例子向Swift的 Int 类型添加了一个新的名为 square 的修改方法,来实现一个原始值的平方计算:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Int {
    mutating func square() {
        self = self * self
    }
}
var someInt = 3
someInt.square()
// someInt is now 9
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;下标-subscripts&#34;&gt;下标(Subscripts)&lt;/h2&gt;

&lt;p&gt;扩展可以向一个已有类型添加新下标。这个例子向Swift内建类型 Int 添加了一个整型下标。该下标 [n] 返回十进 制数字从右向左数的第n个数字。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;123456789[0] returns 9&lt;/li&gt;
&lt;li&gt;123456789[1] returns 8&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;hellip;等等&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Int {
    subscript(var digitIndex: Int) -&amp;gt; Int {
        var decimalBase = 1
        while digitIndex &amp;gt; 0 {
            decimalBase *= 10
            --digitIndex
        }
        return (self / decimalBase) % 10
    }
}
746381295[0]
// returns 5
746381295[1]
// returns 9
746381295[2]
// returns 2
746381295[8]
// returns 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果该 Int 值没有足够的位数,即下标越界,那么上述实现的下标会返回0,因为它会在数字左边自动补0:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;746381295[9]
// returns 0, as if you had requested:
0746381295[9]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;嵌套类型-nested-types&#34;&gt;嵌套类型(Nested Types)&lt;/h2&gt;

&lt;p&gt;扩展可以向已有的类、结构体和枚举添加新的嵌套类型:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Int {
    enum Kind {
        case Negative, Zero, Positive
    }
    var kind: Kind {
        switch self {
        case 0:
            return .Zero
        case let x where x &amp;gt; 0:
            return .Positive
        default:
            return .Negative
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该例子向 Int 添加了新的嵌套枚举。这个名为 Kind 的枚举表示特定整数的类型。具体来说,就是表示整数是正数,零或者负数。&lt;/p&gt;

&lt;p&gt;这个类子还向 Character 添加了一个新的计算实例属性,即 kind,用来返回合适的 Kind 枚 举成员。&lt;/p&gt;

&lt;p&gt;现在,这个嵌套枚举可以和一个 Character 值联合使用了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func printIntegerKinds(numbers: [Int]) {
    for number in numbers {
        switch number.kind {
        case .Negative:
            print(&amp;quot;-&amp;quot;, appendNewline: false)
        case .Zero:
            print(&amp;quot;0&amp;quot;, appendNewline: false)
        case .Positive:
            print(&amp;quot;+&amp;quot;, appendNewline: false)
        }
    }
    print(&amp;quot;\n&amp;quot;)
}
printIntegerKinds([3, 19, -27, 0, -6, 0, 7])
// prints &amp;quot;+ + - 0 - 0 +&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数 printIntegerKinds 的输入是一个 Int 数组值并对其字符进行迭代。在每次迭代过程中,考虑当前字符的 kind 计算属性,并打印出合适的类别描述。&lt;/p&gt;

&lt;p&gt;注意: 由于已知 number.kind 是 Int.Kind 型,所以 Int.Kind 中的所有成员值都可以使用 switch 语句里的形式简写,比如使用 . Negative 代替 Int.Kind.Negative 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Swift之嵌套类型</title>
      <link>http://lynchwong.com/2015/03/swift%E4%B9%8B%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Fri, 06 Mar 2015 11:01:18 +0000</pubDate>
      
      <guid>http://lynchwong.com/2015/03/swift%E4%B9%8B%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;p&gt;枚举类型常被用于实现特定类或结构体的功能。也能够在有多种变量类型的环境中,方便地定义通用类或结构体来使用,为了实现这种功能,Swift允许你定义嵌套类型,可以在枚举类型、类和结构体中定义支持嵌套的类型。
&lt;/p&gt;

&lt;p&gt;要在一个类型中嵌套另一个类型,将需要嵌套的类型的定义写在被嵌套类型的区域{}内,而且可以根据需要定义多级嵌套。&lt;/p&gt;

&lt;h2 id=&#34;嵌套类型实例&#34;&gt;嵌套类型实例&lt;/h2&gt;

&lt;p&gt;下面这个例子定义了一个结构体 BlackjackCard (二十一点),用来模拟 BlackjackCard 中的扑克牌点数。jackCard 结构体包含2个嵌套定义的枚举类型 Suit 和 Rank 。&lt;/p&gt;

&lt;p&gt;在 BlackjackCard 规则中, Ace 牌可以表示1或者11, Ace 牌的这一特征用一个嵌套在枚举型 Rank 的结构体 Values 来表示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct BlackjackCard {

    // nested Suit enumeration
    enum Suit: Character {
        case Spades = &amp;quot;♠&amp;quot;, Hearts = &amp;quot;♡&amp;quot;, Diamonds = &amp;quot;♢&amp;quot;, Clubs = &amp;quot;♣&amp;quot;
    }

    // nested Rank enumeration
    enum Rank: Int {
        case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten
        case Jack, Queen, King, Ace
        struct Values {
            let first: Int, second: Int?
        }
        var values: Values {
            switch self {
            case .Ace:
                return Values(first: 1, second: 11)
            case .Jack, .Queen, .King:
                return Values(first: 10, second: nil)
            default:
                return Values(first: self.rawValue, second: nil)
            }
        }
    }

    // BlackjackCard properties and methods
    let rank: Rank, suit: Suit
    var description: String {
        var output = &amp;quot;suit is \(suit.rawValue),&amp;quot;
        output += &amp;quot; value is \(rank.values.first)&amp;quot;
        if let second = rank.values.second {
            output += &amp;quot; or \(second)&amp;quot;
        }
        return output
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;枚举型的 Suit 用来描述扑克牌的四种花色,并分别用一个 Character 类型的值代表花色符号。&lt;/p&gt;

&lt;p&gt;枚举型的 Rank 用来描述扑克牌从 Ace~10,J,Q,K,13 张牌,并分别用一个 Int 类型的值表示牌的面值(这个 Int 类型的值不适用于 Ace,J,Q,K 的牌)。&lt;/p&gt;

&lt;p&gt;如上文所提到的,枚举型 Rank 在自己内部定义了一个嵌套结构体 Values。在这个结构体中,只有 Ace 有两个数值,其余牌都只有一个数值。结构体 Values 中定义的两个属性:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;first, 为 Int&lt;/li&gt;
&lt;li&gt;second, 为 Int?, 或 “optional Int”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Rank 定义了一个计算属性 values,它将会返回一个结构体 Values 的实例。这个计算属性会根据牌的面值，用适当的数值去初始化 Values 实例，并赋值给 values。对于J，Q，K，Ace会使用特殊数值，对于数字面值的牌使用Int类型的值。&lt;/p&gt;

&lt;p&gt;BlackjackCard 结构体自身有两个属性—rank 与 suit,也同样定义了一个计算属性description,description 属性使用 rank 和 suit 中的内容来构建对这张扑克牌名字和数值的描述,并用可选类型来检查是否存在第二个值,若存在,则在原有的描述中增加对第二数值的描述。&lt;/p&gt;

&lt;p&gt;因为 BlackjackCard 是一个没有自定义构造函数的结构体,在结构体的逐一成员构造器中知道结构体有默认的成员构造函数,所以你可以使用默认的 initializer 去初始化新的常量 theAceOfSpades:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades)
println(&amp;quot;theAceOfSpades: \(theAceOfSpades.description)&amp;quot;)
// prints &amp;quot;theAceOfSpades: suit is ♠, value is 1 or 11&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尽管 Rank 和 Suit 嵌套在 BlackjackCard 中,但仍可被引用,所以在初始化实例时能够通过枚举类型中的成员名称(.Ace 和 .Spades)单独引用。在上面的例子中 description 属性能正确地输出 Ace 有 1 和 11 两个值。&lt;/p&gt;

&lt;h2 id=&#34;嵌套类型的引用&#34;&gt;嵌套类型的引用&lt;/h2&gt;

&lt;p&gt;在外部对嵌套类型的引用,以被嵌套类型的名字为前缀,加上所要引用的属性名:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let heartsSymbol = BlackjackCard.Suit.Hearts.rawValue
// heartsSymbol is &amp;quot;♡&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于上面这个例子,这样可以使 Suit , Rank , 和 Values 的名字尽可能的短,因为它们的名字会自然的由定义它们的上下文来限定。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Swift之类型转换</title>
      <link>http://lynchwong.com/2015/03/swift%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Fri, 06 Mar 2015 10:46:22 +0000</pubDate>
      
      <guid>http://lynchwong.com/2015/03/swift%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>&lt;p&gt;类型转换可以判断实例的类型,也可以将实例看做是其父类或者子类的实例。
&lt;/p&gt;

&lt;p&gt;类型转换在 Swift 中使用 is 和 as 操作符实现。这两个操作符提供了一种简单达意的方式去检查值的类型或者转换它的类型。&lt;/p&gt;

&lt;p&gt;你也可以用它来检查一个类是否实现了某个协议,就像在 检验协议的一致性部分讲述的一样。&lt;/p&gt;

&lt;h2 id=&#34;定义一个类层次作为例子&#34;&gt;定义一个类层次作为例子&lt;/h2&gt;

&lt;p&gt;你可以将类型转换用在类和子类的层次结构上,检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。下面的三个代码段定义了一个类层次和一个包含了几个这些类实例的数组,作为类型转换的例子。&lt;/p&gt;

&lt;p&gt;第一个代码片段定义了一个新的基础类 MediaItem 。这个类为任何出现在数字媒体库的媒体项提供基础功 能。特别的,它声明了一个 String 类型的 name 属性,和一个 init name 初始化器。(假定所有的媒体项都 有个名称。)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MediaItem {
    var name: String
    init(name: String) {
        self.name = name
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下一个代码段定义了 MediaItem 的两个子类。第一个子类 Movie 封装了与电影相关的额外信息,在父类(或 者说基类)的基础上增加了一个 director (导演)属性,和相应的初始化器。第二个子类 Song ,在父类的基 础上增加了一个 artist (艺术家)属性,和相应的初始化器:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Movie: MediaItem {
    var director: String
    init(name: String, director: String) {
        self.director = director
        super.init(name: name)
    }
}

class Song: MediaItem {
    var artist: String
    init(name: String, artist: String) {
        self.artist = artist
        super.init(name: name)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一个代码段创建了一个数组常量 library ,包含两个 Movie 实例和三个 Song 实例。 library 的类型是在它被初始化时根据它数组中所包含的内容推断来的。Swift的类型检测器能够推理出 Movie 和 Song 有共同的 父类 MediaItem ,所以它推断出 [MediaItem] 类作为 library 的类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let library = [
    Movie(name: &amp;quot;Casablanca&amp;quot;, director: &amp;quot;Michael Curtiz&amp;quot;),
    Song(name: &amp;quot;Blue Suede Shoes&amp;quot;, artist: &amp;quot;Elvis Presley&amp;quot;),
    Movie(name: &amp;quot;Citizen Kane&amp;quot;, director: &amp;quot;Orson Welles&amp;quot;),
    Song(name: &amp;quot;The One And Only&amp;quot;, artist: &amp;quot;Chesney Hawkes&amp;quot;),
    Song(name: &amp;quot;Never Gonna Give You Up&amp;quot;, artist: &amp;quot;Rick Astley&amp;quot;)
]
// the type of &amp;quot;library&amp;quot; is inferred to be [MediaItem]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在幕后 library 里存储的媒体项依然是 Movie 和 Song 类型的。但是,若你迭代它,依次取出的实例会是 ediaItem 类型的,而不是 Movie 和 Song 类型。为了让它们作为原本的类型工作,你需要检查它们的类型或 者向下转换它们到其它类型,就像下面描述的一样。&lt;/p&gt;

&lt;h2 id=&#34;检查类型&#34;&gt;检查类型&lt;/h2&gt;

&lt;p&gt;用类型检查操作符( is )来检查一个实例是否属于特定子类型。若实例属于那个子类型,类型检查操作符返回 true ,否则返回 false 。&lt;/p&gt;

&lt;p&gt;下面的例子定义了两个变量, movieCount 和 songCount ,用来计算数组 library 中 Movie 和 Song 类 型的实例数量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var movieCount = 0
var songCount = 0

for item in library {
    if item is Movie {
        ++movieCount
    } else if item is Song {
        ++songCount
    }
}

println(&amp;quot;Media library contains \(movieCount) movies and \(songCount) songs&amp;quot;)
// prints &amp;quot;Media library contains 2 movies and 3 songs&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例迭代了数组 library 中的所有项。每一次, for - in 循环设置 item 为数组中的下一个 MediaItem 。&lt;/p&gt;

&lt;p&gt;若当前 MediaItem 是一个 Movie 类型的实例, item is Movie 返回 true ,相反返回 false 。同样的, ite m is Song 检查item是否为 Song 类型的实例。在循环结束后, movieCount 和 songCount 的值就是被找 到属于各自的类型的实例数量。&lt;/p&gt;

&lt;h2 id=&#34;向下转型-downcasting&#34;&gt;向下转型(Downcasting)&lt;/h2&gt;

&lt;p&gt;某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时,你可以尝试向下转到它的子类型,用类型转换操作符( as? 或 as! )。&lt;/p&gt;

&lt;p&gt;因为向下转型可能会失败,类型转型操作符带有两种不同形式。条件形式(conditional form) as? 返回一个 你试图向下转成的类型的可选值(optional value)。强制形式 as! 把试图向下转型和强制解包(force-unwr aps)结果作为一个混合动作。&lt;/p&gt;

&lt;p&gt;当你不确定向下转型可以成功时,用类型转换的条件形式( as? )。条件形式的类型转换总是返回一个可选值(op tional value),并且若下转是不可能的,可选值将是 nil 。这使你能够检查向下转型是否成功。&lt;/p&gt;

&lt;p&gt;只有你可以确定向下转型一定会成功时,才使用强制形式( as! )。当你试图向下转型为一个不正确的类型时,强 制形式的类型转换会触发一个运行时错误。&lt;/p&gt;

&lt;p&gt;下面的例子,迭代了 library 里的每一个 MediaItem ,并打印出适当的描述。要这样做, item 需要真正作为 Movie 或 Song 的类型来使用,不仅仅是作为 MediaItem 。为了能够在描述中使用 Movie 或 Song 的 director 或 artist 属性,这是必要的。&lt;/p&gt;

&lt;p&gt;在这个示例中,数组中的每一个 item 可能是 Movie 或 Song 。事前你不知道每个 item 的真实类型,所以 这里使用条件形式的类型转换( as? )去检查循环里的每次下转。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for item in library {
    if let movie = item as? Movie {
        println(&amp;quot;Movie: &#39;\(movie.name)&#39;, dir. \(movie.director)&amp;quot;)
    } else if let song = item as? Song {
        println(&amp;quot;Song: &#39;\(song.name)&#39;, by \(song.artist)&amp;quot;)
    }
}

// Movie: &#39;Casablanca&#39;, dir. Michael Curtiz
// Song: &#39;Blue Suede Shoes&#39;, by Elvis Presley
// Movie: &#39;Citizen Kane&#39;, dir. Orson Welles
// Song: &#39;The One And Only&#39;, by Chesney Hawkes
// Song: &#39;Never Gonna Give You Up&#39;, by Rick Astley
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例首先试图将 item 下转为 Movie。因为 item 是一个 MediaItem 类型的实例,它可能是一个 Movie;同样,它可能是一个 Song,或者仅仅是基类 MediaItem。因为不确定,as?形式在试图下转时将返还一个可选值。 item as? Movie 的返回值是 Movie?类型或 可选 Movie”。&lt;/p&gt;

&lt;p&gt;当向下转型为 Movie 应用在两个 Song 实例时将会失败。为了处理这种情况,上面的实例使用了可选绑定(optional binding)来检查可选 Movie 真的包含一个值(这个是为了判断下 是否成功。)可选绑定是这样写的“if let movie = item as? Movie”,可以这样解读:&lt;/p&gt;

&lt;p&gt;“尝试将 item 转为 Movie 类型。若成功,设置一个新的临时常量 movie 来存储返回的可选 Movie”&lt;/p&gt;

&lt;p&gt;若下转成功,然后 movie 的属性将用于打印一个 Movie 实例的描述,包括它的导演的名字 director。相近的原理被用来检测 Song 实例，当 Song 被找到时则打印它的描述(包含 artist 的名字)。&lt;/p&gt;

&lt;p&gt;注意:转换没有真的改变实例或它的值。潜在的根本的实例保持不变;只是简单地把它作为它被转换成的类来使用。&lt;/p&gt;

&lt;h2 id=&#34;any-和-anyobject-的转换&#34;&gt;Any 和 AnyObject 的转换&lt;/h2&gt;

&lt;p&gt;Swift 为不确定类型提供了两种特殊类型别名:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;AnyObject 可以代表任何 class 类型的实例。&lt;/li&gt;
&lt;li&gt;Any 可以表示任何类型,除了方法类型(function types)。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意:只有当你明确的需要它的行为和功能时才使用 Any 和 AnyObject。在你的代码里使用你期望的明确的类型总是更好的。&lt;/p&gt;

&lt;h3 id=&#34;anyobject-类型&#34;&gt;AnyObject 类型&lt;/h3&gt;

&lt;p&gt;当在工作中使用 Cocoa APIs,我们一般会接收一个 [AnyObject] 类型的数组,或者说“一个任何对象类型的数组”。这是因为 Objective-C 没有明确的类型化数组。但是,你常常可以从 API 提供的信息中清晰地确定数组中对象的类型。&lt;/p&gt;

&lt;p&gt;在这些情况下,你可以使用强制形式的类型转换( as )来下转在数组中的每一项到比 AnyObject 更明确的类型,不需要可选解析(optional unwrapping)。&lt;/p&gt;

&lt;p&gt;下面的示例定义了一个 [AnyObject] 类型的数组并填入三个 Movie 类型的实例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let someObjects: [AnyObject] = [
    Movie(name: &amp;quot;2001: A Space Odyssey&amp;quot;, director: &amp;quot;Stanley Kubrick&amp;quot;),
    Movie(name: &amp;quot;Moon&amp;quot;, director: &amp;quot;Duncan Jones&amp;quot;),
    Movie(name: &amp;quot;Alien&amp;quot;, director: &amp;quot;Ridley Scott&amp;quot;)
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为知道这个数组只包含 Movie 实例,你可以直接用( as! )下转并解包到不可选的 Movie 类型:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for object in someObjects {
    let movie = object as! Movie
    println(&amp;quot;Movie: &#39;\(movie.name)&#39;, dir. \(movie.director)&amp;quot;)
}
// Movie: &#39;2001: A Space Odyssey&#39;, dir. Stanley Kubrick
// Movie: &#39;Moon&#39;, dir. Duncan Jones
// Movie: &#39;Alien&#39;, dir. Ridley Scott
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了变为一个更短的形式,下转 someObjects 数组为 [Movie] 类型来代替下转数组中每一项的方式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for movie in someObjects as! [Movie] {
    println(&amp;quot;Movie: &#39;\(movie.name)&#39;, dir. \(movie.director)&amp;quot;)
}
// Movie: &#39;2001: A Space Odyssey&#39;, dir. Stanley Kubrick
// Movie: &#39;Moon&#39;, dir. Duncan Jones
// Movie: &#39;Alien&#39;, dir. Ridley Scott
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;any类型&#34;&gt;Any类型&lt;/h3&gt;

&lt;p&gt;这里有个示例,使用 Any 类型来和混合的不同类型一起工作,包括方法类型和非 class 类型。它创建了一个 可以存储 Any 类型的数组 things 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var things = [Any]()
things.append(0)
things.append(0.0)
things.append(42)
things.append(3.14159)
things.append(&amp;quot;hello&amp;quot;)
things.append((3.0, 5.0))
things.append(Movie(name: &amp;quot;Ghostbusters&amp;quot;, director: &amp;quot;Ivan Reitman&amp;quot;))
things.append({ (name: String) -&amp;gt; String in &amp;quot;Hello, \(name)&amp;quot; })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;things 数组包含两个 Int 值,2个 Double 值,1个 String 值,一个元组 (Double, Double) ,电影“Gho stbusters”,和一个获取 String 值并返回另一个 String 值的闭包表达式。&lt;/p&gt;

&lt;p&gt;你可以在 switch 表达式的cases中使用 is 和 as 操作符来发觉只知道是 Any 或 AnyObject 的常量或变 量的类型。下面的示例迭代 things 数组中的每一项的并用 switch 语句查找每一项的类型。这几种 switch 语 句的情形绑定它们匹配的值到一个规定类型的常量,让它们的值可以被打印:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for thing in things {
    switch thing {
    case 0 as Int:
        println(&amp;quot;zero as an Int&amp;quot;)
    case 0 as Double:
        println(&amp;quot;zero as a Double&amp;quot;)
    case let someInt as Int:
        println(&amp;quot;an integer value of \(someInt)&amp;quot;)
    case let someDouble as Double where someDouble &amp;gt; 0:
        println(&amp;quot;a positive double value of \(someDouble)&amp;quot;)
    case is Double:
        println(&amp;quot;some other double value that I don&#39;t want to print&amp;quot;)
    case let someString as String:
        println(&amp;quot;a string value of \&amp;quot;\(someString)\&amp;quot;&amp;quot;)
    case let (x, y) as (Double, Double):
        println(&amp;quot;an (x, y) point at \(x), \(y)&amp;quot;)
    case let movie as Movie:
        println(&amp;quot;a movie called &#39;\(movie.name)&#39;, dir. \(movie.director)&amp;quot;)
    case let stringConverter as String -&amp;gt; String:
        println(stringConverter(&amp;quot;Michael&amp;quot;))
    default:
        println(&amp;quot;something else&amp;quot;)
    }
}

// zero as an Int
// zero as a Double
// an integer value of 42
// a positive double value of 3.14159
// a string value of &amp;quot;hello&amp;quot;
// an (x, y) point at 3.0, 5.0
// a movie called &#39;Ghostbusters&#39;, dir. Ivan Reitman
// Hello, Michael
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:在一个switch语句的case中使用强制形式的类型转换操作符(as, 而不是 as?)来检查和转换到一个明确的类 型。在 switch case 语句的内容中这种检查总是安全的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Swift之错误处理</title>
      <link>http://lynchwong.com/2015/03/swift%E4%B9%8B%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 06 Mar 2015 10:30:22 +0000</pubDate>
      
      <guid>http://lynchwong.com/2015/03/swift%E4%B9%8B%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>&lt;p&gt;错误处理是响应错误以及从错误中返回的过程。Swift提供第一类错误支持,包括在运行时抛出,捕获,传送和控制可回收错误。
&lt;/p&gt;

&lt;p&gt;一些函数和方法不能总保证能够执行所有代码或产生有用的输出。可空类型用来表示值可能为空,但是当函数执行失败的时候,可空通常可以用来确定执行失败的原因,因此代码可以正确地响应失败。在Swift中,这叫做抛出函数或者抛出方法。&lt;/p&gt;

&lt;p&gt;举个例子,考虑到一个从磁盘上的一个文件读取以及处理数据的任务,有几种情况可能会导致这个任务失败,包括指定路径的文件不存在,文件不具有可读属性,或者文件没有被编码成合适的格式。区分这些错误可以让程序解决并且修复这些错误,并且,如果可能的话,把这些错误报告给用户。&lt;/p&gt;

&lt;p&gt;注意:Swift中的错误处理涉及到错误处理样式,这会用到Cocoa中的NSError和Objective-C。更多信息请参见:Using Swift with Cocoa and Objective-C中的错误处理。&lt;/p&gt;

&lt;h2 id=&#34;错误的表示&#34;&gt;错误的表示&lt;/h2&gt;

&lt;p&gt;在Swift中,错误用符合 ErrorType 协议的值表示。Swift枚举特别适合把一系列相关的错误组合在一起,同时可以把一些相关的值和错误关联在一起。因此编译器会为实现 ErrorType 协议的Swift枚举类型自动实现相应合成。&lt;/p&gt;

&lt;p&gt;比如说,你可以这样表示操作自动贩卖机会出现的错误:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum VendingMachineError: ErrorType { 
    case InvalidSelection
    case InsufficientFunds(required: Double) 
    case OutOfStock
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这种情况下,自动贩卖机可能会因为以下原因失败: 请求的物品不存在,用 InvalidSelection 表示。 请求的物品的价格高于已投入金额,用 InsufficientFunds 表示。相关的双精度值表示还需要多少钱来完成此次交易。请求的物品已经卖完了,用 OutOfStock 表示。&lt;/p&gt;

&lt;p&gt;错误抛出通过在函数或方法声明的参数后面加上 throws 关键字,表明这个函数或方法可以抛出错误。如果指定一个返回值,可以把 throws 关键字放在返回箭头(-&amp;gt;)的前面。除非明确地指出,一个函数,方法或者就闭包不能抛出错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func canThrowErrors() throws -&amp;gt; String
func cannotThrowErrors() -&amp;gt; String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在抛出函数体的任意一个地方,可以通过 throw 语句抛出错误。在下面的例子中,如果请求的物品不存在,或者 卖完了,或者超出投入金额, vend(itemNamed:) 函数会抛出一个错误:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Item {
    var price: Double 
    var count: Int
}

var inventory = [
    &amp;quot;Candy Bar&amp;quot;: Item(price: 1.25, count: 7), 
    &amp;quot;Chips&amp;quot;: Item(price: 1.00, count: 4), 
    &amp;quot;Pretzels&amp;quot;: Item(price: 0.75, count: 11)
]
var amountDeposited = 1.00

func vend(itemNamed name: String) throws { 
    guard var item = inventory[name] else {
        throw VendingMachineError.InvalidSelection 
    }

    guard item.count &amp;gt; 0 else {
        throw VendingMachineError.OutOfStock
    }

    if amountDeposited &amp;gt;= item.price { 
        // Dispense the snack 
        amountDeposited -= item.price 
        --item.count
        inventory[name] = item 
    } else {
        let amountRequired = item.price - amountDeposited 
        throw VendingMachineError.InsufficientFunds(required: amountRequired)
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先, guard 语句用来把绑定 item 常量和 count 变量到在库存中对应的值。如果物品不在库存中,将会抛出 InvalidSelection 错误。然后,物品是否可获取有物品的剩余数量决定。如果 count 小于等于0,将会抛出 OutOfStock 错误。最后,把请求物品的价格和已经投入的金额进行比较,如果如果投入的金额大于物品的价格,将会从投入的金额从减去物品的价格,然后库存中该物品的数量减1,然后返回请求的物品。否则,将会计算还需要多少钱,然后把这个值作为 InsufficientFunds 错误的关联值。因为 throw 语句会马上改变程序流程,当所有的购买条件(物品存在,库存足够以及投入金额足够)都满足的时候,物品才会出售。&lt;/p&gt;

&lt;p&gt;当调用一个抛出函数的时候,在调用前面加上 try 。这个关键字表明函数可以抛出错误,而且在 try 后面代码将不会执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let favoriteSnacks = [ 
    &amp;quot;Alice&amp;quot;: &amp;quot;Chips&amp;quot;, 
    &amp;quot;Bob&amp;quot;: &amp;quot;Licorice&amp;quot;, 
    &amp;quot;Eve&amp;quot;: &amp;quot;Pretzels&amp;quot;,
]

func buyFavoriteSnack(person: String) throws {
    let snackName = favoriteSnacks[person] ?? &amp;quot;Candy Bar&amp;quot;
    try vend(itemNamed: snackName) 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;buyFavoriteSnack(_:) 函数查找某个人的最喜欢的零食,然后尝试买给他。如果这个人在列表中没有喜欢的零食,就会购买 Candy Bar 。这个函数会调用 vend 函数, vend 函数可能会抛出错误,所以在 vend 前面加上 了 try 关键字。因为 buyFavoriteSnack 函数也是一个抛出函数,所以 vend 函数抛出的任何错误都会向上传递到 buyFavoriteSnack 被调用的地方。&lt;/p&gt;

&lt;h2 id=&#34;捕捉和处理错误&#34;&gt;捕捉和处理错误&lt;/h2&gt;

&lt;p&gt;使用 do-catch 语句来就捕获和处理错误&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do {
    try function that throws 
    statements
} catch pattern { 
    statements
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个错误被抛出了,这个错误会被传递到外部域,直到被一个 catch 分句处理。一个 catch 分句包含一个 catch 关键字,跟着一个 pattern 来匹配错误和相应的执行语句。&lt;/p&gt;

&lt;p&gt;类似 switch 语句,编译器会检查 catch 分句是否能够处理全部错误。如果能够处理所有错误情况,就认为这个错误被完全处理。否者,包含这个抛出函数的所在域就要处理这个错误,或者包含这个抛出函数的函数也用 throws 声明。为了保证错误被处理,用一个带 pattern 的 catch 分句来匹配所有错误。如果一个 catch 分句没有指定样式,这个分句会匹配并且绑定任何错误到一个本地 error 常量。更多关于 pattern 的信息,参见模式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;do {
    try vend(itemNamed: &amp;quot;Candy Bar&amp;quot;) 
    // Enjoy delicious snack
} catch VendingMachineError.InvalidSelection { 
    print(&amp;quot;Invalid Selection&amp;quot;)
} catch VendingMachineError.OutOfStock { 
    print(&amp;quot;Out of Stock.&amp;quot;)
} catch VendingMachineError.InsufficientFunds(let amountRequired) {
    print(&amp;quot;Insufficient funds. Please insert an additional $\(amountRequired).&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中, vend(itemNamed:) 函数在 try 表达式中被调用,因为这个函数会抛出错误。如果抛出了错误,程序执行流程马上转到 catch 分句,在 catch 分句中确定错误传递是否继续传送。如果没有抛出错误,将会 执行在 do 语句中剩余的语句。&lt;/p&gt;

&lt;p&gt;注意:Swift中的错误处理和其他语言中的异常处理很像,使用了 try 、 catch 和 throw 关键字。但是和这些语言——包括Objective-C——不同的是,Swift不会展开调用堆栈,那会带来很大的性能损耗。因此,在Swift中 throw 语句的性能可以做到几乎和 return 语句一样。&lt;/p&gt;

&lt;h3 id=&#34;禁止错误传播&#34;&gt;禁止错误传播&lt;/h3&gt;

&lt;p&gt;在运行时,有几种情况抛出函数事实上是不会抛出错误的。在这几种情况下,你可以用 forced-try 表达式来调用 抛出函数或方法,即使用 try! 来代替 try 。&lt;/p&gt;

&lt;p&gt;通过 try! 来调用抛出函数或方法禁止了错误传送,并且把调用包装在运行时断言,这样就不会抛出错误。如果错误真的抛出了,会触发运行时错误。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func willOnlyThrowIfTrue(value: Bool) throws { 
    if value { throw someError }
}

do {
    try willOnlyThrowIfTrue(false)
} catch {
    // Handle Error
}

try! willOnlyThrowIfTrue(false)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;指定清理操作&#34;&gt;指定清理操作&lt;/h2&gt;

&lt;p&gt;使用defer语句来在执行一系列的语句。这样不管有没有错误发生,都可以执行一些必要的收尾操作。包括关闭打开的文件描述符以及释放所有手动分配的内存。&lt;/p&gt;

&lt;p&gt;defer 语句把执行推迟到退出当前域的时候。 defer 语句包括 defer 关键字以及后面要执行的语句。被推迟的语句可能不包含任何将执行流程转移到外部的代码,比如 break 或者 return 语句,或者通过抛出一个错误。被推迟的操作的执行的顺序和他们定义的顺序相反,也就是说,在第一个 defer 语句中的代码在第二个 defer 语句中 的代码之后执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func processFile(filename: String) throws { 
    if exists(filename) {
        let file = open(filename) 
        defer {
            close(file) 
        }
        while let line = try file.readline() { 
            // Work with the file.
        }
        // close(file) is called here, at the end of the scope. 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个例子使用了 defer 语句来保证 open 有对应的 close 。这个调用不管是否有抛出都会执行。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>