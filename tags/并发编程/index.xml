<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>并发编程 on Nobodyknows&#43; 2.5</title>
    <link>http://lynchwong.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.xml</link>
    <description>Recent content in 并发编程 on Nobodyknows&#43; 2.5</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://lynchwong.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Concurrency Programming Guide - Migrating Away from Threads</title>
      <link>http://lynchwong.com/2016/01/concurrency-programming-guide---migrating-away-from-threads/</link>
      <pubDate>Thu, 14 Jan 2016 13:52:12 +0000</pubDate>
      
      <guid>http://lynchwong.com/2016/01/concurrency-programming-guide---migrating-away-from-threads/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW1&#34;&gt;官方文档&lt;/a&gt;
&lt;/p&gt;

&lt;h1 id=&#34;migrating-away-from-threads&#34;&gt;Migrating Away from Threads&lt;/h1&gt;

&lt;p&gt;(从线程迁移)&lt;/p&gt;

&lt;p&gt;将现有线程代码迁移到GCD和操作对象有很多种方法。尽管不是所有的线程代码都能够迁移，但是迁移可能提升性能，并简化你的代码。使用调度队列和操作队列来代替线程拥有许多有点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不再需要存储线程堆栈到应用程序的内存空间。&lt;/li&gt;
&lt;li&gt;消除了创建和配置线程的代码。&lt;/li&gt;
&lt;li&gt;消除了管理和调度线程工作的代码。&lt;/li&gt;
&lt;li&gt;简化了你要编写的代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本章提供了一些技巧和指引，如何使用调度队列和操作队列替换基于线程的代码，并且实现相同的行为。&lt;/p&gt;

&lt;h2 id=&#34;replacing-threads-with-dispatch-queues&#34;&gt;Replacing Threads with Dispatch Queues&lt;/h2&gt;

&lt;p&gt;(使用调度队列替换线程)&lt;/p&gt;

&lt;p&gt;首先考虑应用可能使用线程的几种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单一任务线程：创建一个线程执行一个单一的任务，当任务完成时释放线程。&lt;/li&gt;
&lt;li&gt;工作线程：创建一个或者多个工作线程执行特定的任务，定期分配任务给每个线程。&lt;/li&gt;
&lt;li&gt;创建一个通用线程池，为每一个线程设置&lt;strong&gt;run loops&lt;/strong&gt;。当你有任务要执行的时候，从线程池中抓取一个线程，并分配任务给它。如果没有空闲线程可用，将任务入队列，等待可用的线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;尽管这些看起来像是不同的技术，但实际上只是相同原理的变种。这些线程都是应用程序用来执行任务的。唯一的区别就是管理线程和任务排队的代码。使用调度队列和操作队列，你可以消除线程和线程间通信的代码，让你专注于要执行的任务。&lt;/p&gt;

&lt;p&gt;如果你使用了上面其中一种线程模型，你应该非常了解你应用程序要执行的任务类型。不再是将任务提交到一个你自定义的线程，而是封装在一个操作对象里面或者Block对象里面，然后调度到合适的队列。对于那些没有争议，不需要使用锁的任务，你可以直接使用一下方法进行迁移：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单一任务线程，将任务封装在Block或者操作对象里面，然后提交给并发队列。&lt;/li&gt;
&lt;li&gt;对于工作线程，你需要决定是使用串行的队列还是并发的队列。如果你需要工作线程将特定任务集同步的执行，使用串行队列。如果你使用工作线程执行具体的没有相互依赖的任务，使用并发队列。&lt;/li&gt;
&lt;li&gt;对于线程池，将任务封装到Block或者操作对象，调度给并发队列执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，这种简单的替换并不适合所有的情形。如果你要执行的任务会争夺共享资源，理想的解决方案就是消除或者最小化资源的争夺。如果你可以重构代码或者重新架构代码来消除共享资源的依赖，这是最完美的。如果不能这样做，或者没有效果，你仍然可以使用队列。队列的一大优势就是提供了可供预测的代码执行。这里的可预测意味着你在不使用锁或者其它重量级的锁机制的情形下仍然可以同步的执行代码。你可以使用队列来替代锁执行一下任务：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果你的任务必须按照指定顺序执行，提交到串行调度队列。如果你更喜欢使用操作队列，请使用操作对象的依赖确保按照指定的顺序执行。&lt;/li&gt;
&lt;li&gt;如果你使用锁保护共享资源，使用串行队列来执行任何会修改资源的任务。串行队列替代的同步的锁的机制。关于更多摆脱锁的信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW3&#34;&gt; Eliminating Lock-Based Code &lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;如果你使用&lt;strong&gt;thread joins&lt;/strong&gt;来等待后台任务的完成，你可以考虑使用&lt;strong&gt;dispatch groups&lt;/strong&gt;替代。你也可以使用一个&lt;strong&gt;NSBlockOperation&lt;/strong&gt;对象或者操作对象依赖来实现这些行为。更多关于如何跟踪组的任务执行，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW6&#34;&gt; Replacing Thread Joins &lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;如果你使用生产者－消费者算法来管理有限资源池，请考虑改变实现，参考&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW7&#34;&gt; Changing Producer-Consumer Implementations &lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;如果你使用线程从描述符读写数据，或者监控文件操作，使用&lt;strong&gt;dispatch sources&lt;/strong&gt;，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1&#34;&gt; Dispatch Sources &lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;记住队列不是替代线程的万能药这点很重要。异步编程模型提供的队列适合延迟无关紧要的场合。虽然队列提供配置任务执行的优先级的方法，但更高的优先级也不能确保任务一定能在特定时间得到执行。因此，线程仍然是实现最小延迟的适当选择，例如音频和视频的播放。&lt;/p&gt;

&lt;h2 id=&#34;eliminating-lock-based-code&#34;&gt;Eliminating Lock-Based Code&lt;/h2&gt;

&lt;p&gt;(消除基于锁的代码)&lt;/p&gt;

&lt;p&gt;对于线程代码，锁不同线程间同步访问共享资源的一种方式。然而，锁会带来开销。即使不考虑开销的情形下，使用锁也会由性能损失。在竞争的情形下，一个或者多个线程会为了等待锁的释放而阻塞。&lt;/p&gt;

&lt;p&gt;使用队列替代锁，消除了锁带来的开销，并且简化了现有代码。你可以创建队列来串行的访问资源，而不是使用锁来保护共享资源。队列的开销和锁不一样。比如，将任务入队列并不会到内核中去获取互斥锁。&lt;/p&gt;

&lt;p&gt;当把任务入队列时，你做的主要决定就是同步还是异步。异步提交任务使当前线程在任务执行时继续执行。同步提交任务会阻塞当前线程直到任务完成。两种机制各有用途，不过异步优于同步，尽可能的异步提交。&lt;/p&gt;

&lt;p&gt;接下来展示了如何使用基于队列的代码来等价的替换已经存在的基于锁的代码。&lt;/p&gt;

&lt;h3 id=&#34;implementing-an-asynchronous-lock&#34;&gt;Implementing an Asynchronous Lock&lt;/h3&gt;

&lt;p&gt;(实现异步锁)&lt;/p&gt;

&lt;p&gt;异步锁保护共享资源，也不会阻塞任何修改资源的代码。当你代码的部分工作需要修改一个数据结构的时候你可能会使用异步锁。使用传统的线程，你的实现：获得共享资源的锁，做必要的修改，释放锁，然后继续任务的其它部分的工作。但是，使用调度队列，调用代码可以异步修改，而不需要等待这些修改完成。&lt;/p&gt;

&lt;p&gt;Listing 5-1展示了一个异步锁的实现。在这个例子中，受保护的资源定义了自己的串行队列。调用代码提交了一个Block对象到队列，Block包含了对资源必要的修改。因为这个队列是串行执行的，这个资源的修改可以确保按顺序进行；而且任务是异步执行的，调用线程不会阻塞。&lt;/p&gt;

&lt;p&gt;Listing 5-1  Modifying protected resources asynchronously&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_async(obj-&amp;gt;serial_queue, ^{
    // Critical section
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;executing-critical-sections-synchronously&#34;&gt;Executing Critical Sections Synchronously&lt;/h3&gt;

&lt;p&gt;(同步执行临界区)&lt;/p&gt;

&lt;p&gt;如果当前的代码无法继续直到给定的任务完成，你可以使用&lt;strong&gt;dispatch_sync&lt;/strong&gt;函数同步提交任务。这个函数将任务添加到调度队列，然后阻塞当前线程，直到任务执行完成。根据你的需要这个队列可以是串行的或者并发的。因为这个函数会阻塞当前线程，所以只在需要的时候使用这个函数。Listing 5-2展示了使用&lt;strong&gt;dispatch_sync&lt;/strong&gt;实现临界区的例子。&lt;/p&gt;

&lt;p&gt;Listing 5-2  Running critical sections synchronously&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_sync(my_queue, ^{
    // Critical section
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你已经使用串行队列来保护共享资源，同步提交并不会比异步提交更好的保护资源。同步提交的唯一理由就是阻止当前代码运行直到临界区执行完成。如果你想要马上使用共享资源的一些值，你可能会同步提交。如果当前代码不需要等待临界区执行完成，或者接下来可以简单的提交额外的任务到这个相同的串行队列，通常异步提交更好。&lt;/p&gt;

&lt;h2 id=&#34;improving-on-loop-code&#34;&gt;Improving on Loop Code&lt;/h2&gt;

&lt;p&gt;(改进循环代码)&lt;/p&gt;

&lt;p&gt;如果你的代码中有循环，每次循环迭代执行的任务是相互独立的，你可以考虑使用&lt;strong&gt;dispatch_apply&lt;/strong&gt; 或者 &lt;strong&gt;dispatch_apply_f&lt;/strong&gt;函数来替换循环代码。这些函数将循环的迭代分开，然后提交给调度队列处理。当使用并发队列时，可以并发的执行循环中的多个迭代。&lt;/p&gt;

&lt;p&gt;调用&lt;strong&gt;dispatch_apply&lt;/strong&gt; 和 &lt;strong&gt;dispatch_apply_f&lt;/strong&gt;函数是同步的，会阻塞当前线程直到循环所有的迭代都完成。当提交给并发队列时，循坏迭代的顺序是不确定的。运行每个迭代的线程可能会阻塞导致一个迭代在其它迭代之前或者之后完成。因此，你用于每个循环迭代的Block对象或者函数必须是可重入的。&lt;/p&gt;

&lt;p&gt;Listing 5-3展示了如何使用GCD等价的替换&lt;strong&gt;for&lt;/strong&gt;循环。你传递给&lt;strong&gt;dispatch_apply&lt;/strong&gt; 或 &lt;strong&gt;dispatch_apply_f&lt;/strong&gt;函数的Block或者函数必须接收一个整型值的参数，用来指示当前的循环迭代。在这个例子中，简单的将循环的次数打印到控制台。&lt;/p&gt;

&lt;p&gt;Listing 5-3  Replacing a for loop without striding&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(count, queue, ^(size_t i) {
    printf(&amp;quot;%u\n&amp;quot;, i);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尽管之前的例子很简单，演示了使用调度队列替换&lt;strong&gt;for&lt;/strong&gt;循环的基本技术。虽然这是优化基于循环代码的好方法，但是你仍然需要明智的使用这项技术。虽然调度队列的开销非常小，但是在线程上调度每个循环迭代仍然是有开销的。因此，你的循环迭代必须由一定的工作量才能忽略这些开销。你应该使用性能工具找出到底需要执行多大的工作量。&lt;/p&gt;

&lt;p&gt;提升每次循环迭代的工作量的方法就是使用跨步。使用跨步时，重写原来的Block代码，执行多个循环迭代。从而减少了你指定给&lt;strong&gt;dispatch_apply&lt;/strong&gt;函数的count值。Listing 5-4展示了使用跨步实现Listing 5-3的代码。Block仍然会打印出当前迭代循环的索引，当前跨步是137。(真实的跨步值应该由你基于工作量自己配置。)因为有余值，任何剩余的迭代内联执行。&lt;/p&gt;

&lt;p&gt;Listing 5-4  Adding a stride to a dispatched for loop&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int stride = 137;
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

dispatch_apply(count / stride, queue, ^(size_t idx){
    size_t j = idx * stride;
    size_t j_stop = j + stride;
    do {
        printf(&amp;quot;%u\n&amp;quot;, (unsigned int)j++);
    }while (j &amp;lt; j_stop);
});

size_t i;
for (i = count - (count % stride); i &amp;lt; count; i++)
printf(&amp;quot;%u\n&amp;quot;, (unsigned int)i);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用跨步有明确的性能优势，特别是当循环迭代的次数很大的时候。调度少量的Block并发，意味着执行代码花的时间比调度它们的时间更多。正如任何性能指标，你应该多试几次跨步值，找到你代码最高效的那个跨步值。&lt;/p&gt;

&lt;h2 id=&#34;replacing-thread-joins&#34;&gt;Replacing Thread Joins&lt;/h2&gt;

&lt;p&gt;(替换Thread Joins)&lt;/p&gt;

&lt;p&gt;Thread Joins允许你生成一个或者多个线程，然后让当前线程等待这些线程完成。为了实现一个Thread Joins，父线程创建子线程时作为joinable的线程。如果父线程没有子线程的结果无法继续处理，就可以join子线程。会阻塞父线程直到子线程的任务完成后退出，这时候父线程可以获得子线程的结果然后继续它的工作。父线程可以一次join多个子线程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dispatch groups&lt;/strong&gt;提供了类似于Thread Joins的语义，但是拥有一些额外的优势。和Thread Joins类似，&lt;strong&gt;Dispatch groups&lt;/strong&gt;也能够阻塞一个线程直到一个或者多个子任务执行完成。但是不同于Thread Joins，&lt;strong&gt;Dispatch groups&lt;/strong&gt;同时等待所有子任务。因为&lt;strong&gt;Dispatch groups&lt;/strong&gt;使用调度队列执行任务，非常高效。&lt;/p&gt;

&lt;p&gt;使用&lt;strong&gt;Dispatch groups&lt;/strong&gt;替换Thread Joins，步骤如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用&lt;strong&gt;dispatch_group_create&lt;/strong&gt;函数创建一个新的&lt;strong&gt;dispatch group&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;dispatch_group_async&lt;/strong&gt; 和 &lt;strong&gt;dispatch_group_async_f&lt;/strong&gt;函数给组添加任务。每个提交到组的任务表示你使用joinable线程执行的普通任务。&lt;/li&gt;
&lt;li&gt;如果当前线程不能继续任何工作，调用&lt;strong&gt;dispatch_group_wait&lt;/strong&gt;函数等待组。这个函数会阻塞当前线程直到组里所有的任务执行完成。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你使用操作对象实现你的任务，你也可以使用依赖实现Thread Joins。不过这时候不是让父线程等待一个或者多个任务完成，而是将父线程的代码移到操作对象中。然后你就可以设置父的操作对象和任意数量的子操作对象之间的依赖，执行joinable线程执行的普通任务。因为父的操作对象在其它操作对象上有依赖，阻止了父操作对象在其它操作完成之前执行。&lt;/p&gt;

&lt;p&gt;关于如何使用&lt;strong&gt;dispatch groups&lt;/strong&gt;，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW25&#34;&gt; Waiting on Groups of Queued Tasks &lt;/a&gt;。关于操作对象之间设置依赖，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW17&#34;&gt; Configuring Interoperation Dependencies &lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;changing-producer-consumer-implementations&#34;&gt;Changing Producer-Consumer Implementations&lt;/h2&gt;

&lt;p&gt;(修改生产者－消费者实现)&lt;/p&gt;

&lt;p&gt;生产者－消费者模型可以让你管理有限的动态产生的资源。当生产者创建了一个新的资源，一个或者多个消费者等待并消耗这些资源。通常实现生产者－消费者的典型机制是条件或者信号量。&lt;/p&gt;

&lt;p&gt;使用条件时，生产者线程通常如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用&lt;strong&gt;pthread_mutex_lock&lt;/strong&gt;锁住与条件相关联的mutex。&lt;/li&gt;
&lt;li&gt;产生要消费的资源或者工作。&lt;/li&gt;
&lt;li&gt;使用信号提醒条件变量有资源可以消费了(使用&lt;strong&gt;pthread_cond_signal&lt;/strong&gt;)。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;pthread_mutex_unlock&lt;/strong&gt;解锁mutex。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对应的消费者线程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用&lt;strong&gt;pthread_mutex_lock&lt;/strong&gt;锁住条件相关的mutex。&lt;/li&gt;
&lt;li&gt;设置一个&lt;strong&gt;while&lt;/strong&gt;循环做如下工作：

&lt;ul&gt;
&lt;li&gt;检查是否有真的有工作在做。&lt;/li&gt;
&lt;li&gt;如果没有工作做(或者没有资源可用)，调用&lt;strong&gt;pthread_cond_wait&lt;/strong&gt;阻塞当前线程直到相应的信号触发。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;获得生产者提供的工作或资源。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;pthread_mutex_unlock&lt;/strong&gt;解锁mutex。&lt;/li&gt;
&lt;li&gt;处理工作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用调度队列，你只需要一个调用就可以实现生产者和消费者模型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_async(queue, ^{
    // Process a work item.
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你的生产者有工作要做时，只需要将工作添加到队列，并让队列去处理该工作。唯一需要确定的就是队列的类型。如果生产者生成的任务需要特定的执行顺序。你可以使用串行队列。如果生产者生成的任务并发执行，使用并发队列，然后让系统同时尽可能多的执行。&lt;/p&gt;

&lt;h2 id=&#34;replacing-semaphore-code&#34;&gt;Replacing Semaphore Code&lt;/h2&gt;

&lt;p&gt;(替换信号量代码)&lt;/p&gt;

&lt;p&gt;如果你正在使用信号量来限制共享资源的访问，你应该考虑使用调度信号量来替换。传统的信号量总是需要调用内核来测试信号量。与此相反，调度信号量在用户空间快速测试信号状态，只有测试失败的时候才会调用内核，调用线程需要阻塞。在没有竞争的情形下，调度信号量的行为比传统信号量要快的多。在其它方面，两者的行为是类似的。&lt;/p&gt;

&lt;p&gt;关于如何使用调度信号量，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW24&#34;&gt; Using Dispatch Semaphores to Regulate the Use of Finite Resources &lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;replacing-run-loop-code&#34;&gt;Replacing Run-Loop Code&lt;/h2&gt;

&lt;p&gt;(替换Run-Loop代码)&lt;/p&gt;

&lt;p&gt;如果你使用Run-Loop来管理一个或多个线程执行的工作，你会发现使用队列来实现和维护任务要简单许多。设置一个自定义的Run-Loop需要同时设置底层线程和Run-Loop本身。Run-Loop代码需要包含设置一个或者多个run-loop sources然后编写回调处理到达这些sources上的事件。你可以简单的创建一个串行队列然后调度任务给它。你可以使用一行代码来替换你所有的小城和Run-Loop创建的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_queue_t myNewRunLoop = dispatch_queue_create(&amp;quot;com.apple.MyQueue&amp;quot;, NULL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为队列自动执行添加进来的任务，不需要额外的代码来管理队列。你不需要创建或者配置一个线程，也不需要创建或者附加任何的run-loop sources。此外，你还可以通过简单的添加任务到这个队列上来执行其它类型的任务。使用Run-Loop来实现这一点，你需要修改现有的run loop source或者创建一个新的处理新的数据。&lt;/p&gt;

&lt;p&gt;Run-Loop的一个常用配置就是处理网络套接字异步到达的数据。为了替代这种行为类型的Run-Loop，你可以附加一个调度源到期望的队列上。调度源同样也提供了比传统run loop sources更多的选择来处理数据。除了处理定时器和网络端口的事件，你也可以使用调度源读写文件。监控文件系统对象，监控进程，以及信号。你甚至可以自定义调度源然后由你部分的异步代码来触发。关于设置调度源的更多信息，参见[ Dispatch Sources ]()。&lt;/p&gt;

&lt;h2 id=&#34;compatibility-with-posix-threads&#34;&gt;Compatibility with POSIX Threads&lt;/h2&gt;

&lt;p&gt;(与POSIX线程的兼容性)&lt;/p&gt;

&lt;p&gt;因为Grand Central Dispatch管理你提供的任务之间的关系以及运行任务的线程，通常你应该避免在任务代码中调用POSIX线程事务。如果由于一些原因你必须调用，你应该非常小心你调用的事务。接下来的部分给你提供了那些事务在你任务代码中调用是安全的，哪些是不安全的。这个列表是未完成的，但是应该提示你哪些调用是安全的，哪些不是。&lt;/p&gt;

&lt;p&gt;通常来说，你的应用程序不能删除或者改变不是自己创建的对象和数据结构。因此，调度队列执行的Block对象不能调用如下函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pthread_detach
pthread_cancel
pthread_join
pthread_kill
pthread_exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然在任务运行的时候修改线程的状态是可以的，你必须在任务返回之前还原线程原来的状态。只要你还原了线程原来的状态，调用如下的函数就是安全的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pthread_setcancelstate
pthread_setcanceltype
pthread_setschedparam
pthread_sigmask
pthread_setspecific
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用来执行给定Block的底层线程在多次调用间会发生改变。因此，你的应用程序不应该依赖于如下函数与调用Block之间的返回值信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pthread_self
pthread_getschedparam
pthread_get_stacksize_np
pthread_get_stackaddr_np
pthread_mach_thread_np
pthread_from_mach_thread_np
pthread_getspecific
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;重要&lt;/strong&gt;：Block必须捕获和禁止任何在其中抛出的语言级别的异常。Block执行期间的其它错误也应该由Block处理或者通知应用程序。&lt;/p&gt;

&lt;p&gt;更多关于POSIX线程的信息以及这里提到的函数，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Darwin/Reference/ManPages/man3/pthread.3.html#//apple_ref/doc/man/3/pthread&#34;&gt; pthread &lt;/a&gt;主页。&lt;/p&gt;

&lt;p&gt;================= 结束 =================&lt;/p&gt;

&lt;p&gt;到这里就结束了，官方文档最后一章是名词解释，这里就不翻译了。&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW2&#34;&gt; Glossary &lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Concurrency Programming Guide - Dispatch Sources</title>
      <link>http://lynchwong.com/2016/01/concurrency-programming-guide---dispatch-sources/</link>
      <pubDate>Thu, 14 Jan 2016 13:51:58 +0000</pubDate>
      
      <guid>http://lynchwong.com/2016/01/concurrency-programming-guide---dispatch-sources/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1&#34;&gt;官方文档&lt;/a&gt;
&lt;/p&gt;

&lt;h1 id=&#34;dispatch-sources&#34;&gt;Dispatch Sources&lt;/h1&gt;

&lt;p&gt;(调度源)&lt;/p&gt;

&lt;p&gt;每当你与底层系统交互，你必须为这项任务准备足够长的时间。调用内核或者其它系统层级与你自己的处理比起来代价更昂贵。因此，许多系统库都提供了异步接口允许你的代码提交请求到系统，在请求处理的时候继续执行其它的工作。Grand Central Dispatch构建在允许你提交请求并通过Block和调度队列将结果返回给你的代码的这一通用行为上。&lt;/p&gt;

&lt;h2 id=&#34;about-dispatch-sources&#34;&gt;About Dispatch Sources&lt;/h2&gt;

&lt;p&gt;(关于调度源)&lt;/p&gt;

&lt;p&gt;一个调度源是一种基础的数据类型，用来协调处理特定的低等级的系统事件。Grand Central Dispatch支持如下几种调度源：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定时器调度源，定期产生通知。&lt;/li&gt;
&lt;li&gt;信号调度源，当&lt;strong&gt;UNIX&lt;/strong&gt;信号到达时会通知你。&lt;/li&gt;
&lt;li&gt;描述源，当文件和套接字变化时通知你，比如：

&lt;ul&gt;
&lt;li&gt;当数据可读。&lt;/li&gt;
&lt;li&gt;当数据可写。&lt;/li&gt;
&lt;li&gt;当文件系统中的文件删除、移动、或者重命名。&lt;/li&gt;
&lt;li&gt;文件源数据信息改变。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;进程调度源，通知你进程相关的事件，比如：

&lt;ul&gt;
&lt;li&gt;当进程退出。&lt;/li&gt;
&lt;li&gt;当进程发起&lt;strong&gt;fork&lt;/strong&gt;和&lt;strong&gt;exec&lt;/strong&gt;等调用。&lt;/li&gt;
&lt;li&gt;当信号传递给进程。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Mach相关的事件通知。&lt;/li&gt;
&lt;li&gt;你自定义的自己触发的自定义调度源。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;调度源替代了异步回调函数来处理系统进程相关的事件。当你配置调度源的时候，你指定想要监控的事件，以及调度队列和处理事件的代码。你可以使用Block对象或者函数来指定你的代码。当你感兴趣的事件到达时，调度源会提交你的Block或者函数到指定的队列进行执行。&lt;/p&gt;

&lt;p&gt;不像你手动提交到队列的任务，调度源为你的应用程序持续的提供事件源。一个调度源会保持与调度队列的连接知道你显式的取消。在连接的这段时间，每当对应的事件发生时，就会提交相关的任务代码到调度队列。有些事件，比如定时器事件，都以固定间隔的时间发生，但是大部分都以特定条件零星出现。出于这个原因，调度源会保留与它们关联的调度队列，防止事件在执行的时候队列被过早的释放掉了。&lt;/p&gt;

&lt;p&gt;为了防止事件在调度队列上积压，调度源实现了事件合并机制。如果一个新的事件到达时之前的事件已出列在执行，调度源会将新旧事件的数据合并。根据事件类型的不同，合并可能会替换旧事件或者更新旧事件的信息。比如，基于信号的调度源只提供了最近信号的信息，但是也会报道从上次事件处理调用后总共有多少个信号被传递了。&lt;/p&gt;

&lt;h2 id=&#34;creating-dispatch-sources&#34;&gt;Creating Dispatch Sources&lt;/h2&gt;

&lt;p&gt;(创建调度源)&lt;/p&gt;

&lt;p&gt;创建一个调度源需要同时创建事件源和调度队列本身。事件源是处理事件所需要的本地数据结构。比如，基于描述符的调度源，你需要打开描述符：基于进程的事件，你需要获得目标程序的进程ID。当你有事件源的时候，你可以使用如下步骤创建对应的调度源：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用&lt;strong&gt;dispatch_source_create&lt;/strong&gt;函数创建调度源。&lt;/li&gt;
&lt;li&gt;配置调度源：

&lt;ul&gt;
&lt;li&gt;给调度源设置一个事件处理器；参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW13&#34;&gt; Writing and Installing an Event Handler &lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;对于定时器调度源，关于设置定时器信息使用&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/func/dispatch_source_set_timer&#34;&gt; dispatch_source_set_timer &lt;/a&gt;函数；参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW2&#34;&gt; Creating a Timer &lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;给调度源赋予一个取消处理器，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW14&#34;&gt; Installing a Cancellation Handler &lt;/a&gt;(可选)。&lt;/li&gt;
&lt;li&gt;调用&lt;strong&gt;dispatch_resume&lt;/strong&gt;函数开始处理事件，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW8&#34;&gt; Suspending and Resuming Dispatch Sources &lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因为调度源在使用之前必须进行额外的配置才能被使用，&lt;strong&gt;dispatch_source_create&lt;/strong&gt;函数返回一个挂起状态的调度源。在挂起的时候，调度源会接收事件，但是不会处理它们。这时你可以安装事件处理器并执行额外的配置。&lt;/p&gt;

&lt;p&gt;接下来的部分将想你展示如何配置调度源的各方面。关于如何配置具体类型的调度源，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW22&#34;&gt; Dispatch Source Examples &lt;/a&gt;。关于创建和配置调度源的额外的函数，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/doc/uid/TP40008079&#34;&gt; Grand Central Dispatch (GCD) Reference &lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;writing-and-installing-an-event-handler&#34;&gt;Writing and Installing an Event Handler&lt;/h3&gt;

&lt;p&gt;(编写和安装一个事件处理器)&lt;/p&gt;

&lt;p&gt;为了处理调度源产生的事件，你必须定义一个处理这些事件的事件处理器。一个事件处理器是一个函数或者Block对象，使用&lt;strong&gt;dispatch_source_set_event_handler&lt;/strong&gt; 和 &lt;strong&gt;dispatch_source_set_event_handler_f&lt;/strong&gt;函数安装是调度源上。当事件到达时，调度源提交你的事件处理器到指定的队列进行处理。&lt;/p&gt;

&lt;p&gt;事件处理器的主体负责处理所有到达的事件。如果事件处理器已经在队列中并等待处理已经到达的事件，如果此时又来了一个新事件，调度源会合并这两个事件。事件处理器通常只能看到最新事件的信息，但是取决于调度源的类型，它也可能获得已经合并的事件的信息。如果事件处理器已经开始执行后，又有一个或者多个新的事件到达，调度源会保存这些事件直到当前时间处理器执行完成。在那时，它会使用新的事件将事件处理器再次提交到队列。&lt;/p&gt;

&lt;p&gt;基于函数的事件处理器有一个单一的上下文指针，包含调度源对象，没有返回值。基于Block的事件处理器没有参数也没有返回值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Block-based event handler
void (^dispatch_block_t)(void)

// Function-based event handler
void (*dispatch_function_t)(void *)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在事件处理器的内部，你可以从调度源本身获取给定事件的信息。虽然基于函数的事件处理器可以传递指针给调度源当作参数，基于Block的事件处理器必须自己捕获那些指针。一般Block定义时会自动捕获外部定义的变量。比如，如下的代码片段捕获了&lt;strong&gt;source&lt;/strong&gt;变量，定义在Block范围之外。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,
                                                  myDescriptor, 0, myQueue);
dispatch_source_set_event_handler(source, ^{
    // Get some data from the source variable, which is captured
    // from the parent context.
    size_t estimated = dispatch_source_get_data(source);

    // Continue reading the descriptor...
});
dispatch_resume(source);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Block内捕获变量通常允许更大的灵活性和动态性。当然，默认捕获的变量是只读的。尽管在一些指定的情形下，Block提供了支持修改捕获变量的功能，但是你不应该在与调度源关联的事件处理器里面这样做。调度源总是异步的执行它们的事件处理器，所以你捕获的变量的定义的范围，在事件处理器执行时已经不存在了。关于Block捕获和使用变量的更多信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502&#34;&gt; Blocks Programming Topics &lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Table 4-1列出了你可以在事件处理器代码中获取事件信息的函数。&lt;/p&gt;

&lt;p&gt;Table 4-1  Getting data from a dispatch source&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/ConcurrencyProgrammingGuideOperationQueues/1.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;dispatch_source_get_handle&lt;/strong&gt;：这个函数返回调度源管理的底层系统的数据类型；对于一个描述符的调度队列，这个函数返回一个&lt;strong&gt;int&lt;/strong&gt;类型的值，表示调度源关联的描述符；对于信号调度源，这个函数返回一个&lt;strong&gt;int&lt;/strong&gt;类型，表示最新事件的信号数量；对于进程调度源，这个函数会返回一个&lt;strong&gt;pid_t&lt;/strong&gt;数据结构，表示被监控的进程；对于一个March端口的调度源，这个函数返回一个&lt;strong&gt;mach_port_t&lt;/strong&gt;的数据结构；对于其它的调度源，这个函数的返回值是未定义的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dispatch_source_get_data&lt;/strong&gt;：这个函数返回与事件相关的所有未决数据；对于一个描述符的调度源，从文件读取数据，这个函数返回可读的字节数量；对于一个描述符的调度源，将数据写入文件，这个函数会返回一个正的整型值表示有空间可以写入；对于一个描述符的调度源，监控文件系统的活动，这个函数会返回一个常量表示发生的事件的类型。关于更多的常量，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/doc/constant_group/dispatch_source_vnode_flags_t&#34;&gt; dispatch_source_vnode_flags_t &lt;/a&gt;枚举类型；对于一个进程调度源，这个函数返一个常量指示发生的事件的类型。参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/doc/constant_group/dispatch_source_proc_flags_t&#34;&gt; dispatch_source_proc_flags_t &lt;/a&gt;枚举类型；对于Mach端口调度源，这个函数返回一个常量指示发生的事件的类型，参见&lt;strong&gt;dispatch_source_machport_flags_t&lt;/strong&gt;枚举类型；对于一个自定义的调度源，这个函数返回从现有数据创建的新数据，以及传递给&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/func/dispatch_source_merge_data&#34;&gt; dispatch_source_merge_data &lt;/a&gt;函数的新数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dispatch_source_get_mask&lt;/strong&gt;：这个函数返回我们用来创建调度源的事件标志；对于进程调度源，这个函数返回调度源接收到的事件掩码，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/doc/constant_group/dispatch_source_proc_flags_t&#34;&gt; dispatch_source_proc_flags_t &lt;/a&gt;枚举类型；对于发送权利的Mach端口调度源，这个函数返回了一个期望事件的掩码，参见&lt;strong&gt;dispatch_source_mach_send_flags_t&lt;/strong&gt;枚举类型；对于自定义的OR调度源，这个函数返回用来合并数据值的掩码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于如何为指定类型的调度源编写和安装事件处理器的一些例子，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW22&#34;&gt; Dispatch Source Examples &lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;installing-a-cancellation-handler&#34;&gt;Installing a Cancellation Handler&lt;/h3&gt;

&lt;p&gt;(安装一个取消处理器)&lt;/p&gt;

&lt;p&gt;取消处理器用来在调度源释放之前执行清理操作。对于大多数调度源类型，取消处理器是可选的，除非你对调度源绑定了自定义行为需要在释放时执行。对于描述符和Mach端口调度源必须设置取消处理器，用来关闭描述符或者Mach端口。否则会导致微妙的BUG，这些结构体系被系统其它部分或你的应用在不经意间重用。&lt;/p&gt;

&lt;p&gt;你可以在任何时候安装取消处理器，但通常我们在创建调度源的时候就会安装取消处理器。你可以使用&lt;strong&gt;dispatch_source_set_cancel_handler&lt;/strong&gt; 或者 &lt;strong&gt;dispatch_source_set_cancel_handler_f&lt;/strong&gt;函数来安装取消处理器，取决于你是否想要使用Block对象或者函数来实现。下面的例子展示了一个简单的取消处理器，关闭了一个描述符。这个&lt;strong&gt;fd&lt;/strong&gt;变量被描述符捕获。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_source_set_cancel_handler(mySource, ^{
    close(fd); // Close a file descriptor opened earlier.
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW6&#34;&gt; Reading Data from a Descriptor &lt;/a&gt;获取完整的代码事例。&lt;/p&gt;

&lt;h3 id=&#34;changing-the-target-queue&#34;&gt;Changing the Target Queue&lt;/h3&gt;

&lt;p&gt;(修改目标队列)&lt;/p&gt;

&lt;p&gt;尽管你在创建调度源时指定了事件和取消处理器运行的队列，你可以在任何时间使用&lt;strong&gt;dispatch_set_target_queue&lt;/strong&gt;函数来修改这个队列。当你需要改变调度源事件优先级的时候你可能会这样做。&lt;/p&gt;

&lt;p&gt;改变调度源的队列是一个异步操作而且调度源会竭尽所能的快速的改变。如果一个事件处理器已经在队列中并且等待处理，它会在之前的队列上执行。随后到达的所有事件的处理器都会在后面修改的队列中执行。&lt;/p&gt;

&lt;h3 id=&#34;associating-custom-data-with-a-dispatch-source&#34;&gt;Associating Custom Data with a Dispatch Source&lt;/h3&gt;

&lt;p&gt;(关联自定义数据到调度源)&lt;/p&gt;

&lt;p&gt;类似于Grand Central Dispatch中的其它数据类型，你可以使用&lt;strong&gt;dispatch_set_context&lt;/strong&gt;函数给调度源关联自定义数据。你可以使用上下文指针存储任意你事件处理器需要的数据。如果你在上下文指针存储了任何自定义的数据，你也应该安装一个取消处理器，当调度源不再需要这些数据的时候释放这些数据。&lt;/p&gt;

&lt;p&gt;如果你使用Block来处理事件处理器，你也可以捕获本地变量然后在基于Block的代码里面使用。这可能会减少你使用上下文指针来给你的调度源存储数据，但是你应该明智的使用Block捕获变量。因为调度源会在你的应用程序中长时间存在，当捕获了包含指针的变量时要特别小心。因为指针指向的数据可能随时被释放，因此你需要复制或者保留防止这种情况发生。不管你用哪种方法，你都应该提供一个取消处理器释放这些数据。&lt;/p&gt;

&lt;h3 id=&#34;memory-management-for-dispatch-sources&#34;&gt;Memory Management for Dispatch Sources&lt;/h3&gt;

&lt;p&gt;(调度源的内存管理)&lt;/p&gt;

&lt;p&gt;类似于其它的调度对象，调度源也是引用计数的数据类型。初始计数为1，可以使用&lt;strong&gt;dispatch_retain&lt;/strong&gt; 和 &lt;strong&gt;dispatch_release&lt;/strong&gt;函数来增加和减少引用计数。当引用计数为0时，系统自动释放调度源数据结构。&lt;/p&gt;

&lt;p&gt;因为调度源的使用方式，调度源的所有权可以由它自身在内部或者外部进行管理。外部所有权时，另一个对象拥有这个调度源，并负责在不需要时释放它。内部所有权时，调度源自己拥有自己，并负责在合适的时候释放自己。虽然外部所有权很常用，当你想自己创建调度源，并让它自己管理自己的行为时，可以使用内部所有权。比如，一个调度源被设计成为处理单一全局事件，你可以让它自己处理该事件然后立即退出。&lt;/p&gt;

&lt;h2 id=&#34;dispatch-source-examples&#34;&gt;Dispatch Source Examples&lt;/h2&gt;

&lt;p&gt;(调度源例子)&lt;/p&gt;

&lt;p&gt;接下来的部分展示了如何创建和配置一些常用的调度源。更多关于特定类型的调度源，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/doc/uid/TP40008079&#34;&gt; Grand Central Dispatch (GCD) Reference &lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;creating-a-timer&#34;&gt;Creating a Timer&lt;/h3&gt;

&lt;p&gt;(创建一个定时器)&lt;/p&gt;

&lt;p&gt;定时器调度源定时产生事件。你可以发起定时执行的任务。比如，游戏和其它的图形应用程序，可以使用定时器来更新屏幕或动画。你也可以设置定时器，并在固定间隔事件中检查服务器的新信息。&lt;/p&gt;

&lt;p&gt;所有的调度源定时器都是间隔定时器，一旦创建，会按你指定的间隔定期的传递事件。当你创建了定时器调度源，你必须为调度源指定一个期望的定时器事件精度，也就是&lt;strong&gt;leeway&lt;/strong&gt;值。这个值让系统能够灵活的管理电源并唤醒内核。比如，系统可以使用这个值提前或者延迟触发定时器，以及更好的与其它系统事件结合。创建自己的定时器时，你应该尽量指定一个&lt;strong&gt;leeway&lt;/strong&gt;值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：就算你指定&lt;strong&gt;leeway&lt;/strong&gt;值为0，也不要期望定时器能够按照精确的纳秒来触发事件。系统会尽可能地满足你的需求，但是无法保证完全精确的触发时间。&lt;/p&gt;

&lt;p&gt;当计算机休眠的时候，所有的定时器调度源都会挂起。当计算机唤醒的时候，这些调度源定时器也会自动唤醒。取决于定时器的配置，暂停定时器可能会影响下一次触发。如果你使用&lt;strong&gt;dispatch_time&lt;/strong&gt;函数或者&lt;strong&gt;DISPATCH_TIME_NOW&lt;/strong&gt;常量来设置你的调度源定时器，这个调度源定时器会使用默认的系统时钟来决定何时触发。但是，默认的时钟在计算机休眠的时候不会继续。相反，当你使用&lt;strong&gt;dispatch_walltime&lt;/strong&gt;函数来设置定时器调度源，定时器调度源追踪其触发时间的挂钟时间。这后一种选择通常适合触发时间间隔比较大的定时器，因为可以防止事件之间的时间出现大多的浮动。&lt;/p&gt;

&lt;p&gt;Listing 4-1展示了一个每30秒触发一次，&lt;strong&gt;leeway&lt;/strong&gt;值为1秒的例子。因为间隔相对较大，这个调度源使用&lt;strong&gt;dispatch_walltime&lt;/strong&gt;函数创建。定时器会立即触发第一次，之后的事件每30秒触发一次。&lt;strong&gt;MyPeriodicTask&lt;/strong&gt; 和 &lt;strong&gt;MyStoreTimer&lt;/strong&gt;是自定义函数，你用来重写实现定时器的行为，并将定时器存储高你应用程序的数据结构。&lt;/p&gt;

&lt;p&gt;Listing 4-1  Creating a timer dispatch source&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_source_t CreateDispatchTimer(uint64_t interval,
                                      uint64_t leeway,
                                      dispatch_queue_t queue,
                                      dispatch_block_t block)
{
    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,
                                                     0, 0, queue);
    if (timer)
    {
        dispatch_source_set_timer(timer, dispatch_walltime(NULL, 0), interval, leeway);
        dispatch_source_set_event_handler(timer, block);
        dispatch_resume(timer);
    }
    return timer;
}

void MyCreateTimer()
{
    dispatch_source_t aTimer = CreateDispatchTimer(30ull * NSEC_PER_SEC,
                                                   1ull * NSEC_PER_SEC,
                                                   dispatch_get_main_queue(),
                                                   ^{ MyPeriodicTask(); });

    // Store it somewhere for later use.
    if (aTimer)
    {
        MyStoreTimer(aTimer);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尽管创建一个定时器调度源是接收基于时间的事件的最主要的方式，当然也有其它可选的选项。如果你想在指定的一个时间间隔后执行一个Block，你可以使用&lt;strong&gt;dispatch_after&lt;/strong&gt; 和 &lt;strong&gt;dispatch_after_f&lt;/strong&gt;。这个函数的行为和&lt;strong&gt;dispatch_async&lt;/strong&gt;函数很像，除了允许你指定一个时间值(时间一到就提交Block到队列中执行)。时间值可以指定为相对或者绝对时间。&lt;/p&gt;

&lt;h3 id=&#34;reading-data-from-a-descriptor&#34;&gt;Reading Data from a Descriptor&lt;/h3&gt;

&lt;p&gt;(从描述符读取数据)&lt;/p&gt;

&lt;p&gt;为了从文件或者套接字读取数据，你必须打开文件或者套接字，然后创建一个&lt;strong&gt;DISPATCH_SOURCE_TYPE_READ&lt;/strong&gt;类型的调度源。你指定的事件处理器应该能够读取、处理文件描述符的内容。对于文件，需要读取文件数据，并为应用创建适当的数据结构；对于套接字，需要处理最新接收到的网络数据。&lt;/p&gt;

&lt;p&gt;读取数据时，你应该配置描述符使用非阻塞的操作。虽然你可以使用&lt;strong&gt;ispatch_source_get_data&lt;/strong&gt;函数查看当前有多少数据可读，这个函数返回的数值在函数调用与真实读取时会发生变化。如果底层文件被截断，或者发生了网络错误，从描述符中读取数据会阻塞当前线程，停止在事件处理器中并阻止调度队列去执行其它任务。对于一个串行队列，这可能会死锁你的队列，即使是并发队列，也会减少能够执行的任务数量。&lt;/p&gt;

&lt;p&gt;Listing 4-2展示配置一个调度源读取文件数据的例子。在这个例子中，事件处理器读取了指定文件的所有内容到缓冲区，并调用一个自定义函数(定义在你自己的代码中)来处理这些数据。(这个函数的调用者可能会使用返回的调度源来取消，当读取操作完成时。)为了确保调度队列在没有可读数据时发生不必要的阻塞，这个例子使用了&lt;strong&gt;fcntl&lt;/strong&gt;函数来配置文件描述符来执行非阻塞的操作。安装给调度源的取消处理器确保文件描述符在数据读取完成后关闭文件描述符。&lt;/p&gt;

&lt;p&gt;Listing 4-2  Reading data from a file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_source_t ProcessContentsOfFile(const char* filename)
{
    // Prepare the file for reading.
    int fd = open(filename, O_RDONLY);
    if (fd == -1)
        return NULL;
    fcntl(fd, F_SETFL, O_NONBLOCK);  // Avoid blocking the read operation

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_source_t readSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ,
                                                          fd, 0, queue);
    if (!readSource)
    {
        close(fd);
        return NULL;
    }

    // Install the event handler
    dispatch_source_set_event_handler(readSource, ^{
        size_t estimated = dispatch_source_get_data(readSource) + 1;
        // Read the data into a text buffer.
        char* buffer = (char*)malloc(estimated);
        if (buffer)
        {
            ssize_t actual = read(fd, buffer, (estimated));
            Boolean done = MyProcessFileData(buffer, actual);  // Process the data.

            // Release the buffer when done.
            free(buffer);

            // If there is no more data, cancel the source.
            if (done)
                dispatch_source_cancel(readSource);
        }
    });

    // Install the cancellation handler
    dispatch_source_set_cancel_handler(readSource, ^{close(fd);});

    // Start reading the file.
    dispatch_resume(readSource);
    return readSource;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中，自定义的函数&lt;strong&gt;MyProcessFileData&lt;/strong&gt;确定读取到足够的数据，调度源可以取消。默认情况下，一个调度源配置的是还有数据可读时，会重复调度事件处理器。如果套接字关闭或者到达文件末尾，调度源自动停止调度事件处理器。如果你自己确定不再需要调度源，也可以手动取消它。&lt;/p&gt;

&lt;h3 id=&#34;writing-data-to-a-descriptor&#34;&gt;Writing Data to a Descriptor&lt;/h3&gt;

&lt;p&gt;(向描述符写入数据)&lt;/p&gt;

&lt;p&gt;向文件和套接字写入数据的过程和读取数据的过程非常相似。为写入操作配置了描述符后，你可以创建一个&lt;strong&gt;DISPATCH_SOURCE_TYPE_WRITE&lt;/strong&gt;类型的调度源。一旦调度源创建，系统就会调用你的事件处理器，让它有机会开始向文件或者套接字写入数据。当你完成了写入数据，使用&lt;strong&gt;dispatch_source_cancel&lt;/strong&gt;函数取消调度源。&lt;/p&gt;

&lt;p&gt;写入数据时，你应该总是配置你的描述符是非阻塞操作的。尽管你可以使用&lt;strong&gt;dispatch_source_get_data&lt;/strong&gt;函数查看还有多少空间可以写入，这函数的返回值仅供参考，在函数调用与实际写入之间可能会改变。如果发生了错误，写入数据到阻塞的文件描述符会使事件处理器停止在执行中途，并且会阻止调度队列执行其它的任务。对于串行队列，这可能会死锁队列，即使是并发队列，也会减少能够执行的任务数量。&lt;/p&gt;

&lt;p&gt;Listing 4-3展示了使用调度源将数据写入文件的基本方法。在创建了新文件后，这个函数传递文件描述符给事件处理器。写入文件的数据由&lt;strong&gt;MyGetData&lt;/strong&gt;函数提供，你可以使用自己的代码替换。在写入数据到文件之后，事件处理器取消了调度源防止再次调用。调度源的拥有者负责之后释放调度源。&lt;/p&gt;

&lt;p&gt;Listing 4-3  Writing data to a file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_source_t WriteDataToFile(const char* filename)
{
    int fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC,
                  (S_IRUSR | S_IWUSR | S_ISUID | S_ISGID));
    if (fd == -1)
        return NULL;
    fcntl(fd, F_SETFL); // Block during the write.

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_source_t writeSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_WRITE,
                                                           fd, 0, queue);
    if (!writeSource)
    {
        close(fd);
        return NULL;
    }

    dispatch_source_set_event_handler(writeSource, ^{
        size_t bufferSize = MyGetDataSize();
        void* buffer = malloc(bufferSize);

        size_t actual = MyGetData(buffer, bufferSize);
        write(fd, buffer, actual);

        free(buffer);

        // Cancel and release the dispatch source when done.
        dispatch_source_cancel(writeSource);
    });

    dispatch_source_set_cancel_handler(writeSource, ^{close(fd);});
    dispatch_resume(writeSource);
    return (writeSource);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;monitoring-a-file-system-object&#34;&gt;Monitoring a File-System Object&lt;/h3&gt;

&lt;p&gt;(监控文件系统对象)&lt;/p&gt;

&lt;p&gt;如果你想监控文件系统对象的改变，你可以设置一个&lt;strong&gt;DISPATCH_SOURCE_TYPE_VNODE&lt;/strong&gt;类型的调度源。当一个文件删除、写入、重命名的时候你可以使用这个调度源接收通知。当文件指定类型的源数据改变时你也能收到提醒。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：当调度源正在处理事件时，指定给调度源的文件描述符必须保持打开状态。&lt;/p&gt;

&lt;p&gt;Listing 4-4展示了一个监控文件名字，当改变时执行了一些自定义行为的例子。(你应该提供你自己的行为，替换例子中&lt;strong&gt;MyUpdateFileName&lt;/strong&gt;函数。)因为一个文件描述符专门为调度源打开，调度源安装了取消处理器来关闭文件描述符。这个例子中的文件描述符关联了底层文件系统对象，同一个调度源可以用来检测多次文件名变化。&lt;/p&gt;

&lt;p&gt;Listing 4-4  Watching for filename changes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_source_t MonitorNameChangesToFile(const char* filename)
{
    int fd = open(filename, O_EVTONLY);
    if (fd == -1)
        return NULL;

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE,
                                                      fd, DISPATCH_VNODE_RENAME, queue);
    if (source)
    {
        // Copy the filename for later use.
        int length = strlen(filename);
        char* newString = (char*)malloc(length + 1);
        newString = strcpy(newString, filename);
        dispatch_set_context(source, newString);

        // Install the event handler to process the name change
        dispatch_source_set_event_handler(source, ^{
            const char*  oldFilename = (char*)dispatch_get_context(source);
            MyUpdateFileName(oldFilename, fd);
        });

        // Install a cancellation handler to free the descriptor
        // and the stored string.
        dispatch_source_set_cancel_handler(source, ^{
            char* fileStr = (char*)dispatch_get_context(source);
            free(fileStr);
            close(fd);
        });

        // Start processing events.
        dispatch_resume(source);
    }
    else
        close(fd);

    return source;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;monitoring-signals&#34;&gt;Monitoring Signals&lt;/h3&gt;

&lt;p&gt;(监测信号)&lt;/p&gt;

&lt;p&gt;UNIX信号允许来自应用程序域外的操作。一个应用程序可以接受许多不同类型的信号，比如不可恢复的错误(非法指令)，或重要信息的通知(比如子进程退出)。传统编程中，应用程序使用&lt;strong&gt;sigaction&lt;/strong&gt;函数安装信号处理器函数，当信号到达时尽可能快的同步处理信号。如果你只是想信号到达时得到通知，并不想实际的处理该信号，你可以使用信号调度源来异步的处理信号。&lt;/p&gt;

&lt;p&gt;信号调度源不能替代&lt;strong&gt;sigaction&lt;/strong&gt;函数安装的同步信号处理器。同步信号处理器能够捕获一个信号，并阻止它中止应用程序。而信号调度源只允许你监测信号的到达。此外，你不能使用信号调度源获取所有类型的信号。你不能使用信号调度源监测&lt;strong&gt;SIGILL&lt;/strong&gt;, &lt;strong&gt;SIGBUS&lt;/strong&gt;, 和 &lt;strong&gt;SIGSEGV&lt;/strong&gt;信号。&lt;/p&gt;

&lt;p&gt;因为信号调度源在队列上是异步执行的，它没有同步信号处理器的一些限制。比如，信号调度源的事件处理器可以调用任何函数。灵活性增大的代价是，信号到达和调度源事件处理器调用的延迟可能会增大。&lt;/p&gt;

&lt;p&gt;Listing 4-5向你展示了如何配置一个信号调度源来处理&lt;strong&gt;SIGHUP&lt;/strong&gt;信号。这个调度源事件处理器调用&lt;strong&gt;MyProcessSIGHUP&lt;/strong&gt;函数，你应该替换为你自己处理信号的代码。&lt;/p&gt;

&lt;p&gt;Listing 4-5  Installing a block to monitor signals&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void InstallSignalHandler()
{
    // Make sure the signal does not terminate the application.
    signal(SIGHUP, SIG_IGN);

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGHUP, 0, queue);

    if (source)
    {
        dispatch_source_set_event_handler(source, ^{
            MyProcessSIGHUP();
        });

        // Start processing signals
        dispatch_resume(source);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你在开发一个自定义的框架，信号调度源的一种高级用法就是可以监控任何链接的应用程序的信号。信号调度源不是其它调度源的接口或者应用程序安装的同步信号处理器。&lt;/p&gt;

&lt;p&gt;更多关于实现同步信号处理器的信息，以及信号名称，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Darwin/Reference/ManPages/man3/signal.3.html#//apple_ref/doc/man/3/signal&#34;&gt; signal &lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;monitoring-a-process&#34;&gt;Monitoring a Process&lt;/h3&gt;

&lt;p&gt;(监控进程)&lt;/p&gt;

&lt;p&gt;进程调度源可以监控特定进程的行为，并适当的响应。父进程可以使用这种调度源监控所有子进程的创建。比如，监控子进程的死亡。类似的，子进程也可以使用这种调度源监控父进程，在父进程退出时自己也退出。&lt;/p&gt;

&lt;p&gt;Listing 4-6展示了安装一个监控父进程终结的调度源的步骤。当父进程退出时，调度源设置一些内部状态的信息，告知子进程应该退出了。(你自己的应用程序应该实现*8MySetAppExitFlag**函数，设置合适终结的标识。)因为调度源是自主运行的，因此自己拥有自己，在程序关闭时会取消并释放自己。&lt;/p&gt;

&lt;p&gt;Listing 4-6  Monitoring the death of a parent process&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void MonitorParentProcess()
{
    pid_t parentPID = getppid();

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC,
                                                      parentPID, DISPATCH_PROC_EXIT, queue);
    if (source)
    {
        dispatch_source_set_event_handler(source, ^{
            MySetAppExitFlag();
            dispatch_source_cancel(source);
            dispatch_release(source);
        });
        dispatch_resume(source);
    }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;canceling-a-dispatch-source&#34;&gt;Canceling a Dispatch Source&lt;/h2&gt;

&lt;p&gt;(取消一个调度源)&lt;/p&gt;

&lt;p&gt;调度源会一直保持活动，直到你显式的使用&lt;strong&gt;dispatch_source_cancel&lt;/strong&gt;函数。取消一个调度源会停止递送新事件，并且不能撤销。因此，通常你在取消后就立即释放它，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void RemoveDispatchSource(dispatch_source_t mySource)
{
    dispatch_source_cancel(mySource);
    dispatch_release(mySource);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取消一个调度源是异步操作。调用&lt;strong&gt;dispatch_source_cancel&lt;/strong&gt;函数后不会再有新的事件被处理，但是正在被处理的事件会继续被处理完成。在处理完最后的事件之后，调度源会执行自己的取消处理器。&lt;/p&gt;

&lt;p&gt;取消处理器是你最后的机会，在那里执行内存或资源的释放工作。如果你的调度源使用了文件描述符或者mach端口，你必须提供取消处理器在取消发生的时候关闭文件描述符或者摧毁端口。其它类型的调度源并不要求取消处理器，尽管如此，你仍然应该提供一个，如果你的调度源关联了内存或者数据。比如，你的调度源上下文指针存储了数据，你就应该提供一个。更多关于取消处理器的信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW14&#34;&gt; Installing a Cancellation Handler &lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;suspending-and-resuming-dispatch-sources&#34;&gt;Suspending and Resuming Dispatch Sources&lt;/h2&gt;

&lt;p&gt;(挂起和恢复调度源)&lt;/p&gt;

&lt;p&gt;你可以使用&lt;strong&gt;dispatch_suspend&lt;/strong&gt; 和 &lt;strong&gt;dispatch_resume&lt;/strong&gt;函数临时的挂起和继续调度源的事件传递。这个函数分别增加和减少调度对象的挂起计数。因此，你必须每次&lt;strong&gt;dispatch_suspend&lt;/strong&gt;调用之后，都需要&lt;strong&gt;dispatch_resume&lt;/strong&gt;才能继续事件的传递。&lt;/p&gt;

&lt;p&gt;当调度源挂起，在挂的时发生的所有事件都会被积压直到调度源恢复。当队列恢复时，不是传递所有的事件，而是传递一个合并的单一事件。比如，如果你在监控文件名的变化，传递的事件只包括最后一次名字的改变。以这种方式合并事件，防止它们建立在队列中，当工作恢复时压倒你的应用程序。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Concurrency Programming Guide - Dispatch Queues</title>
      <link>http://lynchwong.com/2016/01/concurrency-programming-guide---dispatch-queues/</link>
      <pubDate>Thu, 14 Jan 2016 13:51:45 +0000</pubDate>
      
      <guid>http://lynchwong.com/2016/01/concurrency-programming-guide---dispatch-queues/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW1&#34;&gt;官方文档&lt;/a&gt;
&lt;/p&gt;

&lt;h1 id=&#34;dispatch-queues&#34;&gt;Dispatch Queues&lt;/h1&gt;

&lt;p&gt;(调度队列)&lt;/p&gt;

&lt;p&gt;Grand Central Dispatch (GCD)调度队列是执行任务的强大工具。调度队列允许你同步或者异步的执行任意的代码块。原先使用单独线程执行的所有的任务都可以替换为使用调度队列。调度队列的优势就在于使用简单，而且比对应的线程代码执行任务时更高效。&lt;/p&gt;

&lt;h2 id=&#34;about-dispatch-queues&#34;&gt;About Dispatch Queues&lt;/h2&gt;

&lt;p&gt;(关于调度队列)&lt;/p&gt;

&lt;p&gt;在你的应用程序中，调度队列是一种更简单的异步执行任务的方法。一个任务就是你应用程序需要执行的一些工作。比如，你可以定义一个任务来执行一些计算，创建或者修改数据结构，处理从文件读取的数据，或者任何事情。通过将对应的代码封装在函数或者一个Block对象里面来定义任务，然后添加到调度队列。&lt;/p&gt;

&lt;p&gt;调度队列是一个类似于对象的结构体，用来管理你提交的任务。所有的调度队列都是先进先出的数据结构。因此，你添加到队列的任务的开始顺序和添加的顺序是一样的。GCD自动为你提供了几种调度队列，但是你也可以根据具体的目的创建队列。Table 3-1列出了你应用程序可用的调度队列的类型以及如何使用它们。&lt;/p&gt;

&lt;p&gt;Table 3-1  Types of dispatch queues&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/ConcurrencyProgrammingGuideDispatchQueues/1.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;串行：串行队列(也称为私有调度队列)按照任务添加的顺序同一时间只执行一个任务。当前正在执行的任务运行在不同的线程上(不同任务的线程可能不同)，调度队列管理这些线程。串行队列通常用来对特定资源进行同步访问。根据需要你可以创建任意多个的串行队列，虽然每个队列本身每次只能执行一个任务，但是各个队列之间是并发执行的。如果你创建了四个串行队列，每个队列同一时间一次只能执行一个任务，但是最多可以有四个任务在并发执行，每个队列有一个任务在执行。关于如何创建串行队列的更多信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW6&#34;&gt; Creating Serial Dispatch Queues &lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;并发：并发队列(也称为全局调度队列)并发的执行一个或多个任务，但是任务开始的顺序与添加时的顺序是一样的。当前执行的任务运行在不同线程上，由调度队列管理。同时运行的任务数量是变化的，而且依赖于系统条件。在iOS5及之后，你可以指定队列的类型为&lt;strong&gt;DISPATCH_QUEUE_CONCURRENT&lt;/strong&gt;来创建并发调度队列。除此之外，已经有四个预先定义好的全局并发队列可供你应用程序使用。更多关于如何获取全局并发队列，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW5&#34;&gt; Getting the Global Concurrent Dispatch Queues &lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;主队列：主队列是全局可用的串行队列，在应用程序的主线程上执行任务。这个队列与应用程序的&lt;strong&gt;run loop&lt;/strong&gt;(如果有的话)交叉执行。由于它运行在你应用程序的主线程上，所以这个队列通常用于应用的关键同步点。尽管你不需要创建主队列，但是你需要确保你的应用程序适当回收。更多关于该队列如何管理的信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW15&#34;&gt; Performing Tasks on the Main Thread &lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当要给应用程序添加并发时，调度队列比线程有优势。最直观的优势就是简单的工作队列编程模型。使用线程，你必须编写要执行工作的代码以及线程创建和管理的代码。调度队列让你专注于要执行的工作而不用担心线程的创建和管理。相反，系统为你处理了线程的创建和管理。优势就是系统比任何单个应用程序管理线程都要更高效。系统可以基于当前可用资源和系统条件动态调控线程数量。除此之外，跟你自己创建线程比起来，系统通常能够更快的执行你的任务。&lt;/p&gt;

&lt;p&gt;虽然你认为为调度队列重写代码很困难，它往往比编写线程代码更简单。设计编写任务的关键点是要自包含且能够异步运行。(这一点对于线程和调度队列都是正确的。)但是，调度队列的优势就是更有可预测性。如果你有两个任务需要访问相同的共享资源，但是运行在不同的线程上，不管是哪个线程先修改资源，你需要使用锁来确保两个任务不会同时修改资源。使用调度队列，你可以将两个任务添加到一个串行队列中，确保任何时间都只有一个任务在修改资源。这种类型的队列基于同步比锁更高效，因为锁总是在双方有争议和无争议的情况下要求昂贵的内核开销，而调度队列主要工作在应用程序的进程空间，只在绝对必要的时候才会下行调用内核。&lt;/p&gt;

&lt;p&gt;虽然你可以正确的指出那两个任务运行在一个串行队列里面而不是并发的，你必须记住如果两个线程在同一时间使用了锁，那么线程提供的任何的并发能力就会丢失或者显著性的下降。更重要的是，线程模式需要创建两个线程，同时会占用内核和用户的内存。调度队列就不需要为它们使用的线程开销相同的内存，并且会让它们使用的线程处理繁忙状态且不会阻塞。&lt;/p&gt;

&lt;p&gt;调度队列包含如下几个其它的关键点需要记住：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;调度队列相对于其它的调度队列是并发的执行任务的。同一个调度队列中的任务被限制成为串行的。&lt;/li&gt;
&lt;li&gt;任何时候执行的任务总数量都是由系统决定的。因此，应用程序中100个队列启动100个任务并不会并发的执行所有的这些任务(除非系统有100个或者更多的内核)。&lt;/li&gt;
&lt;li&gt;系统在选择执行哪个任务时，会考虑队列的优先级。&lt;/li&gt;
&lt;li&gt;队列里的任务在添加到队列时随时都要准备好执行(如果你之前使用了Cocoa的操作对象，那么你注意到了这里的行为与操作对象不同)。&lt;/li&gt;
&lt;li&gt;私有调度队列是引用计数的对象。除了将队列保留在你的代码会增加引用计数之外，还要注意的是调度源也会依附队列，同时也会增加队列的引用计数。因此，你必须确保所有的调度源都被取消了，并且所有的&lt;strong&gt;retain&lt;/strong&gt;方法的调用和&lt;strong&gt;release&lt;/strong&gt;方法的调用是成对的。更多关于队列的保留和释放，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW11&#34;&gt; Memory Management for Dispatch Queues &lt;/a&gt;。更多关于调度源的信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW12&#34;&gt; About Dispatch Sources &lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于操纵调度队列的接口，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/doc/uid/TP40008079&#34;&gt; Grand Central Dispatch (GCD) Reference &lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;queue-related-technologies&#34;&gt;Queue-Related Technologies&lt;/h2&gt;

&lt;p&gt;(队列相关的技术)&lt;/p&gt;

&lt;p&gt;除了调度队列，Grand Central Dispatch提供几种使用队列帮助你管理代码的技术。Table 3-2列出了这些技术，并且提供了链接来获取更多的信息。&lt;/p&gt;

&lt;p&gt;Table 3-2  Technologies that use dispatch queues&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/ConcurrencyProgrammingGuideDispatchQueues/2.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dispatch groups&lt;/strong&gt;：是监控一组Block对象完成的方式。(你可以根据你的需要异步或者同步的监控你的Block。)组提供了一种有用的同步机制，你的代码可以等待其它任务的完成。更多关于使用组的信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW25&#34;&gt; Waiting on Groups of Queued Tasks &lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dispatch semaphores&lt;/strong&gt;：调度信号量类似于传统的信号量，但是通常更高效。只有当调用线程由于信号量不可用的时候它才会去调用内核。如果线程信号量可用，就不会与内核进行交互。更多关于如何使用调度信号量的例子，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW24&#34;&gt; Using Dispatch Semaphores to Regulate the Use of Finite Resources &lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dispatch sources&lt;/strong&gt;：一个调度源在特定系统事件发生时会生成通知。你可以使用调度源监控系统事件，比如处理通知、信号以及其它事件。当事件发生时，你的调度源提交任务代码到指定的调度队列上异步处理。更多关于创建和使用调度源的代码，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW12&#34;&gt; Dispatch Sources &lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;implementing-tasks-using-blocks&#34;&gt;Implementing Tasks Using Blocks&lt;/h2&gt;

&lt;p&gt;(使用Block实现任务)&lt;/p&gt;

&lt;p&gt;Block对象是基于C语言的功能，可以在C，Objective-C，C++代码中使用。Block让定义一个自包含的单元工作块变得简单。尽管它们看起来像是函数指针，块实际上由底层数据结构表示，类似于一个对象，由编译器为你创建和管理。编译器打包了你提供的代码(以及任何相关的数据)，封装为可以在堆上存在的格式，并可以在应用中各个地方传递。&lt;/p&gt;

&lt;p&gt;使用Block的另外一个关键优势就是它们能够使用自己范围之外的变量。当你在一个函数或者方法里面定义一个Block，在某些时候这个Block就像是传统的代码块一样。比如，一个Block可以读取定义在上一层级范围内的变量。Block访问的变量会被复制到堆上的Block的数据结构里面，以便Block可以在之后读取。当Block被添加到调度队列，这些值必须是只读形式的。不过同步执行的Block可以使用那些使用关键字&lt;strong&gt;__block&lt;/strong&gt;定义的变量，对这些变量的修改会影响到调用层级的范围内。&lt;/p&gt;

&lt;p&gt;你可以使用类似于函数指针的语法来声明一个内联的块。Block和函数指针的最主要区别就是Block的名字使用^号代替星号*。类似于函数指针，你可以给Block传递参数以及获取返回值。Listing 3-1向你展示了怎么在代码中声明以及同步执行Block。变量&lt;strong&gt;aBlock&lt;/strong&gt;被声明为接受一个整型值无返回值的Block。然后将一个实际与aBlock匹配的内联Block赋值给它。最后一行立即执行了Block，然后打印出结果。&lt;/p&gt;

&lt;p&gt;Listing 3-1  A simple block example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int x = 123;
int y = 456;

// Block declaration and assignment
void (^aBlock)(int) = ^(int z) {
    printf(&amp;quot;%d %d %d\n&amp;quot;, x, y, z);
};

// Execute the block
aBlock(789);   // prints: 123 456 789
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你在设计你的Block的时候，应该考虑这些总结以及关键指导：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于想要异步执行的Block请使用调度队列，可以安全的捕获使用父函数或者方法里面的变量。然而你不应该尝试去捕获大型的数据结构或者其它基于指针的变量，它们由Block的调用上下文分配和删除。在你的Block被执行时，这些指针引用的内存可能已经不存在了。当然，你自己显式的分配内存，然后让Block拥有这些内存是安全可行的。&lt;/li&gt;
&lt;li&gt;调度队列会在Block被添加进来的时候复制它们，然后执行完成之后释放。换句话说就是你不需要在添加它们之前显式的复制它们。&lt;/li&gt;
&lt;li&gt;尽管队列执行小任务比原始线程更加高效，但是创建和执行这些Block仍然有开销。如果一个Block做太少的工作，可能内联执行比队列里面执行开销更小。使用性能工具来确认Block的工作是否太少。&lt;/li&gt;
&lt;li&gt;不要在底层线程缓存数据，然后期望在不同的Block中访问这些数据。如果同一个队列里面的任务需要共享数据，使用调度队列的上下文引用来存储这些数据。关于更多如何访问调度队列上下文数据的信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW13&#34;&gt; Storing Custom Context Information with a Queue &lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;如果你的Block创建了大量的Objective-C对象，你可能需要将你Block的大部分代码包含在一个&lt;strong&gt;@autorelease&lt;/strong&gt;块中，用来管理这些对象的内存。尽管GCD调度队列有它们自己的自动释放池(autorelease pools)，但不保证在何时回首这些池。如果你的应用程序内存有限，创建你自己的自动释放池用来定期释放那些自动释放的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多关于Block的信息，以及如何声明、使用它们，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502&#34;&gt; Blocks Programming Topics &lt;/a&gt;。关于如何将Block添加到调度队列，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW20&#34;&gt; Adding Tasks to a Queue &lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;creating-and-managing-dispatch-queues&#34;&gt;Creating and Managing Dispatch Queues&lt;/h2&gt;

&lt;p&gt;(创建以及管理调度队列)&lt;/p&gt;

&lt;p&gt;在将任务添加到队列之前，你必须决定使用哪种类型的队列以及打算如何使用队列。调度队列可以串行或者并行的执行任务。如果你对队列有特别的用途，你可以配置队列的相应属性。接下来的章节向你展示了如何创建队列，以及如何配置使用队列。&lt;/p&gt;

&lt;h3 id=&#34;getting-the-global-concurrent-dispatch-queues&#34;&gt;Getting the Global Concurrent Dispatch Queues&lt;/h3&gt;

&lt;p&gt;(获得全局并发调度队列)&lt;/p&gt;

&lt;p&gt;当你有多个任务可以并行运行时并发调度队列就很有用。不过并发队列仍然是先进先出的队列；然而，一个并发队列会在之前任务完成之前就出列下一个任务并启动执行。任何时候并发队列正在执行任务的数量都是变化的，能够根据你应用程序条件的改变而动态改变。很多因素都会影响并发队列正在执行任务的数量，包括当前可用的内核数量，其它处理器已经完成的工作量，其它串行调度队列任务的优先级和数量。&lt;/p&gt;

&lt;p&gt;系统给每个应用程序都提供了四种并发调度队列。这些队列对应用程序来说是全局的，队列之间唯一不同的地方就是优先级。因为它们是全局的，你不需要显式的创建。你可以使用&lt;strong&gt;dispatch_get_global_queue&lt;/strong&gt;函数来获取，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_queue_t aQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了获取默认的并发队列，你也可以给函数传递&lt;strong&gt;DISPATCH_QUEUE_PRIORITY_HIGH&lt;/strong&gt; 和 &lt;strong&gt;DISPATCH_QUEUE_PRIORITY_LOW&lt;/strong&gt;来获取高和低优先级的队列，或者传递&lt;strong&gt;DISPATCH_QUEUE_PRIORITY_BACKGROUND&lt;/strong&gt;常量获取后台队列。如你预期的那样，高优先级的并发队列里面的任务比低优先级并发队列里面的任务先执行。相似的，默认的比低优先级的也先执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;strong&gt;dispatch_get_global_queue&lt;/strong&gt;函数的第二个参数是保留的。现在，你应该总是传递0。&lt;/p&gt;

&lt;p&gt;尽管调度队列是引用计数的对象，你不需要保留或者释放全局的并发队列。因为它们对于应用程序是全局的，对队列使用&lt;strong&gt;retain&lt;/strong&gt; 和 &lt;strong&gt;release&lt;/strong&gt;方法会被忽视。因此，你不需要强引用这些队列。每当你需要引用这些队列的时候，你只需要调用&lt;strong&gt;dispatch_get_global_queue&lt;/strong&gt;函数就行了。&lt;/p&gt;

&lt;h3 id=&#34;creating-serial-dispatch-queues&#34;&gt;Creating Serial Dispatch Queues&lt;/h3&gt;

&lt;p&gt;(创建串行的调度队列)&lt;/p&gt;

&lt;p&gt;当你想要任务按照特定顺序执行的时候串行队列很有用。串行队列同一时间只有一个任务执行，而且总是从队列的头拉取任务。你可能会使用串行队列替代锁来保护共享资源或者可变的数据结构。不像锁，一个串行队列确保任务执行的顺序是可预测的。并且只要你提交了你的任务到异步的串行队列，这个队列就永远不会死锁。&lt;/p&gt;

&lt;p&gt;不像并发队列，已经给你创建好了，你必须显示的创建管理任何你想要使用的串行队列。你可以为你的应用程序创建任意数量的串行队列但是应该避免为了同时执行大量任务而创建大量的串行队列。如果你想并发的执行大量任务，将任务提交到全局并发队列。当创建串行队列，你应该明白创建每一个队列的目的，比如保护资源或者同步应用程序的某些关键行为。&lt;/p&gt;

&lt;p&gt;Listing 3-2展示了创建一个自定义串行队列的步骤。&lt;strong&gt;dispatch_queue_create&lt;/strong&gt;函数需要两个参数：队列的名字和队列属性的集合。调试器和一些性能工具能够向你展示队列的名字帮助你追踪你的任务是如何执行的。这个队列的属性参数被保留，现在应该传递&lt;strong&gt;NULL&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Listing 3-2  Creating a new serial queue&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_queue_t queue;
queue = dispatch_queue_create(&amp;quot;com.example.MyQueue&amp;quot;, NULL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了任何你创建的自定义的队列，系统自动创建了一个绑定到你应用程序主线程的串行队列。更多关于如何获取主线程的队列，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW3&#34;&gt; Getting Common Queues at Runtime &lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;getting-common-queues-at-runtime&#34;&gt;Getting Common Queues at Runtime&lt;/h3&gt;

&lt;p&gt;(在运行时获取常用队列)&lt;/p&gt;

&lt;p&gt;Grand Central Dispatch提供了函数让你访问应用程序中几个常用的调度队列：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;strong&gt;dispatch_get_current_queue&lt;/strong&gt;函数主要用作调试或者测试当前队列的标识。在Block对象中调用这个函数会返回Block提交到队列(这个时候队列应该正在执行)。在Block对象外调用这个方法会返回你应用程序默认的并发队列。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;dispatch_get_main_queue&lt;/strong&gt;函数来获取你应用程序主线程相关的串行调度队列。调用了&lt;strong&gt;dispatch_main&lt;/strong&gt;函数或者在主线程上配置了&lt;strong&gt;run loop&lt;/strong&gt;(使用&lt;strong&gt;CFRunLoopRef&lt;/strong&gt;类型或者&lt;strong&gt;NSRunLoop&lt;/strong&gt;对象)的Cocoa应用程序和程序会自动创建这个队列。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;dispatch_get_global_queue&lt;/strong&gt;函数来获取任何共享的并发队列。更多信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW5&#34;&gt; Getting the Global Concurrent Dispatch Queues &lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;memory-management-for-dispatch-queues&#34;&gt;Memory Management for Dispatch Queues&lt;/h3&gt;

&lt;p&gt;(调度队列的内存管理)&lt;/p&gt;

&lt;p&gt;调度队列和其它的调度对象都是引用计数的数据类型。当你创建一个串行的调度队列，引用计数为1。你可以根据需要使用&lt;strong&gt;dispatch_retain&lt;/strong&gt; 和 &lt;strong&gt;dispatch_release&lt;/strong&gt;函数来增加和减少引用计数。当一个队列的引用计数为0的时候，系统就会异步的释放这个队列。&lt;/p&gt;

&lt;p&gt;保留和释放你的调度对象很重要，比如队列，当你使用队列的时候确保它们保留在内存中。和Cocoa对象的内存管理一样，通用的规则就是如果你使用一个传递给你代码的队列，你应该在使用前保留，使用完之后释放。这种基本的模式保证了队列在使用时保留在内存中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：你不需要保留或者释放任何全局调度队列，包括并发调度队列或者主调度队列。任何保留或者释放操作都会被忽视。&lt;/p&gt;

&lt;p&gt;即使你实现的是自动垃圾回收的应用程序，你仍然需要保留和释放你的调度队列和其它调度对象。Grand Central Dispatch并不支持垃圾回收的机制来回收内存。&lt;/p&gt;

&lt;h3 id=&#34;storing-custom-context-information-with-a-queue&#34;&gt;Storing Custom Context Information with a Queue&lt;/h3&gt;

&lt;p&gt;(在队列中存储自定义的上下文信息)&lt;/p&gt;

&lt;p&gt;所有的调度对象(包括调度队列)允许你关联自定义的上下文数据。你可以使用&lt;strong&gt;dispatch_set_context&lt;/strong&gt; 和 &lt;strong&gt;dispatch_get_context&lt;/strong&gt;函数为给定的对象设置和获取数据。系统不会使用你的自定义数据，所以由你决定何时分配和销毁这些数据。&lt;/p&gt;

&lt;p&gt;对于队列，你可以使用上下文数据来存储一个Objective-C对象的指针或者其它能够帮助标识这个队列或者代码用途的数据结构。你也可以使用队列的&lt;strong&gt;finalizer&lt;/strong&gt;函数在队列释放前来销毁关联数据。Listing 3-3展示了一个如何使用&lt;strong&gt;finalizer&lt;/strong&gt;函数清除队列上下文数据的例子。&lt;/p&gt;

&lt;h3 id=&#34;providing-a-clean-up-function-for-a-queue&#34;&gt;Providing a Clean Up Function For a Queue&lt;/h3&gt;

&lt;p&gt;(为队列提供一个清理函数)&lt;/p&gt;

&lt;p&gt;在你创建了串行调度队列之后，你可以附加一个&lt;strong&gt;finalizer&lt;/strong&gt;函数来执行任何自定义的清理操作在队列被释放时。调度队列是引用计数的对象，你可以使用&lt;strong&gt;dispatch_set_finalizer_f&lt;/strong&gt;函数来指定一个函数来执行清理操作，当队列的引用计数为0时。你可以使用这个函数来清理队列相关的上下文数据，这个函数只在上下文指针不为&lt;strong&gt;NULL&lt;/strong&gt;的时候才会调用。&lt;/p&gt;

&lt;p&gt;Listing 3-3展示了一个自定义的&lt;strong&gt;finalizer&lt;/strong&gt;函数以及一个创建队列并把&lt;strong&gt;finalizer&lt;/strong&gt;函数附加到队列的函数。队列使用&lt;strong&gt;finalizer&lt;/strong&gt;函数来释放或者存储在队列上下文指针的数据。&lt;strong&gt;myInitializeDataContextFunction&lt;/strong&gt; 和 &lt;strong&gt;myCleanUpDataContextFunction&lt;/strong&gt;函数用于初始化和清理上下文数据。传递给&lt;strong&gt;finalizer&lt;/strong&gt;函数的上下文指针包含了与队列关联的数据对象。&lt;/p&gt;

&lt;p&gt;Listing 3-3  Installing a queue clean up function&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void myFinalizerFunction(void *context)
{
    MyDataContext* theData = (MyDataContext*)context;

    // Clean up the contents of the structure
    myCleanUpDataContextFunction(theData);

    // Now release the structure itself.
    free(theData);
}

dispatch_queue_t createMyQueue()
{
    MyDataContext*  data = (MyDataContext*) malloc(sizeof(MyDataContext));
    myInitializeDataContextFunction(data);

    // Create the queue and set the context data.
    dispatch_queue_t serialQueue = dispatch_queue_create(&amp;quot;com.example.CriticalTaskQueue&amp;quot;, NULL);
    if (serialQueue)
    {
        dispatch_set_context(serialQueue, data);
        dispatch_set_finalizer_f(serialQueue, &amp;amp;myFinalizerFunction);
    }

    return serialQueue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;adding-tasks-to-a-queue&#34;&gt;Adding Tasks to a Queue&lt;/h2&gt;

&lt;p&gt;(添加任务到队列)&lt;/p&gt;

&lt;p&gt;为了执行任务，你必须将任务调度到合适的调度队列。你可以同步或者异步的调度任务，你也可以单个或者组的调度。一旦进入到队列，队列会尽可能快的执行你的任务。接下来的章节会向你展示调度任务到队列的一些技术以及优势。&lt;/p&gt;

&lt;h3 id=&#34;adding-a-single-task-to-a-queue&#34;&gt;Adding a Single Task to a Queue&lt;/h3&gt;

&lt;p&gt;(添加单个任务到队列)&lt;/p&gt;

&lt;p&gt;有两种方法可以将一个任务添加到队列：异步或者同步。如果可能，尽可能的使用&lt;strong&gt;dispatch_async&lt;/strong&gt; 和 &lt;strong&gt;dispatch_async_f&lt;/strong&gt;函数来执行任务。当你添加一个Block对象或者函数到队列时，没有办法知道这些代码何时会执行。因此，异步的添加Block或者函数可以让你调用执行的代码，然后让调用线程继续做其它的工作。特别是应用程序主线程应该异步调度任务，这样才能及时相应用户的事件。&lt;/p&gt;

&lt;p&gt;尽管你应该尽可能的异步添加任务，少数时候你可能希望同步添加任务来避免竞争条件和其它的用不错误。在这些情况下，你可以使用&lt;strong&gt;dispatch_sync&lt;/strong&gt; 和 &lt;strong&gt;dispatch_sync_f&lt;/strong&gt;函数来添加任务到队列。这些函数会阻塞当前线程的执行，直到指定的任务执行完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要&lt;/strong&gt;：你绝对不能在同一个队列中的正在执行的任务里面调用&lt;strong&gt;dispatch_sync&lt;/strong&gt; 和 &lt;strong&gt;dispatch_sync_f&lt;/strong&gt;函数。特别是串行的队列，这样做肯定会导致死锁；而并发队列也应该避免这样做。&lt;/p&gt;

&lt;p&gt;下面的例子展示了如何使用基于Block的变量来异步或者同步调度任务：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_queue_t myCustomQueue;
myCustomQueue = dispatch_queue_create(&amp;quot;com.example.MyCustomQueue&amp;quot;, NULL);

dispatch_async(myCustomQueue, ^{
    printf(&amp;quot;Do some work here.\n&amp;quot;);
});

printf(&amp;quot;The first block may or may not have run.\n&amp;quot;);

dispatch_sync(myCustomQueue, ^{
    printf(&amp;quot;Do some more work here.\n&amp;quot;);
});
printf(&amp;quot;Both blocks have completed.\n&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;performing-a-completion-block-when-a-task-is-done&#34;&gt;Performing a Completion Block When a Task Is Done&lt;/h3&gt;

&lt;p&gt;(当任务结束执行完成Block)&lt;/p&gt;

&lt;p&gt;调度到队列里面的任务与创建它们的代码是独立运行的。然而当任务完成时，你的应用程序可能希望接收通知并使用任务完成的结果数据。传统的编程中，你可能会使用回调机制，不过调度队列允许你使用完成Block。&lt;/p&gt;

&lt;p&gt;一个完成Block就是调度队列的另一段代码，位于原始任务的最后。调用代码通常在启动任务时通过参数提供完成Block。任务只需要在完成工作时提交指定的Block或函数到指定的队列。&lt;/p&gt;

&lt;p&gt;Listing 3-4展示了使用Block使用平均数函数。平均数函数的最后两个参数允许调用者指定一个队列和报告结果的Block。在平均数函数计算完值会传递结果到指定的Block然后调度到队列上。为了防止队列过早的释放，必须首先保留这个队列，然后在调度完成这个完成Block之后再释放这个队列。&lt;/p&gt;

&lt;p&gt;Listing 3-4  Executing a completion callback after a task&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void average_async(int *data, size_t len,
                   dispatch_queue_t queue, void (^block)(int))
{
    // Retain the queue provided by the user to make
    // sure it does not disappear before the completion
    // block can be called.
    dispatch_retain(queue);

    // Do the work on the default concurrent queue and then
    // call the user-provided block with the results.
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        int avg = average(data, len);
        dispatch_async(queue, ^{ block(avg);});

        // Release the user-provided queue when done
        dispatch_release(queue);
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;performing-loop-iterations-concurrently&#34;&gt;Performing Loop Iterations Concurrently&lt;/h3&gt;

&lt;p&gt;(并发执行循环迭代)&lt;/p&gt;

&lt;p&gt;一个并发调度队列能够提升性能的地方就是有一定量的循环迭代的地方。比如，假设你有一个&lt;strong&gt;for&lt;/strong&gt;循环，每次循环迭代都需要做一些工作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (i = 0; i &amp;lt; count; i++) {
    printf(&amp;quot;%u\n&amp;quot;,i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果每次迭代执行的任务与其它的迭代独立无关，而且循环迭代执行顺序也无关紧要的话，你可以使用&lt;strong&gt;dispatch_apply&lt;/strong&gt; 和 &lt;strong&gt;dispatch_apply_f&lt;/strong&gt;函数来替换循环。这两个函数为每次循环迭代提交一次指定的Block或函数到队列。当调度到并发队列时，有可能同时执行多个循环迭代。&lt;/p&gt;

&lt;p&gt;当调用&lt;strong&gt;dispatch_apply&lt;/strong&gt; 或 &lt;strong&gt;dispatch_apply_f&lt;/strong&gt;函数时你可以指定串行队列或者并发队列。传递并发队列允许你同时执行多个循环迭代，这也是这些函数最常用的方式。尽管也允许使用串行队列，也能使代码得到正确的结果，但是并没有什么性能提升。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要&lt;/strong&gt;：类似于普通&lt;strong&gt;for&lt;/strong&gt;循环，&lt;strong&gt;dispatch_apply&lt;/strong&gt; 和 &lt;strong&gt;dispatch_apply_f&lt;/strong&gt;函数也是所有循环迭代完成时才会返回。因此，在队列上下文执行的代码中调用这两个函数时必须非常小心。如果你传递的是串行队列，并且是正在执行当前代码的队列，调用这些函数会导致队列死锁。因为它们阻塞了当前线程，在主线程中调用这两个函数时同样也必须小心，它们可能会阻止事件处理的循环，无法响应用户事件。如果你循环的代码需要一定的执行时间，你可以考虑在另一个线程中调用这两个函数。&lt;/p&gt;

&lt;p&gt;Listing 3-5使用了&lt;strong&gt;dispatch_apply&lt;/strong&gt;替换了&lt;strong&gt;for&lt;/strong&gt;循环。你传递的Block必须包含一个参数，用来标识当前循环迭代。第一次迭代这个参数值为0，第二次时为1，最后一次值为count - 1。&lt;/p&gt;

&lt;p&gt;Listing 3-5  Performing the iterations of a for loop concurrently&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

dispatch_apply(count, queue, ^(size_t i) {
    printf(&amp;quot;%u\n&amp;quot;,i);
}); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你应该确保你的任务代码在每次迭代循环时都做了合理的工作量。对于任何你调度到队列的Block或者函数，执行时都会有开销。如果每次循环迭代只执行了少量的工作，调度代码的开销可能超过了从它调度到队列实现的性能优势。如果你测试的时候发现这是真的，你可以使用大步从而增加每次迭代的工作量。随着使用大步，将原始循环的多次迭代组合成一个Block，从而减少迭代的次数。比如，你需要执行100次迭代，决定使用4大步，你现在执行4个循环迭代来执行每个Block，迭代的次数是25。更多关于如何实现大步的信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW2&#34;&gt; Improving on Loop Code &lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;performing-tasks-on-the-main-thread&#34;&gt;Performing Tasks on the Main Thread&lt;/h3&gt;

&lt;p&gt;(在主线程上执行任务)&lt;/p&gt;

&lt;p&gt;Grand Central Dispatc提供了一个特殊的调度队列，让你可以在应用程序的主线程上执行任务。应用程序主线程设置了&lt;strong&gt;run loop&lt;/strong&gt;(由&lt;strong&gt;CFRunLoopRef&lt;/strong&gt;类型或者&lt;strong&gt;NSRunLoop&lt;/strong&gt;对象管理)就会自动为应用程序创建这个队列、自动drained。如果你创建的不是Cocoa应用程序并且不想显式的设置&lt;strong&gt;run loop&lt;/strong&gt;，你必须调用&lt;strong&gt;dispatch_main&lt;/strong&gt;函数来显式的drained主队列。虽然你仍然能够添加任务到队列，如果你不调用这个方法，任务就不会执行。&lt;/p&gt;

&lt;p&gt;你可以调用&lt;strong&gt;dispatch_get_main_queue&lt;/strong&gt;函数来获得应用程序主线程的调度队列。添加到这个队列里面的任务在主线程上是串行执行的。因此你可以在应用某些完成了工作的地方使用这个队列作为同步点。&lt;/p&gt;

&lt;h3 id=&#34;using-objective-c-objects-in-your-tasks&#34;&gt;Using Objective-C Objects in Your Tasks&lt;/h3&gt;

&lt;p&gt;(在任务中使用Objective-C对象)&lt;/p&gt;

&lt;p&gt;GCD为Cocoa内存管理技术提供了内建支持，所以你可以在要提交到调度队列的Block里面自由使用Objective-C对象。每个调度队列都维护了一个自己的自动释放池，确保那些自动释放的对象在某些时候被释放了；队列并不能保证何时会释放这些对象。&lt;/p&gt;

&lt;p&gt;如果你的应用程序内存有限，并且你的Block创建了大量的自动释放的对象，你应该创建自己的自动释放池，确保你的对象被及时的释放掉了。如果你的Block创建了几百个对象，你可能会创建不止一个的自动释放池，并且定期的释放。&lt;/p&gt;

&lt;p&gt;关于更多自动释放池和Objective-C的内存管理，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i&#34;&gt; Advanced Memory Management Programming Guide &lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;suspending-and-resuming-queues&#34;&gt;Suspending and Resuming Queues&lt;/h2&gt;

&lt;p&gt;(挂起和恢复队列)&lt;/p&gt;

&lt;p&gt;通过将队列挂起可以阻止它暂时执行Block对象。使用&lt;strong&gt;dispatch_suspend&lt;/strong&gt;函数挂起队列，使用&lt;strong&gt;dispatch_resume&lt;/strong&gt;函数来恢复队列。调用前者函数会增加队列的挂起引用计数，调用后者会减少队列的挂起引用计数。当这个计数大于0的时候，队列就会持续挂起。因此，你必须在调用这两个函数的时候要平衡，成对出现，能够让队列恢复继续处理Block。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要&lt;/strong&gt;：挂起或者恢复函数的调用是异步的，只在执行的Block之间有效。挂起一个队列不会停止已经开始执行的任务。&lt;/p&gt;

&lt;h2 id=&#34;using-dispatch-semaphores-to-regulate-the-use-of-finite-resources&#34;&gt;Using Dispatch Semaphores to Regulate the Use of Finite Resources&lt;/h2&gt;

&lt;p&gt;(使用调度信号来调节有限资源的使用)&lt;/p&gt;

&lt;p&gt;如果你提交到调度队列的任务需要访问一些有限的资源，你可能希望使用调度信号来调整能够同时访问资源的任务数。调度信号类似于一个调整信号，只有一点例外。当资源可用时，获取调度信号的时间与传统信号比起来更少。这是因为在这种情形下Grand Central Dispatch不会下行去调用内核。唯一需要去调用内核就是资源不可用时，系统需要暂停你的线程直到信号被提醒。&lt;/p&gt;

&lt;p&gt;使用调度信号的过程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当你使用&lt;strong&gt;dispatch_semaphore_create&lt;/strong&gt;函数创建信号时，你可以指定一个正的整型值来指示资源可用的数量。&lt;/li&gt;
&lt;li&gt;在每一个任务中，调用&lt;strong&gt;dispatch_semaphore_wait&lt;/strong&gt;函数等待信号。&lt;/li&gt;
&lt;li&gt;当上面的调用返回时，获取资源然后开始你的工作。&lt;/li&gt;
&lt;li&gt;当你使用完资源后，释放资源然后调用&lt;strong&gt;dispatch_semaphore_signal&lt;/strong&gt;函数来提醒信号。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有关这些步骤是如何工作的一个例子，考虑在系统上使用的文件描述符。每个应用程序都给了有限数量的文件描述符来使用。如果你的任务需要处理大量的文件，你不想一次打开很多文件而耗尽了文件描述符。相反，你可以使用信号来限制你任务代码在任何时候可以使用的文件描述符的数量。代码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Create the semaphore, specifying the initial pool size
dispatch_semaphore_t fd_sema = dispatch_semaphore_create(getdtablesize() / 2);

// Wait for a free file descriptor
dispatch_semaphore_wait(fd_sema, DISPATCH_TIME_FOREVER);
fd = open(&amp;quot;/etc/services&amp;quot;, O_RDONLY);

// Release the file descriptor when done
close(fd);
dispatch_semaphore_signal(fd_sema);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你创建信号的时候，你指定可用资源的数量。这个值是初始信号count变量的。每一次在信号上等待，&lt;strong&gt;dispatch_semaphore_wait&lt;/strong&gt;就会将count变量的值减1。如果这个值的结果是负的，这个函数就会告诉内核去阻塞你的线程。&lt;strong&gt;dispatch_semaphore_signal&lt;/strong&gt;函数会将count变量的值增加1指示资源已经被释放了。如果有任务阻塞等待资源，之后便不会再阻塞然后执行。&lt;/p&gt;

&lt;h2 id=&#34;waiting-on-groups-of-queued-tasks&#34;&gt;Waiting on Groups of Queued Tasks&lt;/h2&gt;

&lt;p&gt;(等待一组队列中的任务)&lt;/p&gt;

&lt;p&gt;Dispatch groups会阻塞一个线程，直到一个或者多个任务执行结束。有时候你必须等待所有指定的任务完成后才能继续处理的时候就可以使用Dispatch groups。比如，在调度了几个任务之后计算一些数据，你可能需要使用组来等待这些任务然后处理结果。另外一种方法就是Dispatch groups可以替代thread joins。不同于开始几个子线程，而是加入到每一个当中，你可以添加对应的任务到Dispatch groups当中，然后等待这个组。&lt;/p&gt;

&lt;p&gt;Listing 3-6展示了设置组的基本过程，调度任务给组，然后等待结果。不是使用&lt;strong&gt;dispatch_async&lt;/strong&gt;函数来调度任务到队列，而是使用&lt;strong&gt;dispatch_group_async&lt;/strong&gt;函数。这个函数会关联组和队列要执行的任务。为了等待组的任务完成，你调用&lt;strong&gt;dispatch_group_wait&lt;/strong&gt;函数，传递正确的组给这个函数。&lt;/p&gt;

&lt;p&gt;Listing 3-6  Waiting on asynchronous tasks&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();

// Add a task to the group
dispatch_group_async(group, queue, ^{
    // Some asynchronous work
    });

// Do some other work while the tasks execute.

// When you cannot make any more forward progress,
// wait on the group to block the current thread.
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);

// Release the group when it is no longer needed.
dispatch_release(group);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dispatch-queues-and-thread-safety&#34;&gt;Dispatch Queues and Thread Safety&lt;/h2&gt;

&lt;p&gt;(调度队列和线程安全)&lt;/p&gt;

&lt;p&gt;在调度队列上下文谈论线程安全看起来有点奇怪，但是线程安全仍然是相关的话题。你应用程序中任何时候实现的并发，以下几点你需要知道：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;调度队列本身是线程安全的。换句话说，你可以在系统的任何线程上提交任务到调度队列，而不用先加锁或者同步访问队列。&lt;/li&gt;
&lt;li&gt;不要在相同队列里面的任务代码中调用&lt;strong&gt;dispatch_sync&lt;/strong&gt;函数，传递相同的队列。这样做会导致队列死锁。如果你需要调度当前的队列，使用&lt;strong&gt;dispatch_async&lt;/strong&gt;函数异步调用。&lt;/li&gt;
&lt;li&gt;避免给提交到调度队列的任务添加锁。尽管这些任务使用锁是安全的，当你获取锁的时候，如果那个锁不可用，你增加了整个串行队列阻塞的风险。类似的，对于并发队列，等待一个锁可能会阻止其它任务的执行。如果你的代码需要同步，使用串行队列替代锁。&lt;/li&gt;
&lt;li&gt;尽管你可以在运行的任务中获取底层线程的信息，但是最好避免这样做。更多关于对比调度队列和线程的信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW18&#34;&gt; Compatibility with POSIX Threads &lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多关于如何改变已经存在线程代码来使用调度队列，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW1&#34;&gt; Migrating Away from Threads &lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Concurrency Programming Guide - Operation Queues</title>
      <link>http://lynchwong.com/2016/01/concurrency-programming-guide---operation-queues/</link>
      <pubDate>Thu, 14 Jan 2016 13:51:30 +0000</pubDate>
      
      <guid>http://lynchwong.com/2016/01/concurrency-programming-guide---operation-queues/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW1&#34;&gt;官方文档&lt;/a&gt;
&lt;/p&gt;

&lt;h1 id=&#34;operation-queues&#34;&gt;Operation Queues&lt;/h1&gt;

&lt;p&gt;(操作队列)&lt;/p&gt;

&lt;p&gt;Cocoa operations(Cocoa操作)使用了面向对象的方式封装了要异步执行的工作。操作被设计来与操作队列一起使用或是独立使用。因为它们是基于Objective-C的，操作在OS X和iOS中基于Cocoa的应用程序中是最常用的。&lt;/p&gt;

&lt;p&gt;本章将展示如何定义和使用操作。&lt;/p&gt;

&lt;h2 id=&#34;about-operation-objects&#34;&gt;About Operation Objects&lt;/h2&gt;

&lt;p&gt;(关于操作对象)&lt;/p&gt;

&lt;p&gt;一个operation object(操作对象)是&lt;strong&gt;NSOperation&lt;/strong&gt;类(在Foundation框架中)的实例，用来封装你想要应用程序执行的任务。&lt;strong&gt;NSOperation&lt;/strong&gt;类是一个抽象基类，必需子类化后才能做一些有用的工作。尽管是抽象的，这个类确实提供了一些基本的功能以减少你子类化的工作量。除此之外，Foundation框架提供了两个具体的子类可供你的代码使用。表2 - 1列出了这两个类，及一些汇总。&lt;/p&gt;

&lt;p&gt;Table 2-1  Operation classes of the Foundation framework&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/ConcurrencyProgrammingGuideOperationQueues/1.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NSInvocationOperation&lt;/strong&gt;：基于你应用程序的一个对象和selector来创建一个操作对象。如果你已经有存在的方法执行需要的任务，你可以使用这个类。因为这个类不要求子类化，所以你可以使用这个类动态的创建操作对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSBlockOperation&lt;/strong&gt;：该类可以并发的执行一个或者多个Block对象。因为可以执行一个以上的Block，所以Block操作对象使用“组”的语义；只有所有这些相关的Block执行完成之后，操作对象才算完成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSOperation&lt;/strong&gt;：用来自定义子类操作对象的基类。子类化&lt;strong&gt;NSOperation&lt;/strong&gt;让你有完全的控制权来实现你自己的操作，包括修改操作执行和状态报告的默认方式的能力。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有的操作对象都支持如下的关键特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持在操作对象之间建立依赖图。这些依赖可以阻止某个操作执行，直到它依赖的所有操作完成。&lt;/li&gt;
&lt;li&gt;支持可选的回调Block，在主要的操作任务完成之后执行。&lt;/li&gt;
&lt;li&gt;支持使用KVO通知监控操作的执行状态的改变。&lt;/li&gt;
&lt;li&gt;支持给操作设定优先级，从而影响执行顺序。&lt;/li&gt;
&lt;li&gt;支持取消语义，允许你停止正在执行的操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;操作被设计来帮助你提升你应用程序的并发层级。同时也是将你应用程序的行为封装到简单代码块的好方法。比起在主线程上执行一些代码，你可以将一个或者多个操作对象提交到队列上，然后在一个或者多个线程上异步执行这些对应的工作。&lt;/p&gt;

&lt;h2 id=&#34;concurrent-versus-non-concurrent-operations&#34;&gt;Concurrent Versus Non-concurrent Operations&lt;/h2&gt;

&lt;p&gt;(并发与非并发操作)&lt;/p&gt;

&lt;p&gt;虽然你通常是将操作添加到操作队列来执行操作，但这样做并不是必需的。你也可以手动调用操作对象的&lt;strong&gt;start&lt;/strong&gt;方法来执行操作，但是这样做并不能保证你余下代码运行的操作就会并发执行。&lt;strong&gt;NSOperation&lt;/strong&gt;类的&lt;strong&gt;isConcurrent&lt;/strong&gt;方法会告诉你这个操作相对于调用&lt;strong&gt;start&lt;/strong&gt;方法的线程，是同步还是异步执行的。&lt;strong&gt;isConcurrent&lt;/strong&gt;方法默认会返回&lt;strong&gt;NO&lt;/strong&gt;，表示在调用线程上操作是同步执行的。&lt;/p&gt;

&lt;p&gt;如果你想要实现并发操作，也就是说，调用异步运行的线程，你必需编写额外的代码来开始异步操作。比如，你可能会产生一个独立的线程，调用一个异步的系统函数，或者做一些其它的事情确保开始方法执行后这个任务会立即返回，很大的可能性是任务完成之前就返回了。&lt;/p&gt;

&lt;p&gt;大多数开发者不需要去实现并发的操作对象。如果你总是将你的操作添加到操作队列当中，你不需要去实现并发的操作。当你把一个非并发的操作提交到操作队列，这个队列会自己创建一个线程来运行你的操作。因此，添加一个非并发的操作到操作队列，仍然会异步执行你的操作对象的代码。只有你不希望使用操作队列来执行操作时，你才需要定义并发操作对象。&lt;/p&gt;

&lt;p&gt;更多关于如何创建并发操作，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW8&#34;&gt;  Configuring Operations for Concurrent Execution &lt;/a&gt; 和 &lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Reference/NSOperation_class/index.html#//apple_ref/doc/uid/TP40004591&#34;&gt; NSOperation Class Reference &lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;creating-an-nsinvocationoperation-object&#34;&gt;Creating an NSInvocationOperation Object&lt;/h2&gt;

&lt;p&gt;(创建NSInvocationOperation对象)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NSInvocationOperation&lt;/strong&gt;类是一个&lt;strong&gt;NSOperation&lt;/strong&gt;具体的子类，当运行的时候会调用你指定的对象的selector。使用这个类可以避免为每一个任务自定义操作对象；特别是你要修改的应用程序已经有执行必要任务所需的对象和方法。你也可以实现根据周围情况的改变来调用方法。比如，你可以用&lt;strong&gt;NSInvocationOperation&lt;/strong&gt;的操作对象来根据用户的输入动态的执行selector。&lt;/p&gt;

&lt;p&gt;创建&lt;strong&gt;NSInvocationOperation&lt;/strong&gt;操作对象的过程很直观。创建初始化一个新实例，将需要执行的对象的selector方法传递给初始化方法。Listing 2-1展示了在一个自定义类中掩饰创建过程。&lt;strong&gt;taskWithData:&lt;/strong&gt;方法创建了一个新的对象，然后提供给另一个方法。&lt;/p&gt;

&lt;p&gt;Listing 2-1  Creating an NSInvocationOperation object&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@implementation MyCustomClass
- (NSOperation*)taskWithData:(id)data {
    NSInvocationOperation* theOp = [[NSInvocationOperation alloc] initWithTarget:self
                                                                        selector:@selector(myTaskMethod:) object:data];

    return theOp;
}

// This is the method that does the actual work of the task.
- (void)myTaskMethod:(id)data {
    // Perform the task.
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;creating-an-nsblockoperation-object&#34;&gt;Creating an NSBlockOperation Object&lt;/h2&gt;

&lt;p&gt;(创建NSBlockOperation对象)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NSBlockOperation&lt;/strong&gt;也是&lt;strong&gt;NSOperation&lt;/strong&gt;类的子类，包装了一个或者多个Block对象。这个类为那些已经在使用操作队列但是不想使用调度队列的应用程序提供了面向对象的封装。使用&lt;strong&gt;NSBlockOperation&lt;/strong&gt;也可以使用操作依赖、KVO通知，以及其它一些调度队列不具有的功能。&lt;/p&gt;

&lt;p&gt;当你创建一个&lt;strong&gt;NSBlockOperation&lt;/strong&gt;的操作时，你通常在初始化的时候至少添加一个Block；之后需要的话也可以添加更多的Block。当要执行&lt;strong&gt;NSBlockOperation&lt;/strong&gt;对象时，会将所有的Block以默认的优先级提交到并发的调度队列。然后&lt;strong&gt;NSBlockOperation&lt;/strong&gt;对象会等待直到所有的Block执行完成。当最后一个Block执行完成，&lt;strong&gt;NSBlockOperation&lt;/strong&gt;对象标记自己执行完成。因此，你可以使用&lt;strong&gt;NSBlockOperation&lt;/strong&gt;操作对象来跟踪一组要执行的Block，就像你使用一个线程合并来自多个线程的结果。不同的就是，&lt;strong&gt;NSBlockOperation&lt;/strong&gt;对象的操作运行在分开的线程上，你的应用程序的其它线程可以继续执行它们自己的任务，而不用等待&lt;strong&gt;NSBlockOperation&lt;/strong&gt;操作对象完成。&lt;/p&gt;

&lt;p&gt;Listing 2-2展示了一个创建简单&lt;strong&gt;NSBlockOperation&lt;/strong&gt;对象的例子。这个Block对象没有参数和返回结果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSBlockOperation* theOp = [NSBlockOperation blockOperationWithBlock: ^{
    NSLog(@&amp;quot;Beginning operation.\n&amp;quot;);
    // Do some work.
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在创建了一个&lt;strong&gt;NSBlockOperation&lt;/strong&gt;操作对象后，你可以使用&lt;strong&gt;addExecutionBlock:&lt;/strong&gt;方法来添加更多的Block。如果你需要串行的执行这些Block，你必需将这些Block提交到期望的调度队列上。&lt;/p&gt;

&lt;h2 id=&#34;defining-a-custom-operation-object&#34;&gt;Defining a Custom Operation Object&lt;/h2&gt;

&lt;p&gt;(自定义操作对象)&lt;/p&gt;

&lt;p&gt;如果&lt;strong&gt;NSBlockOperation&lt;/strong&gt;和&lt;strong&gt;NSInvocationOperation&lt;/strong&gt;操作对象无法满足你应用程序的需求，那么你可以直接子类化&lt;strong&gt;NSOperation&lt;/strong&gt;然后添加你自己需要的行为。&lt;strong&gt;NSOperation&lt;/strong&gt;提供了一些通用的子类继承点。也提供了大量用来处理依赖和KVO通知的基础设施。然后，有时候你仍然需要实现已经存在的基础设施来确保你的操作行为是正确的。其它的额外工作取决于你实现的是否是并发操作。&lt;/p&gt;

&lt;p&gt;定义非并发的操作比定义并发的操作要简单的多。定义非并发的操作，所有你必需做的是执行主要的任务，并对取消事件作出响应；已经存在的基础设施会为你完成剩下的所有工作。对于一个并发操作，你必需使用你的代码替换一些已经存在的基础设施。下面的部分会为你展示如何实现这两种对象。&lt;/p&gt;

&lt;h3 id=&#34;performing-the-main-task&#34;&gt;Performing the Main Task&lt;/h3&gt;

&lt;p&gt;(执行主任务)&lt;/p&gt;

&lt;p&gt;每一个操作对象应该至少实现如下几个方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自定义的&lt;strong&gt;initialization&lt;/strong&gt;方法。&lt;/li&gt;
&lt;li&gt;自定义的&lt;strong&gt;main&lt;/strong&gt;方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你需要一个自定义的&lt;strong&gt;initialization&lt;/strong&gt;方法将你的操作对象设置为已知状态，自定义的&lt;strong&gt;main&lt;/strong&gt;方法来执行你的任务。如有必要你也可以实现额外的方法，当然，比如如下方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;main&lt;/strong&gt;方法中需要调用的其它自定义方法。&lt;/li&gt;
&lt;li&gt;设置和访问操作对象数据的访问器方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSCoding&lt;/strong&gt;协议中那些允许你归档和解档操作对象的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Listing 2-3直观展示了子类化&lt;strong&gt;NSOperation&lt;/strong&gt;的一个开始模版。(这个实例没有展示如何处理取消，但是展示了通常需要的方法。)这个类的初始化方法接收一个单一的数据对象作为参数，然后将引用存储在操作对象内。&lt;strong&gt;main&lt;/strong&gt;方法在将结果返回给应用程序之前表面上看起来在处理这个数据对象。&lt;/p&gt;

&lt;p&gt;Listing 2-3  Defining a simple operation object&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface MyNonConcurrentOperation : NSOperation
@property id (strong) myData;
-(id)initWithData:(id)data;
@end

@implementation MyNonConcurrentOperation
- (id)initWithData:(id)data {
    if (self = [super init])
        myData = data;
    return self;
}

-(void)main {
    @try {
        // Do some work on myData and report the results.
    }
    @catch(...) {
        // Do not rethrow exceptions.
    }
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于如何实现NSOperation的子类化详细例子，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/samplecode/NSOperationSample/Introduction/Intro.html#//apple_ref/doc/uid/DTS10004184&#34;&gt; NSOperationSample &lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;responding-to-cancellation-events&#34;&gt;Responding to Cancellation Events&lt;/h3&gt;

&lt;p&gt;(响应取消事件)&lt;/p&gt;

&lt;p&gt;在一个操作开始执行之后，它将会继续执行任务直到执行完成或者你代码显示的取消操作。取消可能在任何时间发生，甚至可能在操作执行之前。尽管&lt;strong&gt;NSOperation&lt;/strong&gt;类为客户提供了一种取消操作的方式，但是识别出取消事件则是你的事情。如果一个操作被直接终止，可能没有办法收回已经分配的资源。因此，操作对象应该在操作执行中检查取消事件，并且优雅的退出执行。&lt;/p&gt;

&lt;p&gt;操作对象为了支持取消，所有你需要做的就是你在自定义的代码上定期的调用&lt;strong&gt;isCancelled&lt;/strong&gt;方法，如果返回&lt;strong&gt;YES&lt;/strong&gt;就立即退出执行。支持取消是很重要的，不管是自定义的&lt;strong&gt;NSOperation&lt;/strong&gt;或者是已经存在的两个&lt;strong&gt;NSOperation&lt;/strong&gt;子类。&lt;strong&gt;isCancelled&lt;/strong&gt;方法非常轻量，可以频繁的调用而不会产生任何显著的性能损失。在设计操作对象时应该在以下代码考虑调用&lt;strong&gt;isCancelled&lt;/strong&gt;方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;执行任何实际工作之前。&lt;/li&gt;
&lt;li&gt;在循环的每次迭代过程中，如果每个迭代相对较长可能需要调用多次。&lt;/li&gt;
&lt;li&gt;代码中相对比较容易终止操作的任何地方。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Listing 2-4简单展示了在一个操作对象的&lt;strong&gt;main&lt;/strong&gt;方法中如何响应取消事件。在这种情形下，&lt;strong&gt;isCancelled&lt;/strong&gt;方法每次通过while循环时都会调用，允许在工作开始之前快速退出，并以固定的周期间隔再一次开始。&lt;/p&gt;

&lt;p&gt;Listing 2-4  Responding to a cancellation request&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)main {
    @try {
        BOOL isDone = NO;

        while (![self isCancelled] &amp;amp;&amp;amp; !isDone) {
            // Do some work and set isDone to YES when finished
        }
    }
    @catch(...) {
        // Do not rethrow exceptions.
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尽管上面的代码没有包含清理的代码，但是你自己的代码应该确保释放了所有你自定义代码分配的资源。&lt;/p&gt;

&lt;h3 id=&#34;configuring-operations-for-concurrent-execution&#34;&gt;Configuring Operations for Concurrent Execution&lt;/h3&gt;

&lt;p&gt;(为并发执行配置操作对象)&lt;/p&gt;

&lt;p&gt;操作对象默认按照同步方式执行，在调用&lt;strong&gt;start&lt;/strong&gt;方法的那个线程中执行任务。因为操作队列为非并发的操作提供了线程，多数操作仍然是异步执行的。但是如果你希望手动执行操作，而且希望能够异步操作，那你就应该采取适当的措施。通过定义操作对象为并发的操作来实现。&lt;/p&gt;

&lt;p&gt;Table 2-2列出了实现并发操作通常需要重写的方法。&lt;/p&gt;

&lt;p&gt;Table 2-2  Methods to override for concurrent operations&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://lynchwong.com/img/ConcurrencyProgrammingGuideOperationQueues/2.png&#34; alt=&#34;alt text&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;start&lt;/strong&gt;：(必须)所有的并发操作都必须重写这个方法，用自定义的实现替换掉默认的行为。通过调用&lt;strong&gt;start&lt;/strong&gt;方法来手动执行一个操作。因此，这个方法的实现就是操作开始的起点，设置线程及可执行环境来执行你的任务。你的实现在任何时候都不能调用&lt;strong&gt;super&lt;/strong&gt;的方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;main&lt;/strong&gt;：(可选)通常这个方法用来实现与操作对象相关的任务。尽管你可以在&lt;strong&gt;start&lt;/strong&gt;方法中执行你的任务，用&lt;strong&gt;main&lt;/strong&gt;方法来实现任务可以将你设置任务和实现任务的代码分开。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;isExecuting和isFinished&lt;/strong&gt;：(必须)并发操作负责设置它们的可执行环境，并且像外部的客户端报告执行环境的状态。因此，并发操作必需维护一些状态，当任务在执行或者完成时能够知道这些状态信息。必需使用这些方法报告状态信息。你实现的这些方法必需能够在其它线程中同时调用。还需要为相应的&lt;strong&gt;Key paths&lt;/strong&gt;的值的改变产生KVO通知。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;isConcurrent&lt;/strong&gt;：(必须)为了标示一个操作是并发操作，重写该方法返回&lt;strong&gt;YES&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来的部分展示了一个实现&lt;strong&gt;MyOperation&lt;/strong&gt;类的简单案例，演示了要实现并发操作时所需要的基础代码。&lt;strong&gt;MyOperation&lt;/strong&gt;在一个新的线程上简单的执行&lt;strong&gt;main&lt;/strong&gt;方法。&lt;strong&gt;main&lt;/strong&gt;方法执行的任务事实上是不相关的。这个案例的关键点是要向你演示定义并发操作时所需要提供的基础设施。&lt;/p&gt;

&lt;p&gt;Listing 2-5展示了&lt;strong&gt;MyOperation&lt;/strong&gt;类的部分接口和部分实现。&lt;strong&gt;MyOperation&lt;/strong&gt;类的&lt;strong&gt;isConcurrent&lt;/strong&gt;和&lt;strong&gt;isExecuting&lt;/strong&gt;和&lt;strong&gt;isFinished&lt;/strong&gt;方法的实现比较直观。&lt;strong&gt;isConcurrent&lt;/strong&gt;方法应该简单返回&lt;strong&gt;YES&lt;/strong&gt;来指示这个操作是并发的。&lt;strong&gt;isExecuting&lt;/strong&gt;和&lt;strong&gt;isFinished&lt;/strong&gt;方法简单的返回当前类的实例变量。&lt;/p&gt;

&lt;p&gt;Listing 2-5  Defining a concurrent operation&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface MyOperation : NSOperation {
    BOOL        executing;
    BOOL        finished;
}
- (void)completeOperation;
@end

@implementation MyOperation
- (id)init {
    self = [super init];
    if (self) {
        executing = NO;
        finished = NO;
    }
    return self;
}

- (BOOL)isConcurrent {
    return YES;
}

- (BOOL)isExecuting {
    return executing;
}

- (BOOL)isFinished {
    return finished;
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Listing 2-6展示了&lt;strong&gt;MyOperation&lt;/strong&gt;的&lt;strong&gt;start&lt;/strong&gt;方法。该方法的实现已经最小化工作量了，演示了你必须执行的任务。在这种情形下，方法简单的开启了一个新线程，然后配置它调用&lt;strong&gt;main&lt;/strong&gt;方法。同时也更新了&lt;strong&gt;executing&lt;/strong&gt;成员变量，然后为&lt;strong&gt;isExecuting&lt;/strong&gt;值的改变产生了一个KVO通知。当这些代码执行完后，该方法简单的返回了，让新的线程去执行任务。&lt;/p&gt;

&lt;p&gt;Listing 2-6  The start method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)start {
    // Always check for cancellation before launching the task.
    if ([self isCancelled])
    {
        // Must move the operation to the finished state if it is canceled.
        [self willChangeValueForKey:@&amp;quot;isFinished&amp;quot;];
        finished = YES;
        [self didChangeValueForKey:@&amp;quot;isFinished&amp;quot;];
        return;
    }

    // If the operation is not canceled, begin executing the task.
    [self willChangeValueForKey:@&amp;quot;isExecuting&amp;quot;];
    [NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil];
    executing = YES;
    [self didChangeValueForKey:@&amp;quot;isExecuting&amp;quot;];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Listing 2-7展示了实现&lt;strong&gt;MyOperation&lt;/strong&gt;类的剩余代码。从上面可知，&lt;strong&gt;main&lt;/strong&gt;方法是新线程的入口。它主要的工作是执行与操作对象相关的工作，然后在任务最终完成的时候调用自定义的&lt;strong&gt;completeOperation&lt;/strong&gt;方法。&lt;strong&gt;completeOperation&lt;/strong&gt;方法在&lt;strong&gt;isExecuting&lt;/strong&gt;和&lt;strong&gt;isFinished&lt;/strong&gt;的值改变的时候产生KVO通知。&lt;/p&gt;

&lt;p&gt;Listing 2-7  Updating an operation at completion time&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)main {
    @try {

        // Do the main work of the operation here.

        [self completeOperation];
    }
    @catch(...) {
        // Do not rethrow exceptions.
    }
}

- (void)completeOperation {
    [self willChangeValueForKey:@&amp;quot;isFinished&amp;quot;];
    [self willChangeValueForKey:@&amp;quot;isExecuting&amp;quot;];

    executing = NO;
    finished = YES;

    [self didChangeValueForKey:@&amp;quot;isExecuting&amp;quot;];
    [self didChangeValueForKey:@&amp;quot;isFinished&amp;quot;];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即使一个操作是被取消的，你也应该始终通知KVO的观察者你的操作现在已经完成了。当一个操作对象是依赖于其它完成之后的操作对象，它会监听这些操作对象的&lt;strong&gt;isFinished&lt;/strong&gt;的key path。只有当所有的对象都报告完成时，依赖的那个操作才会收到准备执行的信号。在你的应用程序中未能产生一个完成的通知会阻止依赖的操作对象执行。&lt;/p&gt;

&lt;h3 id=&#34;maintaining-kvo-compliance&#34;&gt;Maintaining KVO Compliance&lt;/h3&gt;

&lt;p&gt;(维护KVO)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NSOperation&lt;/strong&gt;类键值观察如下key paths：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;isCancelled&lt;/li&gt;
&lt;li&gt;isConcurrent&lt;/li&gt;
&lt;li&gt;isExecuting&lt;/li&gt;
&lt;li&gt;isFinished&lt;/li&gt;
&lt;li&gt;isReady&lt;/li&gt;
&lt;li&gt;dependencies&lt;/li&gt;
&lt;li&gt;queuePriority&lt;/li&gt;
&lt;li&gt;completionBlock&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你重写&lt;strong&gt;start&lt;/strong&gt;方法，或者对&lt;strong&gt;NSOperation&lt;/strong&gt;对象的其它自定义运行(覆盖main除外)，你必须确保你自定义的对象维护了这些关键路径的KVO。当你重写&lt;strong&gt;start&lt;/strong&gt;方法，你需要关注&lt;strong&gt;isExecuting&lt;/strong&gt;和&lt;strong&gt;isFinished&lt;/strong&gt;这两个关键路径。在重新实现方法的时候，这些关键路径是最常被影响的。&lt;/p&gt;

&lt;p&gt;如果你希望依赖于其它东西(非操作对象)，你也可以重写&lt;strong&gt;isReady&lt;/strong&gt;方法，并强制返回&lt;strong&gt;NO&lt;/strong&gt;，直到你等待的依赖满足。(如果你实现自定义的依赖并且仍然要支持&lt;strong&gt;NSOperation&lt;/strong&gt;类提供的默认依赖管理，确保在&lt;strong&gt;isReady&lt;/strong&gt;方法里面调用了超类的方法。)当你的操作对象的准备状态改变时，应该为关键路径&lt;strong&gt;isReady&lt;/strong&gt;生成KVO通知报告这些改变。除非你重写了&lt;strong&gt;addDependency:&lt;/strong&gt;或者&lt;strong&gt;removeDependency:&lt;/strong&gt;方法，你应该不需要担心为&lt;strong&gt;dependencies&lt;/strong&gt;关键路径产生KVO通知。&lt;/p&gt;

&lt;p&gt;尽管你可以为&lt;strong&gt;NSOperation&lt;/strong&gt;类的其它路径生成KVO通知，但是你不需要这么做。如果你需要取消操作，你可以直接调用已经存在的&lt;strong&gt;cancel&lt;/strong&gt;方法。同样的，你也很少需要在操作对象里面修改队列的优先级信息。最后，除非你的操作需要能够动态改变并发状态，你也不需要提供&lt;strong&gt;isConcurrent&lt;/strong&gt;关键路径的KVO通知。&lt;/p&gt;

&lt;p&gt;更多关于KVO，以及如何在你自定义的对象中使用KVO，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i&#34;&gt; Key-Value Observing Programming Guide &lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;customizing-the-execution-behavior-of-an-operation-object&#34;&gt;Customizing the Execution Behavior of an Operation Object&lt;/h2&gt;

&lt;p&gt;(自定义一个操作对象的执行行为)&lt;/p&gt;

&lt;p&gt;操作对象的配置发生在创建之后添加到队列之前。接下来的几个部分描述的配置适用于所有的操作对象，不管是你自己子类化的&lt;strong&gt;NSOperation&lt;/strong&gt;还是已经存在子类。&lt;/p&gt;

&lt;h3 id=&#34;configuring-interoperation-dependencies&#34;&gt;Configuring Interoperation Dependencies&lt;/h3&gt;

&lt;p&gt;(配置操作之间的依赖)&lt;/p&gt;

&lt;p&gt;依赖是在不同的操作对象之间串行执行的一种方法。一个操作依赖于其它操作时必须等到依赖的所有操作执行完成之后才能执行。因此，你可以在两个操作对象之间创建一对一的关系或者构建复杂的对象依赖图。&lt;/p&gt;

&lt;p&gt;你可以使用&lt;strong&gt;NSOperation&lt;/strong&gt;的&lt;strong&gt;addDependency:&lt;/strong&gt;方法在两个操作对象之间建立依赖。这个方法会创建一个单向的依赖，表示当前的操作对象依赖于你参数指定的目标操作对象。这种依赖意味着当前操作对象不能开始执行直到目标对象执行完成。依赖关系并不局限于同一个队列中的操作。操作对象会自己管理依赖，所以完全可以在不同的队列中的操作对象间建立依赖。但是有一件事情是不能接受的，就是在操作之间创建了循环的依赖。这样做就导致了编程错误，没有操作会运行。&lt;/p&gt;

&lt;p&gt;当操作的所有依赖都执行完成后，操作对象才会准备执行.(如果你自定义了&lt;strong&gt;isReady&lt;/strong&gt;方法的行为，那么操作的准备状态由你设置的决定。)如果操作对象在队列中，那么队列可能在任何时间开始执行。如果你计划手动执行操作，何时执行取决于你何时调用操作的&lt;strong&gt;start&lt;/strong&gt;方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要&lt;/strong&gt;：你应该总是在运行你的操作或者添加到队列之前配置依赖。之后添加的依赖可能并没有效果。&lt;/p&gt;

&lt;p&gt;依赖依靠于每一个操作对象在状态改变时发出合适的KVO通知。如果你自定义了你操作对象的行为，你需要在你自定义的代码中生成合适的KVO通知来避免依赖出现问题。更多关于KVO通知和操作对象，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW10&#34;&gt; Maintaining KVO Compliance &lt;/a&gt;。更多关于配置依赖的信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Reference/NSOperation_class/index.html#//apple_ref/doc/uid/TP40004591&#34;&gt; NSOperation Class Reference &lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;changing-an-operation-s-execution-priority&#34;&gt;Changing an Operation’s Execution Priority&lt;/h3&gt;

&lt;p&gt;(修改操作执行的优先级)&lt;/p&gt;

&lt;p&gt;对于添加到队列的操作，执行顺序首先由队列里面操作的准备好的顺序，然后由相关的优先级来确定。准备状态由依赖的其它操作决定，但是优先级是操作对象本身的一个属性。默认情况下，所有的新的操作对象都有默认的优先级，但是你可以根据需要通过调用操作对象的&lt;strong&gt;setQueuePriority:&lt;/strong&gt;方法来增加或者减少。&lt;/p&gt;

&lt;p&gt;优先级只能应用于相同操作队列里的操作。如果你的应用程序有多个操作队列，每一个队列里面的操作的优先级是独立的。因此，在不同的队列里面，低等级的优先级可能比高等级的优先级先执行。&lt;/p&gt;

&lt;p&gt;优先级并不是依赖的替代品。优先级只会用来确定那些队列里面准备开始执行的操作的执行顺序。比如，一个队列里面包含了一个高优先级和一个低优先级的操作，并且都准备好了，这个队列会先执行高优先级的操作。然而，如果高优先级的操作并没有准备好，但是低优先级的准备好了，这个队列会先执行低优先级的操作。如果你想防止一个操作在另一个操作完成之前开始，你必须使用依赖(如&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW17&#34;&gt; Configuring Interoperation Dependencies &lt;/a&gt;描述的那样)。&lt;/p&gt;

&lt;h3 id=&#34;changing-the-underlying-thread-priority&#34;&gt;Changing the Underlying Thread Priority&lt;/h3&gt;

&lt;p&gt;(修改底层线程的优先级)&lt;/p&gt;

&lt;p&gt;在OS X v10.6之后，我们可以配置执行操作的底层线程的优先级。线程由系统内核管理，通常高优先级的线程给予更多的执行机会。在操作对象中你使用一个范围是0.0 - 1.0的浮点数来指定线程的优先级。如果你没有显式的指定线程的优先级，操作会运行在默认的线程优先级(0.5)的线程上。&lt;/p&gt;

&lt;p&gt;要设置操作的线程的优先级，你必须在将操作对象添加到队列之前(或者手动执行之前)调用操作对象的&lt;strong&gt;setThreadPriority:&lt;/strong&gt;方法来设置优先级。当要执行操作时，默认的&lt;strong&gt;start&lt;/strong&gt;方法会使用你指定的值来设置当前线程的优先级。不过新的优先级只在操作的&lt;strong&gt;main&lt;/strong&gt;方法范围内有效。其它所有的代码(包括操作的完成Block)运行在默认的优先级上。如果你创建了一个并发的操作，因此重写了&lt;strong&gt;start&lt;/strong&gt;方法，你必须自己配置线程的优先级&lt;/p&gt;

&lt;h3 id=&#34;setting-up-a-completion-block&#34;&gt;Setting Up a Completion Block&lt;/h3&gt;

&lt;p&gt;(设置一个完成Block)&lt;/p&gt;

&lt;p&gt;在OS X v10.6及以后，操作可以在完成主任务之后执行一个完成Block。你可以使用这个完成Block来执行任何不属于主任务的工作。比如，你可能会使用这个Block来通知相关的客户端操作已经完成了。一个并发的操作对象可能会使用这个Block生成最终的KVO通知。&lt;/p&gt;

&lt;p&gt;调用&lt;strong&gt;NSOperation&lt;/strong&gt;的&lt;strong&gt;setCompletionBlock:&lt;/strong&gt;方法来设置完成Block。你传递的这个Block应该没有参数列表和返回值。&lt;/p&gt;

&lt;h2 id=&#34;tips-for-implementing-operation-objects&#34;&gt;Tips for Implementing Operation Objects&lt;/h2&gt;

&lt;p&gt;(实现操作对象的技巧)&lt;/p&gt;

&lt;p&gt;尽管操作对象非常容易实现，当你在写代码的时候还是有几点需要注意的。接下来的部分描述了在你编写操作对象时应该考虑的几点因素。&lt;/p&gt;

&lt;h3 id=&#34;managing-memory-in-operation-objects&#34;&gt;Managing Memory in Operation Objects&lt;/h3&gt;

&lt;p&gt;(操作对象的内存管理)&lt;/p&gt;

&lt;p&gt;接下来的几个章节描述了操作对象里面内存管理的几个关键要素。关于Objective-C中一般的内存管理信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i&#34;&gt; Advanced Memory Management Programming Guide &lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&#34;avoid-per-thread-storage&#34;&gt;Avoid Per-Thread Storage&lt;/h4&gt;

&lt;p&gt;(避免存储每个线程)&lt;/p&gt;

&lt;p&gt;虽然大多数操作都在线程上执行，但对于非并发操作，线程通常由队列提供。如果一个操作队列为你提供了线程，你应该认为这个线程的拥有者是队列而你的操作不应该触碰。特别是，你永远不应该关联不是你创建或管理的线程的数据。操作队列管理的线程来来去去，这取决于系统和应用程序的需要。因此，给存储的线程传递数据是不可靠的，很可能会失败。&lt;/p&gt;

&lt;p&gt;对于操作对象，没有必要在任何情况下存储线程。当你创建操作对象时，你应该提供对象工作需要的所有数据。所有输入和输出的数据都应该存储在操作对象中，最后再整合到你的应用程序中，或者最终释放掉。&lt;/p&gt;

&lt;h4 id=&#34;keep-references-to-your-operation-object-as-needed&#34;&gt;Keep References to Your Operation Object As Needed&lt;/h4&gt;

&lt;p&gt;(根据需要保留操作对象的引用)&lt;/p&gt;

&lt;p&gt;因为操作对象是异步运行的，你不应该假设你可以创建它们然后忘记它们。它们仍然是对象，你仍然需要根据你代码的需要来管理它们的引用。特别是如果你要在操作对象完成值后要获取其中的数据。&lt;/p&gt;

&lt;p&gt;另一个你应该保留操作的引用的原因是之后你可能没有机会向队列请求操作对象。队列总是尽最大可能的快速调度和执行操作。在大多数情形下，大部分操作在添加到队列之后就开始执行了。通过自己的代码返回到队列以获得操作的引用时，这个操作可能已经执行完成并移除队列了。&lt;/p&gt;

&lt;h3 id=&#34;handling-errors-and-exceptions&#34;&gt;Handling Errors and Exceptions&lt;/h3&gt;

&lt;p&gt;(处理错误和异常)&lt;/p&gt;

&lt;p&gt;因为操作本质上就是应用程序内创建的实体，它们有责任处理出现的任何错误或异常。在OS X v10.6及之后，&lt;strong&gt;NSOperation&lt;/strong&gt;类的&lt;strong&gt;start&lt;/strong&gt;方法默认不会捕捉异常。(在OS X v10.5，&lt;strong&gt;start&lt;/strong&gt;方法会捕捉然后禁止异常。)你自己的代码因该总是捕捉异常然后直接禁止。同时也应该检查错误代码然后通知应用程序的相应部分。如果你替换了&lt;strong&gt;start&lt;/strong&gt;方法，你也必须捕获所有异常，阻止它们离开底层线程的范围。&lt;/p&gt;

&lt;p&gt;你应该准备好处理以下几种错误情况的类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检查并处理&lt;strong&gt;UNIX errno&lt;/strong&gt;风格的错误代码。&lt;/li&gt;
&lt;li&gt;明确的检查方法和函数返回的错误码。&lt;/li&gt;
&lt;li&gt;捕获你自己代码或者其它系统框架抛出的异常。&lt;/li&gt;
&lt;li&gt;捕获&lt;strong&gt;NSOperation&lt;/strong&gt;类自己抛出的异常，会在如下几种情形抛出异常：

&lt;ol&gt;
&lt;li&gt;当操作并没有准备好执行，但是调用了&lt;strong&gt;start&lt;/strong&gt;方法。&lt;/li&gt;
&lt;li&gt;当操作正在执行或者结束(很有可能是被取消)，&lt;strong&gt;start&lt;/strong&gt;再次被调用。&lt;/li&gt;
&lt;li&gt;当你正在给你一个执行的或者结束的操作添加完成Block。&lt;/li&gt;
&lt;li&gt;当你向一个取消的&lt;strong&gt;NSInvocationOperation&lt;/strong&gt;对象检索结果。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你的自定义的代码会遇到异常或者错误，你应该采取所需的措施将错误传播到应用程序的其它部分。&lt;strong&gt;NSOperation&lt;/strong&gt;类没有提供显式的方法传递错误或者异常到应用程序的其它部分。因此，如果这些信息很重要，你必须提供必须的代码。&lt;/p&gt;

&lt;h2 id=&#34;determining-an-appropriate-scope-for-operation-objects&#34;&gt;Determining an Appropriate Scope for Operation Objects&lt;/h2&gt;

&lt;p&gt;(为操作对象确定一个适当的范围)&lt;/p&gt;

&lt;p&gt;尽管可以为一个操作队列添加任意数量的操作，但是这样做是不切实际的。和任何对象一样，&lt;strong&gt;NSOperation&lt;/strong&gt;类的实例都会消耗内存，并且相关的任务执行也会消耗。如果你的操作对象只做很少量的操作，然后你创建了一万个，然后你可能会发现调度花的时间比实际执行任务花的时间多多了。如果你的应用程序已经是内存有限，你可能会发现，仅仅只有数万个的操作对象可能会进一步降低性能。&lt;/p&gt;

&lt;p&gt;要想高效的使用操作，关键是要在工作量和保持计算机繁忙之间找到平衡点。确保操作都有一定的工作量要执行。比如，如果你的应用程序创建了100个操作对象执行100次相同的任务，可以考虑换成10个操作对象，每个执行10次。&lt;/p&gt;

&lt;p&gt;你同样也应该避免一次给队列添加大量的操作，或者持续快速的向队列添加操作，超过队列的处理的能力。可以分批创建这些对象。当一批执行完成后，使用完成Block高速应用程序创建一批新的。当你有大量工作需要做的时候，你希望足够的操作填满队列，从而使计算机处于繁忙的状态，但是你不想一次创建大量的操作导致应用程序耗尽内存。&lt;/p&gt;

&lt;p&gt;当然，你创建的操作对象的数量，以及每个操作要执行的工作量都是可变的，完全依赖于你的应用程序。你应该总是使用像&lt;strong&gt;Instruments&lt;/strong&gt;这样的工具来帮助你在效率和速度中找到平衡点。对于&lt;strong&gt;Instruments&lt;/strong&gt;和其它的一些用来收集代码性能的性能工具，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410&#34;&gt; Performance Overview &lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;executing-operations&#34;&gt;Executing Operations&lt;/h2&gt;

&lt;p&gt;(执行操作)&lt;/p&gt;

&lt;p&gt;最终，你的应用程序需要执行相关的工作。接下来的章节将会学习几种执行操作的方法，以及在运行时如何操纵操作。&lt;/p&gt;

&lt;h3 id=&#34;adding-operations-to-an-operation-queue&#34;&gt;Adding Operations to an Operation Queue&lt;/h3&gt;

&lt;p&gt;(添加操作到操作队列)&lt;/p&gt;

&lt;p&gt;到目前为止，执行操作的最简单的方法就是使用操作队列，&lt;strong&gt;NSOperationQueue&lt;/strong&gt;类的实例。你的应用程序负责创建和维护任何打算使用的队列。一个应用程序可能有任意数量的队列，但也有实际的限制多少操作可以在给定的时间点被执行。操作队列和系统一起工作，限制了并发的操作的数量，使其跟可用的内核以及系统负载合适。因此，创建额外的队列并不意味着你可以执行额外的操作。&lt;/p&gt;

&lt;p&gt;使用如下代码创建一个队列：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSOperationQueue* aQueue = [[NSOperationQueue alloc] init];、
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;strong&gt;addOperation:&lt;/strong&gt;方法将操作添加到队列。在OS X v10.6及以后，你可以使用&lt;strong&gt;addOperations:waitUntilFinished:&lt;/strong&gt;方法将一组操作添加到队列中，或者你可以使用&lt;strong&gt;addOperationWithBlock:&lt;/strong&gt;方法直接将Block添加到队列中。所有的这些方法都会将操作进行排队，然后通知队列应该开始处理这些操作了。大部分情形下，操作在添加到队列之后不久就开始执行了，但是操作队列可能因为几个原因延迟执行队列里面的操作。具体而言，一些操作依赖于其它的操作，但是其它的操作还没有完成。或者操作队列被刮起了或者已经在执行最大的并发操作数量的操作了。下面的例子展示了将操作添加到队列的基本语法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[aQueue addOperation:anOp]; // Add a single operation
[aQueue addOperations:anArrayOfOps waitUntilFinished:NO]; // Add multiple operations
[aQueue addOperationWithBlock:^{
    /* Do something. */
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;重要&lt;/strong&gt;：在操作添加到队列以后切勿进行修改。在队列中等待的时候，操作可能在任何时间开始执行，因此改变依赖或者数据会产生不理的影响。如果你想直到操作的状态，你可以使用&lt;strong&gt;NSOperation&lt;/strong&gt;类的方法来确定操作是在运行、等待、或者已经完成。&lt;/p&gt;

&lt;p&gt;尽管&lt;strong&gt;NSOperationQueue&lt;/strong&gt;类被设计来对操作进行并发执行，但是可以强制一个队列在一个时间只运行一个操作。操作队列对象的&lt;strong&gt;setMaxConcurrentOperationCount:&lt;/strong&gt;方法允许你配置并发操作的最大数量。传递1这个值会导致队列一次只执行一个操作。尽管一次只执行一个操作，但是执行顺序还是基于其它因素确定，比如每个操作的准备状态以及优先级。因此一个串行的操作队列提供的行为与调度队列的行为并不是一样的。如果操作对象的执行顺序对你很重要，你应该在将操作对象添加到队列之前建立依赖，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW17&#34;&gt; Configuring Interoperation Dependencies &lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;更多关于使用操作队列的信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Reference/NSOperationQueue_class/index.html#//apple_ref/doc/uid/TP40004592&#34;&gt; NSOperationQueue Class Reference &lt;/a&gt;。更多关于串行调度队列的信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW6&#34;&gt; Creating Serial Dispatch Queues &lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;executing-operations-manually&#34;&gt;Executing Operations Manually&lt;/h3&gt;

&lt;p&gt;(手动执行操作)&lt;/p&gt;

&lt;p&gt;尽管操作队列是执行操作对象最方便的方法，但是不使用队列也可以执行。如果你选择手动执行操作，那么，在你的代码中有一些注意事项要你关注。尤其是这个操作已经准备好了要执行，并且总是调用&lt;strong&gt;start&lt;/strong&gt;方法开始。&lt;/p&gt;

&lt;p&gt;一个操作并不会考虑执行直到&lt;strong&gt;isReady&lt;/strong&gt;方法返回&lt;strong&gt;YES&lt;/strong&gt;。&lt;strong&gt;isReady&lt;/strong&gt;已经融入了系统管理依赖的方法里面，&lt;strong&gt;NSOperation&lt;/strong&gt;类提供操作的依赖的状态。只有当依赖很清晰并且开始执行。&lt;/p&gt;

&lt;p&gt;当手动执行一个操作时，你应该总是使用&lt;strong&gt;start&lt;/strong&gt;方法开始执行。你使用这个方法替代&lt;strong&gt;main&lt;/strong&gt;或者其它的方法，因为&lt;strong&gt;start&lt;/strong&gt;方法在执行你的代码之前会执行几项安全检查。特别是，默认的&lt;strong&gt;start&lt;/strong&gt;方法会生成操作要求处理它们依赖进度的KVO通知。如果你的操作已经被取消了，或者抛出了异常而没有真正的准备好要执行，这个方法正好也避免了执行你的操作。&lt;/p&gt;

&lt;p&gt;如果你的应用程序定义了并发操作对象，你也应该考虑调用&lt;strong&gt;isConcurrent&lt;/strong&gt;方法。如果方法返回了&lt;strong&gt;NO&lt;/strong&gt;，你本地的代码可以决定是否在当前线程同步执行或者另外创建一个线程。然后，实现这种检查完全取决于你。&lt;/p&gt;

&lt;p&gt;Listing 2-8展示了一些在手动执行操作之前要进行的简单检查。如果方法返回&lt;strong&gt;NO&lt;/strong&gt;，你可以设置一个定时器然后之后再调用这个方法。你应该不断的重新安排计时器，直到方法返回YES，因为该操作可能会取消。&lt;/p&gt;

&lt;p&gt;Listing 2-8  Executing an operation object manually&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (BOOL)performOperation:(NSOperation*)anOp
{
    BOOL        ranIt = NO;

    if ([anOp isReady] &amp;amp;&amp;amp; ![anOp isCancelled])
    {
        if (![anOp isConcurrent])
            [anOp start];
        else
            [NSThread detachNewThreadSelector:@selector(start)
                                     toTarget:anOp withObject:nil];
        ranIt = YES;
    }
    else if ([anOp isCancelled])
    {
        // If it was canceled before it was started,
        //  move the operation to the finished state.
        [self willChangeValueForKey:@&amp;quot;isFinished&amp;quot;];
        [self willChangeValueForKey:@&amp;quot;isExecuting&amp;quot;];
        executing = NO;
        finished = YES;
        [self didChangeValueForKey:@&amp;quot;isExecuting&amp;quot;];
        [self didChangeValueForKey:@&amp;quot;isFinished&amp;quot;];

        // Set ranIt to YES to prevent the operation from
        // being passed to this method again in the future.
        ranIt = YES;
    }
    return ranIt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;canceling-operations&#34;&gt;Canceling Operations&lt;/h3&gt;

&lt;p&gt;(取消操作)&lt;/p&gt;

&lt;p&gt;一旦添加到操作队列，操作对象就被队列拥有了，并且无法移除。将操作出队列的唯一方法就是取消它。你可以调用操作对象的&lt;strong&gt;cancel&lt;/strong&gt;方法移除单个的操作对象或者调用操作队列对象的&lt;strong&gt;cancelAllOperations&lt;/strong&gt;方法移除所有的操作。&lt;/p&gt;

&lt;p&gt;只有你确定不再需要操作对象时才应该取消它。发出取消命令会将操作对象设置为取消的状态，会阻止它被执行。由于取消也被认为是完成，依赖于它的其它操作对象会收到适当的KVO通知，并清除依赖状态，然后得到执行。有时候为了响应重大的事件时通常会取消队列里面所有的操作，比如应用程序退出或者用户指定取消操作，而不是选择性的进行取消。&lt;/p&gt;

&lt;h3 id=&#34;waiting-for-operations-to-finish&#34;&gt;Waiting for Operations to Finish&lt;/h3&gt;

&lt;p&gt;(等待操作完成)&lt;/p&gt;

&lt;p&gt;为了获得最佳的性能，你应该将你的操作尽可能的设计成异步执行的，让你应用程序在执行操作的时候能够自由的处理额外的工作。如果代码创建的操作也要处理操作的结果，你可以使用&lt;strong&gt;NSOperation&lt;/strong&gt;的&lt;strong&gt;waitUntilFinished&lt;/strong&gt;方法来等待操作的完成。通常我们应该避免写这样的代码。阻塞当前线程可能是简便的解决方法，但是引进了更多的串行代码，限制了应用的并发性降低了用户体验。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要&lt;/strong&gt;：绝对不要在应用主线程中等待一个操作完成。你只能在其它的线程中或者其它的操作中才能这样做。阻塞主线程将导致应用无法响应用户事件，应用也将表现为无响应。&lt;/p&gt;

&lt;p&gt;除了可以等待单个操作完成，你也可以通过调用&lt;strong&gt;NSOperationQueue&lt;/strong&gt;的&lt;strong&gt;waitUntilAllOperationsAreFinished&lt;/strong&gt;方法来等待队列中的所有的操作完成。当在等待整个队列完成时，注意，你应用程序的其它线程仍然可以添加操作到队列，就能会加长等待的时间。&lt;/p&gt;

&lt;h3 id=&#34;suspending-and-resuming-queues&#34;&gt;Suspending and Resuming Queues&lt;/h3&gt;

&lt;p&gt;(挂起和恢复队列)&lt;/p&gt;

&lt;p&gt;如果你想临时暂停执行的操作，你可以使用&lt;strong&gt;setSuspended:&lt;/strong&gt;方法挂起相应的操作队列。挂起一个队列不会导致已经在执行的操作中途放弃任务。只是简单的阻止调度新的操作执行。当用户要求暂停一些正在进行的工作时你可能会挂起一个队列，因为有时候用户可能最终想要恢复那些工作。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Concurrency Programming Guide - Concurrency and Application Design</title>
      <link>http://lynchwong.com/2016/01/concurrency-programming-guide---concurrency-and-application-design/</link>
      <pubDate>Thu, 14 Jan 2016 13:51:15 +0000</pubDate>
      
      <guid>http://lynchwong.com/2016/01/concurrency-programming-guide---concurrency-and-application-design/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ConcurrencyandApplicationDesign/ConcurrencyandApplicationDesign.html#//apple_ref/doc/uid/TP40008091-CH100-SW1&#34;&gt;官方文档&lt;/a&gt;
&lt;/p&gt;

&lt;h1 id=&#34;concurrency-and-application-design&#34;&gt;Concurrency and Application Design&lt;/h1&gt;

&lt;p&gt;(并发及应用程序设计)&lt;/p&gt;

&lt;p&gt;在早期的计算当中，计算机单元时间内能够执行的最大工作量取决于CPU的内核工作的时钟频率。但是随着科技的进步以及处理器设计变得更紧凑，温度以及一些物理特性开始限制处理器内核工作的最大时钟频率。因此，芯片制造商开始寻求其它的方法来提升他们芯片的整体性能。他们定下的解决方案就是在每一块芯片上增加处理器的内核数量。通过增加内核的数量，单个芯片可以在不增加CPU执行速度或者改变芯片尺寸或者热特性的前提下执行更多的指令。唯一的问题就是如何利用额外的内核。&lt;/p&gt;

&lt;p&gt;为了能够利用多核的优势，计算机需要能够在同一时间做多件事情的软件。像OS X和iOS这样现代的、多任务的操作系统在任何给定的时间都可能运行着上百个或者更多的程序，所以在不同的内核上调度每一个程序成为可能。然而，这些大部分程序不是系统的守护进程就是消耗很少的处理时间的后台应用程序。相反，真正需要的是一种使单个应用程序能够更有效的利用额外内核的方法。&lt;/p&gt;

&lt;p&gt;对于一个应用程序来说使用多内核的传统方法就是创建多个线程。然而，随着内核数量的增加，线程解决方案就会有问题。最大的问题是线程代码的规模跟任意数量的内核并没有很好的扩展。你并不能创建对应内核数量的线程，并期望程序能够很好的运行在上面。你会需要知道的是能够有效利用的内核的数量，这个数量由应用程序来计算是很有挑战的。即使你拿到了正确的数量，然而编程确保这么多的线程能够高效率的运行、避免相互之间互相干扰也是很有挑战的。&lt;/p&gt;

&lt;p&gt;所以，总结一下问题就是：应用程序需要一种能够利用计算机可变数量内核的方法。单个应用程序能够执行的工作量也需要能够动态地扩展以适应系统条件的变化。解决方法必须足够简单以至于不会增加采取这些优势所需的工作量。好消息是苹果的操作系统提供了所有这些问题的解决方案，本章就来了解一下这些技术，你可以在你的代码中使用他们。&lt;/p&gt;

&lt;h2 id=&#34;the-move-away-from-threads&#34;&gt;The Move Away from Threads&lt;/h2&gt;

&lt;p&gt;(远离线程)&lt;/p&gt;

&lt;p&gt;尽管线程已经存在了很多年，并且会被继续使用，但是他们在可伸缩的方式上并没有解决多线程执行的一般性问题。使用线程，创建一个可扩展的解决方案的责任就落在了开发者的身上。你必须决定要创建多少个线程，并且根据系统条件的改变动态调整线程的数量。另外一个问题就是你的应用程序会承担创造和维护线程相关的所有成本。&lt;/p&gt;

&lt;p&gt;OS X和iOS使用异步设计的方式来解决并发问题，而不是依赖于线程。异步函数在操作系统中存在了许多年，它们常常被用来开始一些需要花费很长时间的任务，比如从磁盘读取数据。当调用时，一个异步函数在幕后开始运行任务来做一些工作，但是在这些任务工作完成之前可能就返回了。通常来说，这些任务涉及到后台线程，在这些线程上开始执行任务，然后当任务完成时给调用者发送一个通知(通常来说是回调函数)。在以前的时候，如果不存在你需要的异步函数，那么你必须创建你自己的异步函数然后创建你自己的线程。但是现在，OS X和iOS提供了你可以执行异步任务而不需要你自己管理线程的技术。&lt;/p&gt;

&lt;p&gt;异步执行任务的众多技术之一就是Grand Central Dispatch (GCD)。该技术将你自己应用程序中的线程管理的代码移动到了系统层级。所有你需要做的就是定义你想要执行的任务然后将它们添加到适当的dispatch queues(调度队列)中。GCD负责创建需要的线程，并且在这些线程上调度你的任务。因为线程管理现在成为了系统的一部分，GCD提供了全面的方法来管理和执行任务，提供了比传统线程更好的效率。&lt;/p&gt;

&lt;p&gt;Operation queues是Objective-C对象，和调度队列很像。你定义想要执行的任务然后添加到operation queue(操作队列)中，这些队列负责调度以及执行这些任务。像GCD一样，操作队列负责为你管理所有的线程，确保任务尽可能在系统上快的、高效的执行。&lt;/p&gt;

&lt;p&gt;下面的部分提供了更多关于调度队列、操作队列的信息，以及你可以在应用程序中使用的异步技术相关的一些信息。&lt;/p&gt;

&lt;h3 id=&#34;dispatch-queues&#34;&gt;Dispatch Queues&lt;/h3&gt;

&lt;p&gt;(调度队列)&lt;/p&gt;

&lt;p&gt;调度队列是基于C语言用来执行自定义任务的机制。一个调度队列执行任务时要么是串行的要么是并行的，但是总是先进先出的顺序。(换句话说就是：调度队列将任务出队列并开始执行任务时的顺序与将任务添加到队列时的顺序是一样的。)一个串行的调度队列一次只执行一个任务，等到任务完成时才会将新的任务出队列并执行。相反，一个并行的调度队列会尽它可能多的执行任务，而不用等待已经在执行任务结束后再开始。&lt;/p&gt;

&lt;p&gt;调度队列的其它优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提供了直观简单的编程接口。&lt;/li&gt;
&lt;li&gt;提供了全面、自动的线程池管理。&lt;/li&gt;
&lt;li&gt;提供了调优后的速度。&lt;/li&gt;
&lt;li&gt;更高效的内存使用。&lt;/li&gt;
&lt;li&gt;不会使内核陷入负载之中。&lt;/li&gt;
&lt;li&gt;异步调度任务到调度队列而不会让队列死锁。&lt;/li&gt;
&lt;li&gt;优雅、可扩展性强。&lt;/li&gt;
&lt;li&gt;一个串行调度队列比其它的锁和同步原语更加高效。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你提交给调度队列的任务必须封装在函数或者Block对象内。Block对象是C语言的功能，在OS X v10.6和iOS 4.0引进，概念上和函数指针有些相似，但有一些额外的优势。相反，将Block定义在它们自己的作为范围内，通常将Block定义在其它的函数或者方法内，以便于它们能够访问函数和方法的变量。Block也能够移出它们自己的作为范围并复制到堆上，这些行为将会在你把Block提交到调度队列上时发生。所有的这些语义(语法？)让它只需要一小部分代码就能实现非常动态的任务。&lt;/p&gt;

&lt;p&gt;调度队列是Grand Central Dispatch技术的一部分，也是C运行时的一部分。关于调度队列的更多信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW1&#34;&gt; Dispatch Queues &lt;/a&gt;。更多关于Block及它优点的信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502&#34;&gt; Blocks Programming Topics &lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;dispatch-sources&#34;&gt;Dispatch Sources&lt;/h3&gt;

&lt;p&gt;(调度源)&lt;/p&gt;

&lt;p&gt;调度源是基于C语言用来异步处理指定系统类型事件的机制。一个调度源封装了有关特定类型的系统事件的信息，每当事件发生时会提交一个指定的Block对象或者函数给调度队列。你可以使用调度源监控以下几种系统事件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定时器&lt;/li&gt;
&lt;li&gt;信号处理&lt;/li&gt;
&lt;li&gt;描述符相关的事件&lt;/li&gt;
&lt;li&gt;进程相关的事件&lt;/li&gt;
&lt;li&gt;Mach端口事件&lt;/li&gt;
&lt;li&gt;你触发的自定义事件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;调度源是Grand Central Dispatch技术的一部分。关于如何在应用程序中使用调度源的更多信息，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1&#34;&gt; Dispatch Sources &lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;operation-queues&#34;&gt;Operation Queues&lt;/h3&gt;

&lt;p&gt;(操作队列)&lt;/p&gt;

&lt;p&gt;操作队列是Cocoa框架中的，由&lt;strong&gt;NSOperationQueue&lt;/strong&gt;类实现，与并发调度队列(concurrent dispatch queue)是等价的。调度队列总是先进先出的顺序执行任务，当操作队列决定任务的执行顺序时会将其它因素考虑进来。这些因素主要是一个任务是否依赖于另一个完成了的任务。你可以在定义任务的时候配置依赖，从而给你的任务创建复杂的执行顺序图。&lt;/p&gt;

&lt;p&gt;你提交到操作队列中的任务必须是&lt;strong&gt;NSOperation&lt;/strong&gt;类的实例。一个操作对象(operation object)是封装了你想要执行的任务以及所需数据的Objective-C对象。因为&lt;strong&gt;NSOperation&lt;/strong&gt;本质上是一个抽象基类，你通常需要定义它的子类来执行任务。然而，Foundation框架包含了一些&lt;strong&gt;NSOperation&lt;/strong&gt;的子类(NSBlockOperation和NSInvocationOperation)，你可以用来执行你的任务。&lt;/p&gt;

&lt;p&gt;操作对象会生成KVO的通知，它是监测你任务进度的有效途径。虽然操作队列总是并发执行任务，但是需要的时候你可以使用依赖来确保任务是串行执行的。&lt;/p&gt;

&lt;p&gt;关于更多如何使用操作队列以及如何自定义操作对象，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW1&#34;&gt; Operation Queues &lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;asynchronous-design-techniques&#34;&gt;Asynchronous Design Techniques&lt;/h2&gt;

&lt;p&gt;(异步设计技术)&lt;/p&gt;

&lt;p&gt;在你重新设计你的代码以此来支持并发之前，你应该先问问自己这样做是否是必需的。并发可以提升你代码的响应速度并确保你的主线程能够自由的响应用户事件。它甚至能够在相同时间内借助更多内核做更多的工作来提升代码的效率。然而，这也增加了开销，增加了代码的整体复杂性，在编写和调试代码时更有难度。&lt;/p&gt;

&lt;p&gt;因为并发增加了复杂性，它并不能当作一种功能在产品周期末尾添加到应用程序中。为了做的正确，你需要仔细考虑你应用程序执行的任务及用于执行这些任务的数据结构。操作不当，你就会发现你的代码的运行速度比以前更慢，对用户响应也不灵敏。所以，在你开始设计一些目标时花一些时间仔细想想你需要采取的方法是非常值得的。&lt;/p&gt;

&lt;p&gt;每个应用程序都有不同要求以及不同的任务要执行。所以没有文档告诉你如何设计你的应用程序和相关的任务。但是，接下来部分会提供一些指导，帮助你在设计的过程中做出正确的选择。&lt;/p&gt;

&lt;h3 id=&#34;define-your-application-s-expected-behavior&#34;&gt;Define Your Application’s Expected Behavior&lt;/h3&gt;

&lt;p&gt;(定义应用程序的预期行为)&lt;/p&gt;

&lt;p&gt;在考虑把并发添加到你应用程序之前，你应该总是从定义你应用程序的正确的行为开始。明白你应用程序预期的行为是你之后验证设计的一种方法。通过引入并发到应用程序，它也应该能够收到预期的性能优势。&lt;/p&gt;

&lt;p&gt;你应该做的第一件事就是把你应用程序要执行的任务以及任务相关的对象和数据结构枚举出来。最初，你可能想要从用户选择了一个菜单或者点击了一个按钮来执行任务开始。这些任务提供了独立的行为，并明确定义了任务开始和结束的点。你也应该定义一些你应用程序可能会执行但是和用户交互无关的其它类型的任务，比如基于定时器的任务。&lt;/p&gt;

&lt;p&gt;在你列出了这些高层次的任务列表之后，你需要将每一个任务细分到能够将任务成功执行的步骤上。在这个层面上，你应该主要关注那些你需要的数据结构和对象的改变是如何影响整个应用程序状态的改变。你也应该注意对象和数据结构之间的相互依赖。比如，一个任务涉及到对数组里的对象做相同的改变，需要值得注意的是改变一个对象是否会影响其它的对象。如果对象能够相互独立的进行修改，那么这里就可以对这些修改进行并发。&lt;/p&gt;

&lt;h3 id=&#34;factor-out-executable-units-of-work&#34;&gt;Factor Out Executable Units of Work&lt;/h3&gt;

&lt;p&gt;(分解出可执行工作单元)&lt;/p&gt;

&lt;p&gt;只要你明白了你应用程序的任务，你应该能够确定你的代码中那些地方能够从并发中受益了。如果改变了任务中一步或者几步就会改变结果，你应该串行的执行这些步骤。如果改变这些顺序对输出没有影响，那么你应该考虑并行的执行这些顺序。在上述两种情形中，你定义了工作的可执行单元用来标示一个或者多个需要执行的步骤。这些工作单元就变成了那些你封装在Block对象或者操作对象中的东西，并调度给合适的队列。&lt;/p&gt;

&lt;p&gt;对于每一个你确定的可执行工作单元，至少在最初阶段不要担心多少工作量被执行了。尽管那里总有开销在运行一个线程，但是调度队列和操作队列的一个优势就是比传统的线程开销要小很多。使用队列来执行更小的工作单元比使用线程更高效。当然，你应该经常测量你的实际性能和调整你的任务所需的尺寸，但最初的时候，任务不应该被考虑的太小。&lt;/p&gt;

&lt;h3 id=&#34;identify-the-queues-you-need&#34;&gt;Identify the Queues You Need&lt;/h3&gt;

&lt;p&gt;(确定你需要的队列)&lt;/p&gt;

&lt;p&gt;现在你的任务已经分解成了不同的工作单元封装在Block对象和操作对象中，你需要定义你要用来执行任务的队列。对于一个给定的任务，检查你创建的Block和操作对象以及它们的执行顺序以确保正确执行了任务。&lt;/p&gt;

&lt;p&gt;如果你使用Block来实现任务，你可以将这些任务添加到串行或者并行的调度队列。如果要求指定的执行顺序，你应该总是将Block添加到串行的调度队列。如果不需要指定的执行顺序，你可以将Block添加到并行的调度队列或者添加到几个不同的调度队列，取决于你的需求。&lt;/p&gt;

&lt;p&gt;如果你使用操作对象来实现任务，队列的选择通常对你的对象的配置不感兴趣。要串行的执行操作对象，你必需在两个对象之间配置依赖。依赖可以防止一个操作在另一个操作还在执行时就开始，在一个操作完成工作之后再开始执行。&lt;/p&gt;

&lt;h3 id=&#34;tips-for-improving-efficiency&#34;&gt;Tips for Improving Efficiency&lt;/h3&gt;

&lt;p&gt;(提高效率的技巧)&lt;/p&gt;

&lt;p&gt;除了简单地把任务分解，并把它们添加到队列，还有其它的方法来提升使用队列的效率：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;考虑到任务中直接计算值时，内存使用是一个因素。如果你的应用程序已经使用大量内存，那么直接计算值可能比从主内存中直接加载缓存更快。直接计算值使用寄存器和给定处理器内核的高速缓存，比主内存要快很多。当然，经过测试这样有性能提升的时候你才可以这么做。&lt;/li&gt;
&lt;li&gt;尽可能早的识别串行任务，然后尽你可能的让它们更多的并发。如果一个任务必需要串行的执行，是因为它依赖于一些共享资源，可以考虑改变架构来移除这些共享资源。你也可能会考虑为每一个客户端复制一份资源来消除共享资源。&lt;/li&gt;
&lt;li&gt;避免使用锁。由于调度队列和操作队列的支持使得锁在大部分情形下并不需要。比起使用锁来保护共享资源，指定一个串行队列(或者使用操作对象依赖)按照正确的顺序执行任务更好。&lt;/li&gt;
&lt;li&gt;只要可能，尽可能多的依靠系统框架。实现并发的最好的方法就是利用系统提供的内建的并发框架的优势。很多框架使用线程，其它很多技术在内部实现并发行为。当你定义你的任务时，查看现有框架是否定义了函数或者方法正是你需要的。使用这些API可以节省你很多的精力，更可能会给你带来更大的并发可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;performance-implications&#34;&gt;Performance Implications&lt;/h2&gt;

&lt;p&gt;(性能影响)&lt;/p&gt;

&lt;p&gt;操作队列，调度队列，调度源是为你简化你的并发编程。然而，这些技术并没有保证会提高你应用程序的效率和响应速度。使用队列时既有效的满足了你的需求并且对其它程序资源没有操作负担是你的责任。比如，尽管你可以创建10000个操作对象，然后提交到操作队列，这样做会导致应用程序会分配一个潜在的大量的内存，这会导致应用程序性能下降。&lt;/p&gt;

&lt;p&gt;在将并发引入你的代码前，不管是使用队列或者是线程，你应该总是搜集你应用程序当前性能的一些基本指标。在引入并发后你应该搜集另外的性能指标，然后和之前的基本指标进行对比，检查你应用程序的效率是否有所提升。如果应用程序的效率和反应低下，你应该使用可用的性能工具来检查潜在的原因。&lt;/p&gt;

&lt;p&gt;关于性能的介绍以及测试性能的工具，更多高级性能的话题，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410&#34;&gt; Performance Overview &lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;concurrency-and-other-technologies&#34;&gt;Concurrency and Other Technologies&lt;/h2&gt;

&lt;p&gt;(并发和其它技术)&lt;/p&gt;

&lt;p&gt;将你的任务代码模块化是提升你应用程序并发量的有效途径。然而，这种设计方法可能无法满足在每种情况下每一个应用程序的需要。根据你的任务，可能还有其它的选择能够给应用程序提供更好的并发性能。本节将介绍一些其它的技术，在你设计程序的时候可以考虑使用。&lt;/p&gt;

&lt;h3 id=&#34;opencl-and-concurrency&#34;&gt;OpenCL and Concurrency&lt;/h3&gt;

&lt;p&gt;(OpenCL和并发)&lt;/p&gt;

&lt;p&gt;在OS X中，OpenCL是一个基于标准的技术，用来在计算机的图形处理器进行通用计算。如果你有一个明确定义的一组要应用到大型数据集的计算，那么OpenCL是这方面很好的一个技术。比如，你可以使用OpenCL对图像的像素进行滤波计算或者一次对多个值进行复杂的数学计算。换句话说，OpenCL面向的是数据需要并行处理的问题集。&lt;/p&gt;

&lt;p&gt;虽然OpenCL适用于大规模的并行数据计算，但是并不适用于通用的计算。需要大量的工作来准备传输数据和内核上的工作到显卡上，以便于在GPU上操作。同样的，找回OpenCL生成的结果也需要大量的工作量。结论就是，通常和系统交互的任何任务生成的数据不要与OpenCL交互。比如，你不会使用OpenCL来处理文件数据和网络流数据。相反，你用于OpenCL处理的数据必需更加自包含，便于传输给图形处理器独立运算。&lt;/p&gt;

&lt;p&gt;更多关于OpenCL以及如何使用，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Performance/Conceptual/OpenCL_MacProgGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008312&#34;&gt; OpenCL Programming Guide for Mac &lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;when-to-use-threads&#34;&gt;When to Use Threads&lt;/h3&gt;

&lt;p&gt;(什么时候使用线程)&lt;/p&gt;

&lt;p&gt;尽管操作队列和调度队列是执行并发任务的首选，但它们不是万能的。取决于你的应用程序，仍然有你需要创建自定义线程的时候。如果你需要创建自定义的线程，你应该尽可能少的创建线程，你应该使用这些线程来执行那些其它方法无法实现的任务。&lt;/p&gt;

&lt;p&gt;线程仍然是实现实时运行代码的好方法。调度队列会尽可能快的执行它们的任务，但它们并没有真正解决时间限制。如果你需要后台运行的代码有更可预测的行为，线程可能依然是更好的选择。&lt;/p&gt;

&lt;p&gt;对于任何线程编程，你始终应该明智的使用且只在绝对必要的时候使用。关于线程包及如何使用，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i&#34;&gt; Threading Programming Guide &lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Concurrency Programming Guide - Introduction</title>
      <link>http://lynchwong.com/2016/01/concurrency-programming-guide---introduction/</link>
      <pubDate>Thu, 14 Jan 2016 13:44:09 +0000</pubDate>
      
      <guid>http://lynchwong.com/2016/01/concurrency-programming-guide---introduction/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091-CH1-SW1&#34;&gt;官方文档&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;之前的编程指南我都是写在一篇博客里的，发现有的太长了。感觉上不利于编辑也不利于查找，所以我现在就分成几篇来完成，每个大章节单独用一篇来。&lt;/p&gt;

&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;

&lt;p&gt;重要提示：这是一份正在开发中的API或者技术的初步文档。虽然这个文档已经被技术准确性审核，但是这并不是最终的。&lt;/p&gt;

&lt;p&gt;并发的概念就是多个事务发生在同一时间。随着多核CPU的增值以及意识到每个处理器中的内核数量只会增加，所以软件设计者需要新的方法来利用这些优势。尽管像OS X和iOS这样的操作系统都能够并行运行多个程序，大部分这些程序都运行在后台，执行任务时都需要处理器的一小段连续的时间。而前台的应用程序捕捉了用户的注意力，并且使计算机处于繁忙的状态。如果一个应用程序有很多工作要做，但是这些工作只保持在部分的内核上运行，那么这些额外的处理器资源(其它的内核)就浪费了。&lt;/p&gt;

&lt;p&gt;在过去，在应用程序中引进并发编程要求创建一个或者更多的额外线程。不幸的是编写线程代码很有挑战性。线程属于底层工具，必须手动管理。鉴于一个应用程序的线程数量会根据当前系统负载和底层硬件动态变化，实现一个正确的线程解决方案极其困难，几乎不可能实现。除此之外，用于线程的同步机制通常会给软件设计带来额外的复杂性和风险，这些并不能保证会提升性能。&lt;/p&gt;

&lt;p&gt;OS X和iOS都采用更异步的方式来执行这些任务，而不是像传统的基于线程的系统和应用程序那样。应用程序只需要定义特定的任务，然后让系统执行它们，而不是去直接创建线程。我们让系统来管理线程，应用程序从而获得了一个数量级的可拓展性，而这些在编写线程代码时是不可能的。应用程序的开发者也获得了简单以及高效的编程模型。&lt;/p&gt;

&lt;p&gt;本文档介绍的技术，你应该用在你的应用程序中来实现并发。这些技术适用于OS X和iOS。&lt;/p&gt;

&lt;h2 id=&#34;本文档的结构&#34;&gt;本文档的结构&lt;/h2&gt;

&lt;p&gt;本文档包含如下章节：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://lynchwong.com/2016/01/14/Concurrency-Programming-Guide-Concurrency-and-Application-Design/&#34;&gt; Concurrency and Application Design &lt;/a&gt;介绍了异步应用程序设计的基础，以及异步执行你自定义操作的技术的基础。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lynchwong.com/2016/01/14/Concurrency-Programming-Guide-Operation-Queues/&#34;&gt; Operation Queues &lt;/a&gt;介绍了如何使用Objective-C对象来封装和执行任务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lynchwong.com/2016/01/14/Concurrency-Programming-Guide-Dispatch-Queues/&#34;&gt; Dispatch Queues &lt;/a&gt;介绍了基于C的应用程序如何并发执行任务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lynchwong.com/2016/01/14/Concurrency-Programming-Guide-Dispatch-Sources/&#34;&gt; Dispatch Sources &lt;/a&gt;展示了如何异步处理系统事件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lynchwong.com/2016/01/14/Concurrency-Programming-Guide-Migrating-Away-from-Threads/&#34;&gt; Migrating Away from Threads &lt;/a&gt;提供如何将你基于线程的代码进行迁移的方法和技术，从而使用更新的技术。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文档也包含了定义相关条款的一些术语。&lt;/p&gt;

&lt;h2 id=&#34;术语&#34;&gt;术语&lt;/h2&gt;

&lt;p&gt;在进行讨论并发之前，有必要来定义一些相关的术语来避免困惑。一些熟悉&lt;strong&gt;UNIX&lt;/strong&gt;和&lt;strong&gt;OS X&lt;/strong&gt;系统的开发者可能发现了“task”, “process”, 和 “thread”在文档中的使用不一样方式不太一样。本文档以如下方式来使用这些术语：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;术语线程用来指执行代码的一个单独的路径。在OS X中的线程的底层实现是基于POSIX线程的API。&lt;/li&gt;
&lt;li&gt;术语进程用于指正在运行的可执行的，它可以包括多个线程。&lt;/li&gt;
&lt;li&gt;术语任务用来指需要被执行的工作的抽象概念。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于完整的术语的定义，以及本文档中使用到的术语，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW2&#34;&gt; Glossary &lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;参见&#34;&gt;参见&lt;/h2&gt;

&lt;p&gt;本文档专注于如何在你的应用程序中实现并发编程，而没有覆盖线程的使用。如果你需要关于使用线程的信息和其它线程相关的技术，参见&lt;a href=&#34;https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i&#34;&gt; Threading Programming Guide &lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>